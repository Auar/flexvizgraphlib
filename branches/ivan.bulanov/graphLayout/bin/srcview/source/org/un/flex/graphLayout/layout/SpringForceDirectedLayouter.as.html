<!-- saved from url=(0014)about:internet -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<title>SpringForceDirectedLayouter.as</title>
<link rel="stylesheet" type="text/css" href="../../../../../../SourceStyles.css"/>
</head>

<body><pre><span class="asComment">/* 
 * The MIT License
 *
 * Copyright (c) 2007 The SixDegrees Project Team
 * (Jason Bellone, Juan Rodriguez, Segolene de Basquiat, Daniel Lang).
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the &quot;Software&quot;), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */</span>
<span class="asPackage">package</span> org.un.flex.graphLayout.layout <span class="asBracket">{</span>

    <span class="asReserved">import</span> org.un.flex.graphLayout.visual.IVisualGraph;
    <span class="asReserved">import</span> flash.events.Event;
    <span class="asReserved">import</span> org.un.flex.graphLayout.data.IGraph;
    <span class="asReserved">import</span> org.un.flex.graphLayout.data.Graph;
    <span class="asReserved">import</span> org.un.flex.graphLayout.visual.IVisualNode;
    <span class="asReserved">import</span> org.un.flex.graphLayout.data.IEdge;
    <span class="asReserved">import</span> org.un.flex.graphLayout.data.INode;
    <span class="asReserved">import</span> org.un.flex.graphLayout.visual.IVisualEdge;
    <span class="asReserved">import</span> flash.utils.Dictionary;
    <span class="asReserved">import</span> flash.events.MouseEvent;
    <span class="asReserved">import</span> flash.events.TimerEvent;
    <span class="asReserved">import</span> mx.core.UIComponent;
    <span class="asReserved">import</span> flash.geom.Rectangle;
    <span class="asReserved">import</span> flash.utils.Timer;
    <span class="asReserved">import</span> flash.geom.Point;
    
    <span class="asDoc">/**
     * This is an implementation of the ForceDirected/SpringGraph
     * Layouting algorithm. The implementation took the general
     * idea    from Mark Shepherd&apos;s SpringGraph component implementation
     * which is itself based on TouchGraph (Java). However, apart from
     * the general idea and some variable names, the code is a rewrite.
     * 
     * Here is the copyright information that was part of the code. I add
     * it just in case someone might feel offended if it is not there:
     * 
     * Copyright of the original TouchGraph LLC code:
     * (c) 2001-2002 Alexander Shapiro. All rights reserved.
     * Copyright of the adaption to Flex:
     * (c) Mark Shepherd, Adobe FlexBuilder Engineering, 2006.
     * Copyright of this reimplementation in Flex:
     * (c) Daniel Lang, United Nations, 2007.
     * 
     * See license infortmation at the top.
     * */</span>
    <span class="asReserved">public</span> <span class="asClass">class</span> SpringForceDirectedLayouter <span class="asReserved">extends</span> BaseLayouter <span class="asReserved">implements</span> ILayoutAlgorithm <span class="asBracket">{</span>
        
        <span class="asDoc">/**
         * @internal
         * Timing related constants.
         * */</span>
        <span class="asReserved">private</span> <span class="asReserved">const</span> _TIMERDELAY<span class="asOperator">:</span>Number <span class="asOperator">=</span> 10;
        <span class="asReserved">private</span> <span class="asReserved">const</span> _TIMERREPCOUNT<span class="asOperator">:</span>int <span class="asOperator">=</span> 2;

        <span class="asDoc">/**
         * @internal
         * This controls the amount of adjustement passes during one
         * layout cycle. */</span>
        <span class="asReserved">private</span> <span class="asReserved">const</span> _RELAXPASSES<span class="asOperator">:</span>int <span class="asOperator">=</span> 5;
        
        <span class="asDoc">/**
         * @internal
         * The maximum distance in pixels, that a node is allowed
         * to move during one layout cycle */</span>
        <span class="asReserved">private</span> <span class="asReserved">const</span> _MOVEPIXELLIMIT<span class="asOperator">:</span>int <span class="asOperator">=</span> 60;
        
        <span class="asDoc">/**
         * @internal
         * The ideal coverage for autofit is 90% 
         * */</span>
        <span class="asReserved">private</span> <span class="asReserved">const</span> _AUTOFITCOVERAGE<span class="asOperator">:</span>Number <span class="asOperator">=</span> 0.9;
        
        <span class="asDoc">/**
         * @internal
         * There is also a tolerance of 3% to be within
         * the ideal coverage.
         * */</span>
        <span class="asReserved">private</span> <span class="asReserved">const</span> _AUTOFITCOVERTOLERANCE<span class="asOperator">:</span>Number <span class="asOperator">=</span> 0.03;
        
        <span class="asComment">/* the timer object */</span>
        <span class="asReserved">private</span> <span class="asVar">var</span> _timer<span class="asOperator">:</span>Timer <span class="asOperator">=</span> <span class="asReserved">null</span>;
        
        <span class="asComment">/* the damper cools down the movement
         * it may range be from 0.0 (no movement) to
         * 1.0 (no damping */</span>
        <span class="asReserved">private</span> <span class="asVar">var</span> _damper<span class="asOperator">:</span>Number <span class="asOperator">=</span> 0.1;
        
        <span class="asComment">/* max motion keeps track of the fastest moving nodes
         * to see if the graph stabilises */</span>
        <span class="asReserved">private</span> <span class="asVar">var</span> _maxMotion<span class="asOperator">:</span>Number <span class="asOperator">=</span> 0.0;
        <span class="asReserved">private</span> <span class="asVar">var</span> _maxMotionTmp<span class="asOperator">:</span>Number <span class="asOperator">=</span> 0.0;
        <span class="asReserved">private</span> <span class="asVar">var</span> _lastMaxMotion<span class="asOperator">:</span>Number <span class="asOperator">=</span> 0.0;
        
        <span class="asComment">/* this is used during motion limiting */</span>
        <span class="asReserved">private</span> <span class="asVar">var</span> _motionRatio<span class="asOperator">:</span>Number <span class="asOperator">=</span> 0.0;
        
        <span class="asComment">/* cutoff limit for max motion */</span>
        <span class="asReserved">private</span> <span class="asVar">var</span> _motionLimit<span class="asOperator">:</span>Number <span class="asOperator">=</span> 0.01;
        
        <span class="asComment">/* general setting whether to activate damping or not */</span>
        <span class="asReserved">private</span> <span class="asVar">var</span> _dampingActive<span class="asOperator">:</span>Boolean <span class="asOperator">=</span> <span class="asReserved">true</span>;
        
        <span class="asComment">/* a constant with a similar effect as damping
         * low means things go slow, too high will cause oscillation */</span>
        <span class="asReserved">private</span> <span class="asVar">var</span> _rigidity<span class="asOperator">:</span>Number <span class="asOperator">=</span> 0.25;
        <span class="asReserved">private</span> <span class="asVar">var</span> _newRigidity<span class="asOperator">:</span>Number <span class="asOperator">=</span> 0.25;
        
        <span class="asComment">/* for dragging and dropping */</span>
        <span class="asReserved">private</span> <span class="asVar">var</span> _dragNode<span class="asOperator">:</span>IVisualNode <span class="asOperator">=</span> <span class="asReserved">null</span>;

        <span class="asComment">/* each node has it&apos;s own repulsion value, which is
         * kept in this map. The values are calculated on the fly
         * using updateRepulsion()
         * keys are VisualNodes, values are Numbers */</span>
        <span class="asReserved">private</span> <span class="asVar">var</span> _repulsionMap<span class="asOperator">:</span>Dictionary;
        
        <span class="asComment">/* for each node we keep a &apos;delta&apos; value for its
         * coordinates. */</span>
        <span class="asReserved">private</span> <span class="asVar">var</span> _deltaPositions<span class="asOperator">:</span>Dictionary;
        
        <span class="asComment">/* this is a global adjustement factor for the repulsion
         * it&apos;s access will be controlled by the linkLength access
         * methods */</span>
        <span class="asReserved">private</span> <span class="asVar">var</span> _repulsionFactor<span class="asOperator">:</span>Number;
        <span class="asReserved">private</span> <span class="asVar">var</span> _prevRepulsionFactor<span class="asOperator">:</span>Number;

        <span class="asComment">/* required for this specific 
         * autofit implementation */</span>
        <span class="asReserved">private</span> <span class="asVar">var</span> _prevCoverage<span class="asOperator">:</span>Number <span class="asOperator">=</span> 0;

        <span class="asDoc">/**
         * The constructor only initialises the data structures and presets
         * some parameters.
         * */</span>
        <span class="asReserved">public</span> <span class="asFunction">function</span> SpringForceDirectedLayouter<span class="asBracket">(</span>vg<span class="asOperator">:</span>IVisualGraph <span class="asOperator">=</span> <span class="asReserved">null</span><span class="asBracket">)</span><span class="asOperator">:</span><span class="asReserved">void</span> <span class="asBracket">{</span>
            <span class="asReserved">super</span><span class="asBracket">(</span>vg<span class="asBracket">)</span>;
            
            _repulsionMap <span class="asOperator">=</span> <span class="asReserved">new</span> Dictionary;
            _deltaPositions <span class="asOperator">=</span> <span class="asReserved">new</span> Dictionary;
        
            _repulsionFactor <span class="asOperator">=</span> 0.3;
            _prevRepulsionFactor <span class="asOperator">=</span> 0.0;
        <span class="asBracket">}</span>

        <span class="asDoc">/**
         * Reset all layouting parameters, which may be
         * required during a significant layout change.
         * This is particularily important in this layouter,
         * as it constantly updates the layout (using the timer).
         * */</span>
        <span class="asReserved">override</span> <span class="asReserved">public</span> <span class="asFunction">function</span> resetAll<span class="asBracket">()</span><span class="asOperator">:</span><span class="asReserved">void</span> <span class="asBracket">{</span>
            
            <span class="asReserved">if</span><span class="asBracket">(</span>_timer <span class="asOperator">!=</span> <span class="asReserved">null</span><span class="asBracket">)</span> <span class="asBracket">{</span>
                _timer.stop<span class="asBracket">()</span>
                _timer <span class="asOperator">=</span> <span class="asReserved">null</span>;
                <span class="asComment">//trace(&quot;Timer STOPPED&quot;);
</span>            <span class="asBracket">}</span>
            
            _damper <span class="asOperator">=</span> 0.1;
            _maxMotion <span class="asOperator">=</span> 0.0;
            _maxMotionTmp <span class="asOperator">=</span> 0.0;
            _lastMaxMotion <span class="asOperator">=</span> 0.0;
        
            _motionRatio <span class="asOperator">=</span> 0.0;
            _dampingActive <span class="asOperator">=</span> <span class="asReserved">true</span>;
            _motionLimit <span class="asOperator">=</span> 0.01;
            
            _rigidity <span class="asOperator">=</span> 0.25;
            _newRigidity <span class="asOperator">=</span> 0.25;

            _dragNode <span class="asOperator">=</span> <span class="asReserved">null</span>;
            
            _deltaPositions <span class="asOperator">=</span> <span class="asReserved">new</span> Dictionary;
            _repulsionMap <span class="asOperator">=</span> <span class="asReserved">new</span> Dictionary;
            _repulsionFactor <span class="asOperator">=</span> 0.3;
            _prevRepulsionFactor <span class="asOperator">=</span> 0.0;
            _prevCoverage <span class="asOperator">=</span> 0;
            _layoutChanged <span class="asOperator">=</span> <span class="asReserved">true</span>;
        <span class="asBracket">}</span>

        <span class="asDoc">/**
         * This is the actual method that does a layout pass. In this
         * Layouter, it is supposed to interrupt and kick-off a new
         * layout cycle, which is different from most others, since this
         * layouter keeps on calculating the layout through a timer.
         * */</span>
        <span class="asReserved">override</span> <span class="asReserved">public</span> <span class="asFunction">function</span> layoutPass<span class="asBracket">()</span><span class="asOperator">:</span>Boolean <span class="asBracket">{</span>
            
            <span class="asComment">/*
            trace(&quot;layoutPass called&quot;);
            */</span>
            
            <span class="asComment">/* if we have a current timer running, kill it off
             * to avoid mutiple unnecessary calls */</span>
            <span class="asReserved">if</span><span class="asBracket">(</span>_timer <span class="asOperator">!=</span> <span class="asReserved">null</span><span class="asBracket">)</span> <span class="asBracket">{</span>
                _timer.stop<span class="asBracket">()</span>;
                _timer <span class="asOperator">=</span> <span class="asReserved">null</span>;
            <span class="asBracket">}</span>
            
            <span class="asComment">/* now start the calculation and computation */</span>
            <span class="asReserved">return</span> calculateLayout<span class="asBracket">()</span>;
        <span class="asBracket">}</span>
        
        <span class="asDoc">/**
         * In this implementation, this method resets the damper
         * value.
         * */</span>
        <span class="asReserved">override</span> <span class="asReserved">public</span> <span class="asFunction">function</span> refreshInit<span class="asBracket">()</span><span class="asOperator">:</span><span class="asReserved">void</span> <span class="asBracket">{</span>
            resetDamper<span class="asBracket">()</span>;
        <span class="asBracket">}</span>
        
        <span class="asDoc">/**
         * This method notifies the layouter about a drag/drop
         * operation. This is important to exempt are currently
         * dragged node from the layouting, to allow it to drag
         * the whole graph with it. This method basically sets the
         * current drag node.
         * @param event The mouse event that is fired on the starting of the drag operation.
         * @param vn The node which is being dragged.
         * */</span>
        <span class="asReserved">override</span> <span class="asReserved">public</span> <span class="asFunction">function</span> dragEvent<span class="asBracket">(</span>event<span class="asOperator">:</span>MouseEvent, vn<span class="asOperator">:</span>IVisualNode<span class="asBracket">)</span><span class="asOperator">:</span><span class="asReserved">void</span> <span class="asBracket">{</span>
            <span class="asComment">/* we have to make sure, that what we want
             * to drag is actually a UIComponent, i.e. 
             * part of our nodes, if not we do nothing. */</span>
            <span class="asComment">//trace(&quot;layouter received a drag event&quot;);
</span>            <span class="asReserved">if</span><span class="asBracket">(</span>event.currentTarget <span class="asReserved">is</span> UIComponent<span class="asBracket">)</span> <span class="asBracket">{</span>
                _dragNode <span class="asOperator">=</span> vn;
            <span class="asBracket">}</span>
        <span class="asBracket">}</span>
        
        <span class="asDoc">/**
         * If we receive a drop event, we delete the drag node.
         * @param event The mouse event that is fired on the starting of the drag operation.
         * @param vn The node which is being dragged.
         * */</span>
        <span class="asReserved">override</span> <span class="asReserved">public</span> <span class="asFunction">function</span> dropEvent<span class="asBracket">(</span>event<span class="asOperator">:</span>MouseEvent, vn<span class="asOperator">:</span>IVisualNode<span class="asBracket">)</span><span class="asOperator">:</span><span class="asReserved">void</span> <span class="asBracket">{</span>
            _dragNode <span class="asOperator">=</span> <span class="asReserved">null</span>;
        <span class="asBracket">}</span>
        

        <span class="asDoc">/**
         * @inheritDoc
         * */</span>
        <span class="asReserved">override</span> <span class="asReserved">public</span> <span class="asFunction">function</span> <span class="asReserved">set</span> linkLength<span class="asBracket">(</span>f<span class="asOperator">:</span>Number<span class="asBracket">)</span><span class="asOperator">:</span><span class="asReserved">void</span> <span class="asBracket">{</span>
            _repulsionFactor <span class="asOperator">=</span> <span class="asBracket">(</span>f <span class="asOperator">/</span> 100 <span class="asOperator">*</span> 1.5<span class="asBracket">)</span>;
        <span class="asBracket">}</span>
        
        <span class="asDoc">/**
         * @private
         * */</span>
        <span class="asReserved">override</span> <span class="asReserved">public</span> <span class="asFunction">function</span> <span class="asReserved">get</span> linkLength<span class="asBracket">()</span><span class="asOperator">:</span>Number <span class="asBracket">{</span>
            <span class="asReserved">return</span> <span class="asBracket">(</span>_repulsionFactor <span class="asOperator">/</span> 1.5 <span class="asOperator">*</span> 100<span class="asBracket">)</span>;
        <span class="asBracket">}</span>
        


        <span class="asDoc">/**
         * This is a local parameter specific to this layouter, that may
         * be accessed from outside, if required. It handles how flexible
         * the springy edges are.
         * @param r The new rigidity value.
         * */</span>
        <span class="asReserved">public</span> <span class="asFunction">function</span> <span class="asReserved">set</span> rigidity<span class="asBracket">(</span>r<span class="asOperator">:</span>Number<span class="asBracket">)</span><span class="asOperator">:</span><span class="asReserved">void</span> <span class="asBracket">{</span>
            _newRigidity <span class="asOperator">=</span> r;
        <span class="asBracket">}</span>

        <span class="asDoc">/**
         * This is a specific method for this layouter and
         * specifies if damping should be used or not.
         * */</span>
        <span class="asReserved">public</span> <span class="asFunction">function</span> <span class="asReserved">set</span> dampingActive<span class="asBracket">(</span>da<span class="asOperator">:</span>Boolean<span class="asBracket">)</span><span class="asOperator">:</span><span class="asReserved">void</span> <span class="asBracket">{</span>
    
            <span class="asComment">/* check for a change */</span>
            <span class="asReserved">if</span><span class="asBracket">(</span>_dampingActive <span class="asOperator">!=</span> da<span class="asBracket">)</span> <span class="asBracket">{</span>
                <span class="asComment">/* set the new value */</span>
                _dampingActive <span class="asOperator">=</span> da;
                
                <span class="asComment">/* reset the damper value if disabled */</span>
                <span class="asReserved">if</span><span class="asBracket">(</span>da <span class="asOperator">==</span> <span class="asReserved">false</span><span class="asBracket">)</span> <span class="asBracket">{</span>
                    _damper <span class="asOperator">=</span> 1.0;
                <span class="asBracket">}</span>                
            <span class="asBracket">}</span>
        <span class="asBracket">}</span>
        
        <span class="asDoc">/**
         * @private
         * */</span>
        <span class="asReserved">public</span> <span class="asFunction">function</span> <span class="asReserved">get</span> dampingActive<span class="asBracket">()</span><span class="asOperator">:</span>Boolean <span class="asBracket">{</span>
            <span class="asReserved">return</span> _dampingActive;
        <span class="asBracket">}</span>
        
        <span class="asDoc">/**
         * Reset the damper but keep damping.
         * @internal
         * (in the original code the comment said &apos;don&apos;t keep damping&apos;
         * but the dampingActive remains true....
         * */</span>
        <span class="asReserved">private</span> <span class="asFunction">function</span> resetDamper<span class="asBracket">()</span><span class="asOperator">:</span><span class="asReserved">void</span> <span class="asBracket">{</span>
            _dampingActive <span class="asOperator">=</span> <span class="asReserved">true</span>;
            _damper <span class="asOperator">=</span> 1.0;
        <span class="asBracket">}</span>
        
        <span class="asDoc">/**
         * Stabilises the graph gently by setting the damper
         * to a low value.
         * */</span>
        <span class="asReserved">private</span> <span class="asFunction">function</span> stopMotion<span class="asBracket">()</span><span class="asOperator">:</span><span class="asReserved">void</span> <span class="asBracket">{</span>
            _dampingActive <span class="asOperator">=</span> <span class="asReserved">true</span>;
            <span class="asReserved">if</span><span class="asBracket">(</span>_damper <span class="asOperator">&gt;</span> 0.3<span class="asBracket">)</span> <span class="asBracket">{</span>
                _damper <span class="asOperator">=</span> 0.3;
            <span class="asBracket">}</span> <span class="asReserved">else</span> <span class="asBracket">{</span>
                <span class="asComment">/* this stops all movement, until the damper is reset */</span>
                _damper <span class="asOperator">=</span> 0.0;
            <span class="asBracket">}</span>
        <span class="asBracket">}</span>
        
        <span class="asDoc">/**
         * @internal
         * experimental code with the motionThreshold
         * may be eliminated.
         * */</span>
        <span class="asReserved">private</span> <span class="asFunction">function</span> <span class="asReserved">set</span> motionThreshold<span class="asBracket">(</span>t<span class="asOperator">:</span>Number<span class="asBracket">)</span><span class="asOperator">:</span><span class="asReserved">void</span> <span class="asBracket">{</span>
            _motionLimit <span class="asOperator">=</span> t;
            _layoutChanged <span class="asOperator">=</span> <span class="asReserved">true</span>;
        <span class="asBracket">}</span>

        <span class="asDoc">/**
         * @private
         * similarly experimental, do not expose it right now.
         * */</span>
        <span class="asReserved">private</span> <span class="asFunction">function</span> <span class="asReserved">get</span> motionThreshold<span class="asBracket">()</span><span class="asOperator">:</span>Number <span class="asBracket">{</span>
            <span class="asReserved">return</span> _motionLimit;
        <span class="asBracket">}</span>

        <span class="asDoc">/**
         * @internal
         * do a full calculation of the layout, also trigger the
         * timer to repeat doing it a couple of times.
         * */</span>
        <span class="asReserved">private</span> <span class="asFunction">function</span> calculateLayout<span class="asBracket">()</span><span class="asOperator">:</span>Boolean <span class="asBracket">{</span>
            
            <span class="asComment">/* return value, not really used */</span>
            <span class="asVar">var</span> rv<span class="asOperator">:</span>Boolean <span class="asOperator">=</span> <span class="asReserved">true</span>;
            
            <span class="asComment">//trace(&quot;calculate called&quot;);
</span>            <span class="asComment">//trace(&quot;Repulsion: &quot;+_repulsionFactor+&quot; AF:&quot;+_autoFitEnabled.toString());
</span>            <span class="asComment">//trace(&quot;d: &quot;+_damper+&quot; dactive: &quot;+_dampingActive.toString()+&quot; mM: &quot;+_maxMotion+&quot; mL: &quot;+_motionLimit);
</span>            
            <span class="asComment">/* call the relax method to pull on the edges */</span>
            relax<span class="asBracket">()</span>;
            
            <span class="asReserved">if</span><span class="asBracket">(</span>_autoFitEnabled<span class="asBracket">)</span> <span class="asBracket">{</span>
                calculateAutoFit<span class="asBracket">()</span>;
            <span class="asBracket">}</span>
            
            <span class="asComment">/* indicated that the layout has changed */</span>
            _layoutChanged <span class="asOperator">=</span> <span class="asReserved">true</span>;
            
            _vgraph.dispatchEvent<span class="asBracket">(</span><span class="asReserved">new</span> Event<span class="asBracket">(</span><span class="asString">&quot;vgraphChanged&quot;</span><span class="asBracket">))</span>;
            
            <span class="asComment">/* maybe we could/should invalidate the display list? */</span>
            
            <span class="asComment">/* if we have no timer running, kick of the timer */</span>
            <span class="asReserved">if</span><span class="asBracket">(</span>_timer <span class="asOperator">==</span> <span class="asReserved">null</span><span class="asBracket">)</span> <span class="asBracket">{</span>            
                startTimer<span class="asBracket">()</span>;
            <span class="asBracket">}</span>
            
            <span class="asComment">/* return always true for now */</span>
            <span class="asReserved">return</span> rv;
        <span class="asBracket">}</span> 

        
        <span class="asDoc">/**
         * @internal
         * This starts the timer, which essentially kicks off the
         * iterative layout calculation until the layout has stabilised.
         * */</span>
        <span class="asReserved">private</span> <span class="asFunction">function</span> startTimer<span class="asBracket">()</span><span class="asOperator">:</span><span class="asReserved">void</span> <span class="asBracket">{</span>
            _timer <span class="asOperator">=</span> <span class="asReserved">new</span> Timer<span class="asBracket">(</span>_TIMERDELAY, _TIMERREPCOUNT<span class="asBracket">)</span>;
            _timer.addEventListener<span class="asBracket">(</span>TimerEvent.TIMER_COMPLETE, timerFired<span class="asBracket">)</span>;
            _timer.start<span class="asBracket">()</span>;
        <span class="asBracket">}</span>
        
        <span class="asDoc">/**
         * @internal
         * When the timer fired, this calls a layout pass, but it
         * should rather call a different function that implements the
         * real layout passes to avoid calling layoutpass too often.
         * Also multiple calls could get created.
         * */</span>
        <span class="asReserved">private</span> <span class="asFunction">function</span> timerFired<span class="asBracket">(</span>event<span class="asOperator">:</span>TimerEvent <span class="asOperator">=</span> <span class="asReserved">null</span><span class="asBracket">)</span><span class="asOperator">:</span><span class="asReserved">void</span> <span class="asBracket">{</span>
            
            <span class="asComment">//trace(&quot;Timer fired!&quot;);
</span>            
            <span class="asComment">/* repeat the calculation */</span>
            calculateLayout<span class="asBracket">()</span>;
            
            <span class="asComment">/* should be enough to prevent timer cascades */</span>        
            startTimer<span class="asBracket">()</span>;
        <span class="asBracket">}</span>
        
        <span class="asDoc">/**
         * @internal
         * This method calculates and adjusts the repulsion 
         * values for each node, in order for the graph to
         * fit into ~ 90 % of the available space.
         * */</span>
        <span class="asReserved">private</span> <span class="asFunction">function</span> calculateAutoFit<span class="asBracket">()</span><span class="asOperator">:</span><span class="asReserved">void</span> <span class="asBracket">{</span>
            
            <span class="asVar">var</span> hCoverage<span class="asOperator">:</span>Number;
            <span class="asVar">var</span> vCoverage<span class="asOperator">:</span>Number;
            <span class="asVar">var</span> coverage<span class="asOperator">:</span>Number;
            <span class="asVar">var</span> missingCoverage<span class="asOperator">:</span>Number;
            <span class="asVar">var</span> deltaCoverage<span class="asOperator">:</span>Number;
            <span class="asVar">var</span> targetDelta<span class="asOperator">:</span>Number;
            
            <span class="asComment">/* scrolling delta */</span>
            <span class="asVar">var</span> scrollX<span class="asOperator">:</span>Number;
            <span class="asVar">var</span> scrollY<span class="asOperator">:</span>Number;
            
            <span class="asComment">/* bounding box of nodes */</span>
            <span class="asVar">var</span> viewbounds<span class="asOperator">:</span>Rectangle <span class="asOperator">=</span> _vgraph.calcNodesBoundingBox<span class="asBracket">()</span>;
            
            <span class="asComment">/* the viewbounds describe the current bounding box of
             * all nodes */</span>
            <span class="asReserved">if</span><span class="asBracket">(</span>viewbounds<span class="asBracket">)</span> <span class="asBracket">{</span>
                
                <span class="asComment">/* using the viewbounds the current percentage in coverage can be
                 * calculated */</span>
                hCoverage <span class="asOperator">=</span> <span class="asBracket">(</span>viewbounds.bottom <span class="asOperator">-</span> viewbounds.top<span class="asBracket">)</span> <span class="asOperator">/</span> _vgraph.height;
                vCoverage <span class="asOperator">=</span> <span class="asBracket">(</span>viewbounds.right <span class="asOperator">-</span> viewbounds.left<span class="asBracket">)</span> <span class="asOperator">/</span> _vgraph.width;
                coverage <span class="asOperator">=</span> Math.max<span class="asBracket">(</span>hCoverage, vCoverage<span class="asBracket">)</span>;
                
                <span class="asTrace">trace</span><span class="asBracket">(</span><span class="asString">&quot;FD af Coverage:&quot;</span><span class="asOperator">+</span>coverage<span class="asBracket">)</span>;
                
                <span class="asReserved">if</span><span class="asBracket">((</span>_prevCoverage <span class="asOperator">&gt;</span> 0<span class="asBracket">)</span> <span class="asOperator">&amp;&amp;</span> <span class="asBracket">(</span>coverage <span class="asOperator">&gt;</span> 0<span class="asBracket">))</span> <span class="asBracket">{</span>
                    
                    <span class="asComment">/* calculate the missing coverage and if we are
                     * within the tolerance limit */</span>
                    missingCoverage <span class="asOperator">=</span> _AUTOFITCOVERAGE <span class="asOperator">-</span> coverage;
                    
                    <span class="asReserved">if</span><span class="asBracket">(</span>Math.abs<span class="asBracket">(</span>missingCoverage<span class="asBracket">)</span> <span class="asOperator">&gt;</span> _AUTOFITCOVERTOLERANCE<span class="asBracket">)</span> <span class="asBracket">{</span>    
                        <span class="asComment">/* We are still more away than the tolerance.
                         * Check how much we changed
                         * from last pass, positive result means
                         * we are still expanding, negative means
                         * we are contracting */</span>
                        deltaCoverage <span class="asOperator">=</span> coverage <span class="asOperator">-</span> _prevCoverage;
                        targetDelta <span class="asOperator">=</span> missingCoverage <span class="asOperator">*</span> 0.2 <span class="asComment">// why?
</span>                        
                        <span class="asTrace">trace</span><span class="asBracket">(</span><span class="asString">&quot;FD af deltaCov:&quot;</span><span class="asOperator">+</span>deltaCoverage<span class="asOperator">+</span><span class="asString">&quot; targetDelta:&quot;</span><span class="asOperator">+</span>targetDelta<span class="asBracket">)</span>;
                        
                        <span class="asComment">/* impose limits */</span>
                        <span class="asReserved">if</span><span class="asBracket">(</span>targetDelta <span class="asOperator">&lt;</span> <span class="asOperator">-</span>0.05<span class="asBracket">)</span> <span class="asBracket">{</span>
                            targetDelta <span class="asOperator">=</span> <span class="asOperator">-</span>0.05;
                        <span class="asBracket">}</span>
                        <span class="asReserved">if</span><span class="asBracket">(</span>targetDelta <span class="asOperator">&gt;</span> 0.05<span class="asBracket">)</span> <span class="asBracket">{</span>
                            targetDelta <span class="asOperator">=</span> 0.05;
                        <span class="asBracket">}</span>
                        
                        <span class="asReserved">if</span><span class="asBracket">(</span>deltaCoverage <span class="asOperator">&lt;</span> targetDelta<span class="asBracket">)</span> <span class="asBracket">{</span>
                            <span class="asComment">/* expansion too slow, more repulsion */</span>
                            _repulsionFactor <span class="asOperator">+=</span> 0.01;
                            
                            <span class="asComment">/* but limit to maximum */</span>
                            <span class="asReserved">if</span><span class="asBracket">(</span>_repulsionFactor <span class="asOperator">&gt;</span> 0.7<span class="asBracket">)</span> <span class="asBracket">{</span>
                                _repulsionFactor <span class="asOperator">=</span> 0.7;
                            <span class="asBracket">}</span>
                            
                        <span class="asBracket">}</span> <span class="asReserved">else</span> <span class="asBracket">{</span>
                            <span class="asComment">/* expansion too fast, or contraction too slow */</span>
                            _repulsionFactor <span class="asOperator">-=</span> 0.01;
                            
                            <span class="asComment">/* limit also minimum */</span>
                            <span class="asReserved">if</span><span class="asBracket">(</span>_repulsionFactor <span class="asOperator">&lt;</span> 0.05<span class="asBracket">)</span> <span class="asBracket">{</span>
                                _repulsionFactor <span class="asOperator">=</span> 0.05;
                            <span class="asBracket">}</span>
                        <span class="asBracket">}</span>
                    <span class="asBracket">}</span>
                <span class="asBracket">}</span>
                _prevCoverage <span class="asOperator">=</span> coverage;
            
                <span class="asComment">/* now check if we moved nodes out of bounds and 
                 * do some scrolling */</span>
                <span class="asReserved">if</span><span class="asBracket">((</span>viewbounds.left <span class="asOperator">&lt;</span> 0<span class="asBracket">)</span> <span class="asOperator">||</span> <span class="asBracket">(</span>viewbounds.top <span class="asOperator">&lt;</span> 0<span class="asBracket">)</span> <span class="asOperator">||</span>
                   <span class="asBracket">(</span>viewbounds.bottom <span class="asOperator">&gt;</span> _vgraph.height<span class="asBracket">)</span> <span class="asOperator">||</span>
                   <span class="asBracket">(</span>viewbounds.right <span class="asOperator">&gt;</span> _vgraph.width<span class="asBracket">))</span> <span class="asBracket">{</span>
                    
                    scrollX <span class="asOperator">=</span> <span class="asBracket">(</span>_vgraph.width <span class="asOperator">/</span> 2<span class="asBracket">)</span> <span class="asOperator">-</span> <span class="asBracket">(</span>viewbounds.x <span class="asOperator">+</span> <span class="asBracket">(</span>viewbounds.width <span class="asOperator">/</span> 2<span class="asBracket">))</span>;
                    scrollY <span class="asOperator">=</span> <span class="asBracket">(</span>_vgraph.height <span class="asOperator">/</span> 2<span class="asBracket">)</span> <span class="asOperator">-</span> <span class="asBracket">(</span>viewbounds.y <span class="asOperator">+</span> <span class="asBracket">(</span>viewbounds.height <span class="asOperator">/</span> 2<span class="asBracket">))</span>;
                       
                       <span class="asComment">/* limit to 1 pixel at a time .... (another probably stupid thing) 
                        * at least it makes things rather slow .... */</span>
                       <span class="asReserved">if</span><span class="asBracket">(</span>scrollX <span class="asOperator">&gt;</span> 5<span class="asBracket">)</span> <span class="asBracket">{</span> 
                           scrollX <span class="asOperator">=</span> 5;
                       <span class="asBracket">}</span>
                       <span class="asReserved">if</span><span class="asBracket">(</span>scrollX <span class="asOperator">&lt;</span> <span class="asOperator">-</span>5<span class="asBracket">)</span> <span class="asBracket">{</span>
                           scrollX <span class="asOperator">=</span> <span class="asOperator">-</span>5;
                       <span class="asBracket">}</span>
                       <span class="asReserved">if</span><span class="asBracket">(</span>scrollY <span class="asOperator">&gt;</span> 5<span class="asBracket">)</span> <span class="asBracket">{</span>
                           scrollY <span class="asOperator">=</span> 5;
                       <span class="asBracket">}</span>
                       <span class="asReserved">if</span><span class="asBracket">(</span>scrollY <span class="asOperator">&lt;</span> <span class="asOperator">-</span>5<span class="asBracket">)</span> <span class="asBracket">{</span>
                           scrollY <span class="asOperator">=</span> <span class="asOperator">-</span>5;
                       <span class="asBracket">}</span>
                       
                       <span class="asComment">/* now scroll */</span>
                       <span class="asReserved">if</span><span class="asBracket">((</span>scrollX <span class="asOperator">!=</span> 0<span class="asBracket">)</span> <span class="asOperator">||</span> <span class="asBracket">(</span>scrollY <span class="asOperator">!=</span> 0<span class="asBracket">))</span> <span class="asBracket">{</span>
                           _vgraph.scroll<span class="asBracket">(</span>scrollX, scrollY<span class="asBracket">)</span>;
                           _layoutChanged <span class="asOperator">=</span> <span class="asReserved">true</span>;
                       <span class="asBracket">}</span>      
                <span class="asBracket">}</span>
            <span class="asBracket">}</span>
            <span class="asReserved">if</span><span class="asBracket">(</span>_prevRepulsionFactor <span class="asOperator">!=</span> _repulsionFactor<span class="asBracket">)</span> <span class="asBracket">{</span>
                _prevRepulsionFactor <span class="asOperator">=</span> _repulsionFactor;
            <span class="asBracket">}</span>
        <span class="asBracket">}</span>
        
        
        <span class="asDoc">/**
         * @internal
         * This is another wrapper function around several
         * layout calculation steps.
         * 1. It updates the repulsion value of each node.
         * 2. It calls relaxEdges which pulls on the edges.
         * 3. It works on each node to separate them by their size and taking the repulsion into account
         * 4. It actually starts moving the nodes (but keeping some constraints).
         * */</span>
        <span class="asReserved">private</span> <span class="asFunction">function</span> relax<span class="asBracket">()</span><span class="asOperator">:</span><span class="asReserved">void</span> <span class="asBracket">{</span>
            
            <span class="asVar">var</span> visVNodes<span class="asOperator">:</span>Dictionary;
            <span class="asVar">var</span> vn<span class="asOperator">:</span>IVisualNode;
            <span class="asVar">var</span> node<span class="asOperator">:</span>INode;
            
            <span class="asComment">/* work on all currently visible VNodes */</span>
            visVNodes <span class="asOperator">=</span> _vgraph.visibleVNodes;
            <span class="asReserved">for</span> <span class="asReserved">each</span><span class="asBracket">(</span>vn <span class="asReserved">in</span> visVNodes<span class="asBracket">)</span> <span class="asBracket">{</span>
                <span class="asComment">//trace(&quot;relax for each node: updating repulsion for: &quot;+node.id);
</span>                
                <span class="asReserved">if</span><span class="asBracket">(</span><span class="asOperator">!</span>vn.isVisible<span class="asBracket">)</span> <span class="asBracket">{</span>
                    <span class="asReserved">throw</span> Error<span class="asBracket">(</span><span class="asString">&quot;Received invisible node while working on visible vnodes only&quot;</span><span class="asBracket">)</span>;
                <span class="asBracket">}</span>
                
                <span class="asComment">/* first update each nodes repulsion value */</span>
                updateRepulsion<span class="asBracket">(</span>vn<span class="asBracket">)</span>;
                
                <span class="asComment">/* now update the coordinates set in the VNode from the vnodes real
                 * coordinates */</span>
                vn.refresh<span class="asBracket">()</span>;
                
                <span class="asComment">/* *
                trace(&quot;node: &quot;+vn.id+&quot; has dx:&quot;+vn.dx+&quot; dy:&quot;+vn.dy+&quot; x:&quot;+vn.x+
                &quot; y:&quot;+vn.y+&quot; viewX:&quot;+vn.viewX+&quot; viewY:&quot;+vn.viewY+&quot; repulsion:&quot;+_repulsionMap[vn]);
                */</span>
            <span class="asBracket">}</span>
            
            <span class="asComment">/* now call the three methods to work on the layout
             * so many times, as required and preset in the constant value */</span>
            <span class="asReserved">for</span><span class="asBracket">(</span><span class="asVar">var</span> i<span class="asOperator">:</span>int<span class="asOperator">=</span>0; i <span class="asOperator">&lt;</span> _RELAXPASSES; <span class="asOperator">++</span>i<span class="asBracket">)</span> <span class="asBracket">{</span>
                <span class="asComment">//trace(&quot;relaxEdges,applyRepulsion,moveNodes, pass: &quot;+i);
</span>                relaxEdges<span class="asBracket">()</span>;
                applyRepulsion<span class="asBracket">()</span>;        
                moveNodes<span class="asBracket">()</span>;
            <span class="asBracket">}</span>
            
            <span class="asComment">/* update rigidity, it may have been set new */</span>
            <span class="asReserved">if</span><span class="asBracket">(</span>_rigidity <span class="asOperator">!=</span> _newRigidity<span class="asBracket">)</span> <span class="asBracket">{</span>
                _rigidity <span class="asOperator">=</span> _newRigidity;
            <span class="asBracket">}</span>
            
            <span class="asComment">/* commit all nodes, basically this sets the
             * view.x to their _x attribute */</span>
            <span class="asReserved">for</span> <span class="asReserved">each</span><span class="asBracket">(</span>vn <span class="asReserved">in</span> visVNodes<span class="asBracket">)</span> <span class="asBracket">{</span>
                <span class="asReserved">if</span><span class="asBracket">(</span><span class="asOperator">!</span>vn.isVisible<span class="asBracket">)</span> <span class="asBracket">{</span>
                    <span class="asReserved">throw</span> Error<span class="asBracket">(</span><span class="asString">&quot;Received invisible node while working on visible vnodes only&quot;</span><span class="asBracket">)</span>;
                <span class="asBracket">}</span>
                vn.commit<span class="asBracket">()</span>;
            <span class="asBracket">}</span>
        <span class="asBracket">}</span>

        <span class="asDoc">/**
         * @internal
         * This method tenses up the edges and pulls the nodes
         * closer. In order to optimize, it should only work on
         * &quot;visible&quot; edges, i.e. edges for which both nodes
         * are visible.
         */</span>
        <span class="asReserved">private</span> <span class="asFunction">function</span> relaxEdges<span class="asBracket">()</span><span class="asOperator">:</span><span class="asReserved">void</span> <span class="asBracket">{</span>
            <span class="asComment">/* we need IEdges first */</span>
            <span class="asVar">var</span> edge<span class="asOperator">:</span>IEdge;
            <span class="asVar">var</span> visEdges<span class="asOperator">:</span>Dictionary <span class="asOperator">=</span> _vgraph.visibleEdges;
            <span class="asReserved">for</span> <span class="asReserved">each</span><span class="asBracket">(</span>edge <span class="asReserved">in</span> visEdges<span class="asBracket">)</span> <span class="asBracket">{</span>
                <span class="asComment">/* now work on the edge */</span>
                pullRubberEdge<span class="asBracket">(</span>edge<span class="asBracket">)</span>;
            <span class="asBracket">}</span>
            
        <span class="asBracket">}</span>
        
        
        <span class="asDoc">/**
         * @internal
         * This methods works on each edge and tries to pull it
         * together. It depends on the current edge length and
         * the general rigidity of edges.
         * @param e The edge which should be pulled together.
         * */</span>
        <span class="asReserved">private</span> <span class="asFunction">function</span> pullRubberEdge<span class="asBracket">(</span>e<span class="asOperator">:</span>IEdge<span class="asBracket">)</span><span class="asOperator">:</span><span class="asReserved">void</span> <span class="asBracket">{</span>
            
            <span class="asVar">var</span> vedge<span class="asOperator">:</span>IVisualEdge <span class="asOperator">=</span> e.vedge;
            <span class="asVar">var</span> vnode1<span class="asOperator">:</span>IVisualNode <span class="asOperator">=</span> e.node1.vnode;
            <span class="asVar">var</span> vnode2<span class="asOperator">:</span>IVisualNode <span class="asOperator">=</span> e.node2.vnode;

            <span class="asComment">/* beware, that this &apos;x&apos; is not the x from the
             * the UIComponent (view) but the attribute
             * from the VisualNode */</span>            
            <span class="asVar">var</span> vx<span class="asOperator">:</span>Number <span class="asOperator">=</span> vnode2.x <span class="asOperator">-</span> vnode1.x; 
            <span class="asVar">var</span> vy<span class="asOperator">:</span>Number <span class="asOperator">=</span> vnode2.y <span class="asOperator">-</span> vnode1.y;
            
            <span class="asComment">/* calculate the actual length of the edge */</span>
            <span class="asVar">var</span> edgelength<span class="asOperator">:</span>Number <span class="asOperator">=</span> Math.sqrt<span class="asBracket">((</span>vx <span class="asOperator">*</span> vx<span class="asBracket">)</span><span class="asOperator">+</span><span class="asBracket">(</span>vy <span class="asOperator">*</span> vy<span class="asBracket">))</span>;
            
            <span class="asComment">/* apply the rigidity to make the edge tighter */</span>
            <span class="asVar">var</span> dx<span class="asOperator">:</span>Number <span class="asOperator">=</span> vx <span class="asOperator">*</span> _rigidity;
            <span class="asVar">var</span> dy<span class="asOperator">:</span>Number <span class="asOperator">=</span> vy <span class="asOperator">*</span> _rigidity;

            <span class="asComment">/* careful now we use the avgNodeSideLength() method
             * of the vedge, which is not really a length
             * but the average length of the sides of each node&apos;s
             * view */</span>
            <span class="asVar">var</span> avgNodeSideLength<span class="asOperator">:</span>Number <span class="asOperator">=</span> 0;
            <span class="asVar">var</span> divisor<span class="asOperator">:</span>Number <span class="asOperator">=</span> 0;

            <span class="asComment">//trace(&quot;pullEdges1 vx:&quot;+vx+&quot; vy:&quot;+vy+&quot; dx:&quot;+dx+&quot; dy:&quot;+dy+&quot; edgelength:&quot;+edgelength+&quot; strangelen:&quot;+strangeLen+&quot; divisor:&quot;+divisor);
</span>
            <span class="asComment">/* all nodes attached to the edge should be visible, 
             * so we assert here that it is true */</span>

            <span class="asReserved">if</span><span class="asBracket">(</span><span class="asOperator">!</span>vnode1.isVisible <span class="asOperator">||</span> <span class="asOperator">!</span>vnode2.isVisible<span class="asBracket">)</span> <span class="asBracket">{</span>
                <span class="asReserved">throw</span> Error<span class="asBracket">(</span><span class="asString">&quot;At least one node of the edge is not visible but it should be!&quot;</span><span class="asBracket">)</span>;
            <span class="asBracket">}</span>

            <span class="asComment">/* calculate the average node side length of the two
             * nodes */</span>
            avgNodeSideLength <span class="asOperator">=</span> <span class="asBracket">(</span>vnode1.view.width <span class="asOperator">+</span> vnode1.view.height <span class="asOperator">+</span> vnode2.view.width <span class="asOperator">+</span> vnode2.view.height<span class="asBracket">)</span> <span class="asOperator">/</span> 4.0;
            
            <span class="asComment">/* in some cases this may be 0 so we need to set
             * some default value */</span>
            <span class="asReserved">if</span><span class="asBracket">(</span>avgNodeSideLength <span class="asOperator">==</span> 0<span class="asBracket">)</span> <span class="asBracket">{</span>
                avgNodeSideLength <span class="asOperator">=</span> <span class="asBracket">(</span>MINIMUM_NODE_HEIGHT <span class="asOperator">+</span> MINIMUM_NODE_WIDTH<span class="asBracket">)</span> <span class="asOperator">/</span> 2.0;
            <span class="asBracket">}</span>
            
            divisor <span class="asOperator">=</span> 100 <span class="asOperator">*</span> avgNodeSideLength;
                 
            dx <span class="asOperator">=</span> dx <span class="asOperator">/</span> divisor;
            dy <span class="asOperator">=</span> dy <span class="asOperator">/</span> divisor;
                            
            <span class="asReserved">if</span><span class="asBracket">(</span>_deltaPositions<span class="asBracket">[</span>vnode1<span class="asBracket">]</span> <span class="asOperator">==</span> <span class="asReserved">null</span><span class="asBracket">)</span> <span class="asBracket">{</span>
                _deltaPositions<span class="asBracket">[</span>vnode1<span class="asBracket">]</span> <span class="asOperator">=</span> <span class="asReserved">new</span> Point<span class="asBracket">(</span>0,0<span class="asBracket">)</span>;
            <span class="asBracket">}</span>
            <span class="asReserved">if</span><span class="asBracket">(</span>_deltaPositions<span class="asBracket">[</span>vnode2<span class="asBracket">]</span> <span class="asOperator">==</span> <span class="asReserved">null</span><span class="asBracket">)</span> <span class="asBracket">{</span>
                _deltaPositions<span class="asBracket">[</span>vnode2<span class="asBracket">]</span> <span class="asOperator">=</span> <span class="asReserved">new</span> Point<span class="asBracket">(</span>0,0<span class="asBracket">)</span>;
            <span class="asBracket">}</span>
            
            <span class="asComment">/* apply the position offset, add for vnode 1 */</span>
            <span class="asBracket">(</span>_deltaPositions<span class="asBracket">[</span>vnode1<span class="asBracket">]</span> <span class="asReserved">as</span> Point<span class="asBracket">)</span>.offset<span class="asBracket">(</span>dx <span class="asOperator">*</span> edgelength, dy <span class="asOperator">*</span> edgelength<span class="asBracket">)</span>;
            
            <span class="asComment">/* subtract for vnode */</span>
            <span class="asBracket">(</span>_deltaPositions<span class="asBracket">[</span>vnode2<span class="asBracket">]</span> <span class="asReserved">as</span> Point<span class="asBracket">)</span>.offset<span class="asBracket">(</span><span class="asOperator">-</span>dx <span class="asOperator">*</span> edgelength, <span class="asOperator">-</span>dy <span class="asOperator">*</span> edgelength<span class="asBracket">)</span>;
            
            <span class="asComment">/*
            trace(&quot;pullEdges2 dx:&quot;+dx+&quot; dy:&quot;+dy+&quot; edgelength:&quot;+edgelength);
            trace(&quot;pullEdges3 node: &quot;+vnode1.id+&quot; has dx:&quot;+vnode1.dx+&quot; dy:&quot;+vnode1.dy+&quot; x:&quot;+vnode1.x+
                    &quot; y:&quot;+vnode1.y+&quot; viewX:&quot;+vnode1.viewX+&quot; viewY:&quot;+vnode1.viewY+&quot; repulsion:&quot;+_repulsionMap[vnode1]);
            trace(&quot;pullEdges3 node: &quot;+vnode2.id+&quot; has dx:&quot;+vnode2.dx+&quot; dy:&quot;+vnode2.dy+&quot; x:&quot;+vnode2.x+
                &quot; y:&quot;+vnode2.y+&quot; viewX:&quot;+vnode2.viewX+&quot; viewY:&quot;+vnode2.viewY+&quot; repulsion:&quot;+_repulsionMap[vnode2]);
            */</span>
        <span class="asBracket">}</span>

        <span class="asDoc">/**
         * @internal
         * This method checks for some motion limit parameters
         * and then moves each node (i.e. sets the target coordinates)
         * then it calls the damping function.
         * There is some potential to eliminate this, particularily
         * if the motionLimit things are not used....
         * */</span>
        <span class="asReserved">private</span> <span class="asFunction">function</span> moveNodes<span class="asBracket">()</span><span class="asOperator">:</span><span class="asReserved">void</span> <span class="asBracket">{</span>
            
            <span class="asVar">var</span> visVNodes<span class="asOperator">:</span>Dictionary <span class="asOperator">=</span> _vgraph.visibleVNodes;
            <span class="asVar">var</span> vn<span class="asOperator">:</span>IVisualNode;
            
            _lastMaxMotion <span class="asOperator">=</span> _maxMotion; <span class="asComment">// save last maxMotion
</span>            _maxMotionTmp <span class="asOperator">=</span> 0.0;
            
            <span class="asComment">/* again work on all visible nodes */</span>
            <span class="asReserved">for</span> <span class="asReserved">each</span><span class="asBracket">(</span>vn <span class="asReserved">in</span> visVNodes<span class="asBracket">)</span> <span class="asBracket">{</span>
                <span class="asReserved">if</span><span class="asBracket">(</span><span class="asOperator">!</span>vn.isVisible<span class="asBracket">)</span> <span class="asBracket">{</span>
                    <span class="asReserved">throw</span> Error<span class="asBracket">(</span><span class="asString">&quot;Received invisible node while working on visible vnodes only&quot;</span><span class="asBracket">)</span>;
                <span class="asBracket">}</span>
                <span class="asComment">/* work on the target coordinates of the node */</span>
                modifyNodeTarget<span class="asBracket">(</span>vn<span class="asBracket">)</span>;
            <span class="asBracket">}</span>

            <span class="asComment">/* maxMotionTmp will be updated during the function 
             * calls above, so we can use it here */</span>
            _maxMotion <span class="asOperator">=</span> _maxMotionTmp;

            <span class="asComment">/* calculate the motionRatio, the -1 is subtracted to
             * make positive values mean things are moving faster
             */</span>
            <span class="asReserved">if</span><span class="asBracket">(</span>_maxMotion <span class="asOperator">&gt;</span> 0<span class="asBracket">)</span> <span class="asBracket">{</span>
                _motionRatio <span class="asOperator">=</span> <span class="asBracket">(</span>_lastMaxMotion <span class="asOperator">/</span> _maxMotion<span class="asBracket">)</span> <span class="asOperator">-</span> 1;
            <span class="asBracket">}</span> <span class="asReserved">else</span> <span class="asBracket">{</span>
                _motionRatio <span class="asOperator">=</span> 0.0;
            <span class="asBracket">}</span>
        
            <span class="asComment">/* call the damper */</span>
            damp<span class="asBracket">()</span>;
        <span class="asBracket">}</span>

        <span class="asDoc">/** 
         * @internal
         * This does a damping pass, i.e. lower the damper
         * value to a certain degree depending on the circumstances.
         * */</span>
        <span class="asReserved">private</span> <span class="asFunction">function</span> damp<span class="asBracket">()</span><span class="asOperator">:</span><span class="asReserved">void</span> <span class="asBracket">{</span>
            
            <span class="asReserved">if</span><span class="asBracket">(</span>_dampingActive<span class="asBracket">)</span> <span class="asBracket">{</span>
                
                <span class="asComment">/* Only damp if the graph starts to move faster.
                 * If things are slowing down, let them stabilise on their
                 * own, without damping */</span>
                <span class="asReserved">if</span><span class="asBracket">(</span>_motionRatio <span class="asOperator">&lt;=</span> 0.001<span class="asBracket">)</span> <span class="asBracket">{</span>
                    
                    <span class="asComment">/* if maxMotion &lt; 0.2 damp! OR
                     * if the damper has ticked to 0.9 and maxMotion still &gt; 1, damp!
                     * damper must not be negative though */</span>
                    <span class="asReserved">if</span><span class="asBracket">((</span>_maxMotion <span class="asOperator">&lt;</span> 0.2 <span class="asOperator">||</span> <span class="asBracket">(</span>_maxMotion <span class="asOperator">&gt;</span> 1 <span class="asOperator">&amp;&amp;</span> _damper <span class="asOperator">&lt;</span> 0.9<span class="asBracket">))</span> <span class="asOperator">&amp;&amp;</span>
                        _damper <span class="asOperator">&gt;</span> 0.01<span class="asBracket">)</span> <span class="asBracket">{</span>
                        _damper <span class="asOperator">-=</span> 0.01;
                    <span class="asBracket">}</span>
                    <span class="asComment">/* damp a bit less agressively now */</span>
                    <span class="asReserved">else</span> <span class="asReserved">if</span><span class="asBracket">(</span>_maxMotion <span class="asOperator">&lt;</span> 0.4 <span class="asOperator">&amp;&amp;</span> _damper <span class="asOperator">&gt;</span> 0.003<span class="asBracket">)</span> <span class="asBracket">{</span>
                        _damper <span class="asOperator">-=</span> 0.003;
                    <span class="asBracket">}</span>
                    <span class="asComment">/* damp even less agressively */</span>
                    <span class="asReserved">else</span> <span class="asReserved">if</span><span class="asBracket">(</span>_damper <span class="asOperator">&gt;</span> 0.0001<span class="asBracket">)</span> <span class="asBracket">{</span>
                        _damper <span class="asOperator">-=</span> 0.0001;
                    <span class="asBracket">}</span>
                <span class="asBracket">}</span>
                
                <span class="asComment">/* damper 0 means no movement(!) */</span>
                <span class="asReserved">if</span><span class="asBracket">((</span>_maxMotion <span class="asOperator">&lt;</span> _motionLimit<span class="asBracket">)</span> <span class="asOperator">&amp;&amp;</span> _dampingActive<span class="asBracket">)</span> <span class="asBracket">{</span>
                    _damper <span class="asOperator">=</span> 0.0;
                <span class="asBracket">}</span>    
            <span class="asBracket">}</span>
        <span class="asBracket">}</span>
        
        <span class="asDoc">/**
         * @internal
         * This moves an indiviual node.
         * It takes the destination coordinates
         * in each node dx/dy, applies the damper, makes sure the
         * node does not travel too far and calculates the distance
         * it will move.
         * @param vn The node which should be moved.
         * */</span>
        <span class="asReserved">private</span> <span class="asFunction">function</span> modifyNodeTarget<span class="asBracket">(</span>vn<span class="asOperator">:</span>IVisualNode<span class="asBracket">)</span><span class="asOperator">:</span><span class="asReserved">void</span> <span class="asBracket">{</span>
            
            <span class="asVar">var</span> dx<span class="asOperator">:</span>Number;
            <span class="asVar">var</span> dy<span class="asOperator">:</span>Number;
            <span class="asVar">var</span> distanceMoved<span class="asOperator">:</span>Number;
            
            <span class="asComment">/* again, the node should be visible, so we break if it
             * is not
             * XXX these checks are currently quite redundant, but
             * at this maturity level of the code, it may not hurt.
             * If the code proves to be very stable, some of these may
             * be removed */</span>
            <span class="asReserved">if</span><span class="asBracket">(</span><span class="asOperator">!</span>vn.isVisible<span class="asBracket">)</span> <span class="asBracket">{</span>
                <span class="asReserved">throw</span> Error<span class="asBracket">(</span><span class="asString">&quot;Node is not visible but should be!&quot;</span><span class="asBracket">)</span>;
            <span class="asBracket">}</span>
            
            <span class="asComment">/* this should not really happen */</span>
            <span class="asReserved">if</span><span class="asBracket">(</span>_deltaPositions<span class="asBracket">[</span>vn<span class="asBracket">]</span> <span class="asOperator">==</span> <span class="asReserved">null</span><span class="asBracket">)</span> <span class="asBracket">{</span>
                _deltaPositions<span class="asBracket">[</span>vn<span class="asBracket">]</span> <span class="asOperator">=</span> <span class="asReserved">new</span> Point<span class="asBracket">(</span>0,0<span class="asBracket">)</span>;
            <span class="asBracket">}</span>
            
            dx <span class="asOperator">=</span> <span class="asBracket">(</span>_deltaPositions<span class="asBracket">[</span>vn<span class="asBracket">]</span> <span class="asReserved">as</span> Point<span class="asBracket">)</span>.x;
            dy <span class="asOperator">=</span> <span class="asBracket">(</span>_deltaPositions<span class="asBracket">[</span>vn<span class="asBracket">]</span> <span class="asReserved">as</span> Point<span class="asBracket">)</span>.y;
            
            <span class="asComment">//trace(&quot;modifyNodeTarget1 for &quot;+vn.id+&quot; dx:&quot;+dx+&quot; dy:&quot;+dy+&quot; damper:&quot;+_damper);
</span>                
            <span class="asComment">/* apply the damper now to slow things down and stabilise
             * the movement. The lower the damper the lower the movement
             * 0.0 means no movement 1.0 means no damping */</span>
            <span class="asReserved">if</span><span class="asBracket">(</span>_dampingActive <span class="asOperator">&amp;&amp;</span> _damper <span class="asOperator">&gt;</span> 0<span class="asBracket">)</span> <span class="asBracket">{</span>
                dx <span class="asOperator">=</span> dx <span class="asOperator">*</span> _damper;
                dy <span class="asOperator">=</span> dy <span class="asOperator">*</span> _damper;
            <span class="asBracket">}</span>
                
            <span class="asComment">/* reapply the value to the node attribite and half the movement
             * again.
             * This slows things down more, but don&apos;t stop but keep some momentum
             * in moving nodes, to avoid a problem if some nodes are
             * already very slow */</span>
            _deltaPositions<span class="asBracket">[</span>vn<span class="asBracket">]</span> <span class="asOperator">=</span> <span class="asReserved">new</span> Point<span class="asBracket">(</span>dx <span class="asOperator">/</span> 2.0, dy <span class="asOperator">/</span> 2.0<span class="asBracket">)</span>; 
            
            <span class="asComment">//trace(&quot;modifyNodeTarget2 for &quot;+vn.id+&quot; dx:&quot;+dx+&quot; dy:&quot;+dy+&quot; damper:&quot;+_damper);
</span>                
            <span class="asComment">/* how far did the node move? */</span>
            distanceMoved <span class="asOperator">=</span> Math.sqrt<span class="asBracket">(</span>dx<span class="asOperator">*</span>dx <span class="asOperator">*</span> dy<span class="asOperator">*</span>dy<span class="asBracket">)</span>;
                
            <span class="asComment">//trace(&quot;modifyNodeTarget3 for &quot;+vn.id+&quot; distanceMoved:&quot;+distanceMoved);
</span>                
            <span class="asComment">/*
            trace(&quot;modifyNodeTarget4 for &quot;+vn.id+&quot; moveable:&quot;+vn.moveable.toString());
            if(_dragNode != null) {
                trace(&quot; dragnode:&quot;+_dragNode.id);
            }
            */</span>
            
            <span class="asComment">/* move the node, but only if it is not currently dragged! */</span>
            <span class="asReserved">if</span><span class="asBracket">(</span>vn.moveable <span class="asOperator">&amp;&amp;</span> vn <span class="asOperator">!=</span> _dragNode<span class="asBracket">)</span> <span class="asBracket">{</span>
                <span class="asComment">//trace(&quot;modifyNodeTarget5 for &quot;+vn.id+&quot; vnx:&quot;+vn.x+&quot; vny:&quot;+vn.y);
</span>                vn.x <span class="asOperator">=</span> vn.x <span class="asOperator">+</span> Math.max<span class="asBracket">(</span><span class="asOperator">-</span>_MOVEPIXELLIMIT, Math.min<span class="asBracket">(</span>_MOVEPIXELLIMIT, dx<span class="asBracket">))</span>;
                vn.y <span class="asOperator">=</span> vn.y <span class="asOperator">+</span> Math.max<span class="asBracket">(</span><span class="asOperator">-</span>_MOVEPIXELLIMIT, Math.min<span class="asBracket">(</span>_MOVEPIXELLIMIT, dy<span class="asBracket">))</span>;
                <span class="asComment">//trace(&quot;modifyNodeTarget6 for &quot;+vn.id+&quot; vnx:&quot;+vn.x+&quot; vny:&quot;+vn.y);
</span>            <span class="asBracket">}</span>
            <span class="asComment">/* update the motion value */</span>
            _maxMotionTmp <span class="asOperator">=</span> Math.max<span class="asBracket">(</span>distanceMoved,_maxMotionTmp<span class="asBracket">)</span>;
        <span class="asBracket">}</span>

        <span class="asDoc">/**
         * @internal
         * This methods (originally called avoidLabels()) applies
         * the repulsion to the nodes in order to keep them apart
         * (and consequently avoid their labels from overlapping).
         * */</span>
        <span class="asReserved">private</span> <span class="asFunction">function</span> applyRepulsion<span class="asBracket">()</span><span class="asOperator">:</span><span class="asReserved">void</span> <span class="asBracket">{</span>

            <span class="asVar">var</span> allVisVNodes<span class="asOperator">:</span>Dictionary <span class="asOperator">=</span> _vgraph.visibleVNodes;
            <span class="asVar">var</span> vn_i<span class="asOperator">:</span>IVisualNode;
            <span class="asVar">var</span> vn_j<span class="asOperator">:</span>IVisualNode;
            
            <span class="asReserved">for</span> <span class="asReserved">each</span><span class="asBracket">(</span>vn_i <span class="asReserved">in</span> allVisVNodes<span class="asBracket">)</span> <span class="asBracket">{</span>                
                <span class="asReserved">if</span><span class="asBracket">(</span><span class="asOperator">!</span>vn_i.isVisible<span class="asBracket">)</span> <span class="asBracket">{</span>
                    <span class="asReserved">throw</span> Error<span class="asBracket">(</span><span class="asString">&quot;Received invisible node while working on visible vnodes only&quot;</span><span class="asBracket">)</span>;
                <span class="asBracket">}</span>
                <span class="asReserved">for</span> <span class="asReserved">each</span><span class="asBracket">(</span>vn_j <span class="asReserved">in</span> allVisVNodes<span class="asBracket">)</span> <span class="asBracket">{</span>
                    <span class="asReserved">if</span><span class="asBracket">(</span><span class="asOperator">!</span>vn_j.isVisible<span class="asBracket">)</span> <span class="asBracket">{</span>
                        <span class="asReserved">throw</span> Error<span class="asBracket">(</span><span class="asString">&quot;Received invisible node while working on visible vnodes only&quot;</span><span class="asBracket">)</span>;
                    <span class="asBracket">}</span>
                    <span class="asReserved">if</span><span class="asBracket">(</span>vn_i <span class="asOperator">!=</span> vn_j<span class="asBracket">)</span> <span class="asBracket">{</span>
                        <span class="asComment">/* call the actual code to apply the repulsion 
                         * between two nodes */</span>
                        applyNodeRepulsion<span class="asBracket">(</span>vn_i, vn_j<span class="asBracket">)</span>;
                    <span class="asBracket">}</span>
                <span class="asBracket">}</span>
            <span class="asBracket">}</span>
        <span class="asBracket">}</span>
        
        <span class="asDoc">/**
         * @internal
         * This method actually applies the repulsion between any
         * two visible nodes and adjustes their target coordinates
         * accordingly. If two nodes would be on the same spot
         * it also modifies their current coordinates to move them
         * apart.
         * @param vn1 The first node of the node pair to apply the repulsion.
         * @param vn2 The second node of the node pair to apply the repulsion.
         * */</span>
        <span class="asReserved">private</span> <span class="asFunction">function</span> applyNodeRepulsion<span class="asBracket">(</span>vn1<span class="asOperator">:</span>IVisualNode, vn2<span class="asOperator">:</span>IVisualNode<span class="asBracket">)</span><span class="asOperator">:</span><span class="asReserved">void</span> <span class="asBracket">{</span>
            
            <span class="asVar">var</span> dx<span class="asOperator">:</span>Number <span class="asOperator">=</span> 0;
            <span class="asVar">var</span> dy<span class="asOperator">:</span>Number <span class="asOperator">=</span> 0;
            
            <span class="asVar">var</span> vx<span class="asOperator">:</span>Number <span class="asOperator">=</span> vn1.x <span class="asOperator">-</span> vn2.x;
            <span class="asVar">var</span> vy<span class="asOperator">:</span>Number <span class="asOperator">=</span> vn1.y <span class="asOperator">-</span> vn2.y;
            <span class="asVar">var</span> lenSquare<span class="asOperator">:</span>Number <span class="asOperator">=</span> <span class="asBracket">(</span>vx <span class="asOperator">*</span> vx<span class="asBracket">)</span> <span class="asOperator">+</span> <span class="asBracket">(</span>vy <span class="asOperator">*</span> vy<span class="asBracket">)</span>;
            
            <span class="asComment">/* get the repulsion number for each node */</span>
            <span class="asVar">var</span> repsum<span class="asOperator">:</span>Number;
            <span class="asVar">var</span> repfac<span class="asOperator">:</span>Number;

            <span class="asComment">//trace(&quot;applyRepulsion1 vx:&quot;+vx+&quot; vy:&quot;+vy+&quot; lenSquare:&quot;+lenSquare);
</span>                
            <span class="asComment">/* if for some reason we did not have it initialised 
             * assert the repulsion map has an entry for each node */</span>
            <span class="asReserved">if</span><span class="asBracket">(</span>_repulsionMap<span class="asBracket">[</span>vn1<span class="asBracket">]</span> <span class="asOperator">==</span> <span class="asReserved">null</span> <span class="asOperator">||</span> _repulsionMap<span class="asBracket">[</span>vn2<span class="asBracket">]</span> <span class="asOperator">==</span> <span class="asReserved">null</span><span class="asBracket">)</span> <span class="asBracket">{</span>
                <span class="asReserved">throw</span> Error<span class="asBracket">(</span><span class="asString">&quot;repulsionMap for a node not initialised&quot;</span><span class="asBracket">)</span>;
            <span class="asBracket">}</span>
                        
            repsum <span class="asOperator">=</span> _repulsionMap<span class="asBracket">[</span>vn1<span class="asBracket">]</span> <span class="asOperator">*</span> _repulsionMap<span class="asBracket">[</span>vn2<span class="asBracket">]</span> <span class="asOperator">/</span> 100;
            repfac <span class="asOperator">=</span> repsum <span class="asOperator">*</span> _rigidity;
                
            <span class="asComment">//trace(&quot;applyRepulsion2 repv1:&quot;+_repulsionMap[vn1]+&quot; repv2:&quot;+_repulsionMap[vn2]+&quot; repsum:&quot;+repsum+&quot; repfac:&quot;+repfac);
</span>                
                
            <span class="asComment">/* if two nodes are exactly on top of each other 
             * just randomly separate them. */</span>
            <span class="asReserved">if</span><span class="asBracket">(</span>lenSquare <span class="asOperator">==</span> 0<span class="asBracket">)</span> <span class="asBracket">{</span>
                <span class="asComment">//trace(&quot;nodes seem to be on top of each other&quot;);
</span>                dx <span class="asOperator">=</span> Math.random<span class="asBracket">()</span> <span class="asOperator">*</span> 10;
                dy <span class="asOperator">=</span> Math.random<span class="asBracket">()</span> <span class="asOperator">*</span> 10;
                <span class="asComment">//trace(&quot;setting dx:&quot;+dx+&quot; dy:&quot;+dy);
</span>            <span class="asBracket">}</span>
                
            <span class="asComment">/* if the nodes are too far, i.e. more than 600x600
             * we apply a special factor to prevent them from flying away */</span>
            <span class="asReserved">else</span> <span class="asReserved">if</span><span class="asBracket">(</span>lenSquare <span class="asOperator">&lt;</span> 360000<span class="asBracket">)</span> <span class="asBracket">{</span>
                dx <span class="asOperator">=</span> vx <span class="asOperator">/</span> lenSquare;
                dy <span class="asOperator">=</span> vy <span class="asOperator">/</span> lenSquare;
            <span class="asBracket">}</span>
                
            <span class="asComment">//trace(&quot;applyRepulsion3: dx:&quot;+dx+&quot; dy:&quot;+dy+&quot; v1.dx:&quot;+vn1.dx+&quot; v1.dy:&quot;+vn1.dy+&quot; v2.dx:&quot;+vn2.dx+&quot; v2.dy:&quot;+vn2.dy);
</span>            
            <span class="asComment">/* init if not existing */</span>
            <span class="asReserved">if</span><span class="asBracket">(</span>_deltaPositions<span class="asBracket">[</span>vn1<span class="asBracket">]</span> <span class="asOperator">==</span> <span class="asReserved">null</span><span class="asBracket">)</span> <span class="asBracket">{</span>
                _deltaPositions<span class="asBracket">[</span>vn1<span class="asBracket">]</span> <span class="asOperator">=</span> <span class="asReserved">new</span> Point<span class="asBracket">(</span>0,0<span class="asBracket">)</span>;
            <span class="asBracket">}</span>
            <span class="asReserved">if</span><span class="asBracket">(</span>_deltaPositions<span class="asBracket">[</span>vn2<span class="asBracket">]</span> <span class="asOperator">==</span> <span class="asReserved">null</span><span class="asBracket">)</span> <span class="asBracket">{</span>
                _deltaPositions<span class="asBracket">[</span>vn2<span class="asBracket">]</span> <span class="asOperator">=</span> <span class="asReserved">new</span> Point<span class="asBracket">(</span>0,0<span class="asBracket">)</span>;
            <span class="asBracket">}</span>
            
            <span class="asComment">/* add to vn1 */</span>
            <span class="asBracket">(</span>_deltaPositions<span class="asBracket">[</span>vn1<span class="asBracket">]</span> <span class="asReserved">as</span> Point<span class="asBracket">)</span>.offset<span class="asBracket">(</span>dx <span class="asOperator">*</span> repfac, dy <span class="asOperator">*</span> repfac<span class="asBracket">)</span>;
            
            <span class="asComment">/* subtract from vn2 */</span>
            <span class="asBracket">(</span>_deltaPositions<span class="asBracket">[</span>vn2<span class="asBracket">]</span> <span class="asReserved">as</span> Point<span class="asBracket">)</span>.offset<span class="asBracket">(</span><span class="asOperator">-</span>dx <span class="asOperator">*</span> repfac, <span class="asOperator">-</span>dy <span class="asOperator">*</span> repfac<span class="asBracket">)</span>;
                
            <span class="asComment">//trace(&quot;applyRepulsion4: dx:&quot;+dx+&quot; dy:&quot;+dy+&quot; v1.dx:&quot;+vn1.dx+&quot; v1.dy:&quot;+vn1.dy+&quot; v2.dx:&quot;+vn2.dx+&quot; v2.dy:&quot;+vn2.dy);
</span>        <span class="asBracket">}</span>
        
        <span class="asDoc">/**
         * @internal
         * Updates the new repulsion value for the given node.
         * @param vn The node to update its repulsion.
         * */</span>
        <span class="asReserved">private</span> <span class="asFunction">function</span> updateRepulsion<span class="asBracket">(</span>vn<span class="asOperator">:</span>IVisualNode<span class="asBracket">)</span><span class="asOperator">:</span><span class="asReserved">void</span> <span class="asBracket">{</span>
            
            <span class="asVar">var</span> newrep<span class="asOperator">:</span>Number;
            
            <span class="asReserved">if</span><span class="asBracket">(</span><span class="asOperator">!</span>vn.isVisible<span class="asBracket">)</span> <span class="asBracket">{</span>
                <span class="asReserved">throw</span> Error<span class="asBracket">(</span><span class="asString">&quot;Received invisible node while working on visible vnodes only&quot;</span><span class="asBracket">)</span>;
            <span class="asBracket">}</span>
            
            <span class="asComment">/* maybe another factor was once multiplied with this.... */</span>
            newrep <span class="asOperator">=</span> <span class="asBracket">(</span>vn.view.width <span class="asOperator">+</span> vn.view.height<span class="asBracket">)</span> <span class="asOperator">*</span> _repulsionFactor;
            
            <span class="asReserved">if</span><span class="asBracket">(</span>newrep <span class="asOperator">==</span> 0<span class="asBracket">)</span> <span class="asBracket">{</span>
                newrep <span class="asOperator">=</span> _repulsionFactor;
            <span class="asBracket">}</span>
            
            <span class="asComment">/* update the value in the map */</span>
            _repulsionMap<span class="asBracket">[</span>vn<span class="asBracket">]</span> <span class="asOperator">=</span> newrep;    
        
            <span class="asComment">//trace(&quot;updated repulsion for node:&quot;+vn.id+&quot; to:&quot;+newrep);
</span>        <span class="asBracket">}</span>
    <span class="asBracket">}</span>
<span class="asBracket">}</span></pre></body>
</html>
