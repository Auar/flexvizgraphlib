<!-- saved from url=(0014)about:internet -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<title>ConcentricRadialLayouter.as</title>
<link rel="stylesheet" type="text/css" href="../../../../../../SourceStyles.css"/>
</head>

<body><pre><span class="asComment">/* 
 * The MIT License
 *
 * Copyright (c) 2007 The SixDegrees Project Team
 * (Jason Bellone, Juan Rodriguez, Segolene de Basquiat, Daniel Lang).
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the &quot;Software&quot;), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */</span>
<span class="asPackage">package</span> org.un.flex.graphLayout.layout <span class="asBracket">{</span>

    <span class="asReserved">import</span> org.un.flex.graphLayout.visual.IVisualGraph;
    <span class="asReserved">import</span> flash.events.Event;
    <span class="asReserved">import</span> org.un.flex.graphLayout.data.IGraph;
    <span class="asReserved">import</span> org.un.flex.graphLayout.data.Graph;
    <span class="asReserved">import</span> org.un.flex.graphLayout.visual.IVisualNode;
    <span class="asReserved">import</span> org.un.flex.graphLayout.data.IEdge;
    <span class="asReserved">import</span> org.un.flex.graphLayout.data.INode;
    <span class="asReserved">import</span> org.un.flex.graphLayout.visual.IVisualEdge;
    <span class="asReserved">import</span> org.un.flex.utils.Geometry;
    <span class="asReserved">import</span> flash.utils.Dictionary;
    <span class="asReserved">import</span> flash.events.MouseEvent;
    <span class="asReserved">import</span> org.un.flex.graphLayout.data.IGTree;
    <span class="asReserved">import</span> flash.geom.Point;
    <span class="asReserved">import</span> flash.utils.Timer;
    <span class="asReserved">import</span> flash.events.TimerEvent;
    
    <span class="asDoc">/**
     * This is an implementation of the generic radial
     * layout algorithm that uses concentric rings
     * for the distance. In addition it will implement
     * the animation algorithm by Yee et. al that moves
     * nodes along their circles instead of in straight
     * lines.
     * */</span>
    <span class="asReserved">public</span> <span class="asClass">class</span> ConcentricRadialLayouter <span class="asReserved">extends</span> AnimatedBaseLayouter <span class="asReserved">implements</span> ILayoutAlgorithm <span class="asBracket">{</span>
        
        <span class="asDoc">/**
         * The default radius increase between
         * the concentric circles.
         * */</span>
        <span class="asReserved">public</span> <span class="asReserved">static</span> <span class="asReserved">const</span> DEFAULT_RADIUS<span class="asOperator">:</span>Number <span class="asOperator">=</span> 50;
        
        <span class="asDoc">/**
         * @internal
         * we need a previous root for the animation */</span>
        <span class="asReserved">private</span> <span class="asVar">var</span> _previousRoot<span class="asOperator">:</span>INode;        
        
        <span class="asDoc">/**
         * @internal
         * the current maximum depth of the tree */</span>
        <span class="asReserved">private</span> <span class="asVar">var</span> _maxDepth<span class="asOperator">:</span>int <span class="asOperator">=</span> 0;
        
        <span class="asDoc">/**
         * @internal
         * the current radius increase for each circle */</span>
        <span class="asReserved">private</span> <span class="asVar">var</span> _radiusInc<span class="asOperator">:</span>Number <span class="asOperator">=</span> 0;
        
        <span class="asComment">/* the two bounding angles */</span>
        <span class="asReserved">private</span> <span class="asVar">var</span> _theta1<span class="asOperator">:</span>Number;
        <span class="asReserved">private</span> <span class="asVar">var</span> _theta2<span class="asOperator">:</span>Number;
        <span class="asReserved">private</span> <span class="asVar">var</span> _setBounds<span class="asOperator">:</span>Boolean;        
        
        <span class="asComment">/* if we add views the initial size is 0,
         * so we just keep track of the other nodes and
         * use the largest size of a node to measure
         */</span>
        <span class="asReserved">private</span> <span class="asVar">var</span> _maxviewwidth<span class="asOperator">:</span>Number <span class="asOperator">=</span> 0;
        <span class="asReserved">private</span> <span class="asVar">var</span> _maxviewheight<span class="asOperator">:</span>Number <span class="asOperator">=</span> 0;

        <span class="asDoc">/**
         * this holds the data for a layout drawing.
         * */</span>
        <span class="asReserved">private</span> <span class="asVar">var</span> _currentDrawing<span class="asOperator">:</span>ConcentricRadialLayoutDrawing;

        <span class="asDoc">/**
         * The constructor initializes the layouter and may assign
         * already a VisualGraph object, but this can also be set later.
         * @param vg The VisualGraph object on which this layouter should work on.
         * */</span>
        <span class="asReserved">public</span> <span class="asFunction">function</span> ConcentricRadialLayouter<span class="asBracket">(</span>vg<span class="asOperator">:</span>IVisualGraph <span class="asOperator">=</span> <span class="asReserved">null</span><span class="asBracket">)</span><span class="asOperator">:</span><span class="asReserved">void</span> <span class="asBracket">{</span>
        
            <span class="asReserved">super</span><span class="asBracket">(</span>vg<span class="asBracket">)</span>;
            
            <span class="asComment">/* this is inherited */</span>
            animationType <span class="asOperator">=</span> ANIM_RADIAL;
            
            _currentDrawing <span class="asOperator">=</span> <span class="asReserved">null</span>;
            
            _radiusInc <span class="asOperator">=</span> DEFAULT_RADIUS;
            _previousRoot <span class="asOperator">=</span> <span class="asReserved">null</span>;
            _theta1 <span class="asOperator">=</span> 0;
            _theta2 <span class="asOperator">=</span> _theta1 <span class="asOperator">+</span> 360;
            _setBounds <span class="asOperator">=</span> <span class="asReserved">false</span>;
            
            _maxviewwidth <span class="asOperator">=</span> MINIMUM_NODE_WIDTH;
            _maxviewheight <span class="asOperator">=</span> MINIMUM_NODE_HEIGHT;
            
            initDrawing<span class="asBracket">()</span>;
        <span class="asBracket">}</span>

        <span class="asDoc">/**
         * @inheritDoc
         * */</span>
        <span class="asReserved">public</span> <span class="asReserved">override</span> <span class="asFunction">function</span> resetAll<span class="asBracket">()</span><span class="asOperator">:</span><span class="asReserved">void</span> <span class="asBracket">{</span>        
            _layoutChanged <span class="asOperator">=</span> <span class="asReserved">true</span>;
            _stree <span class="asOperator">=</span> <span class="asReserved">null</span>;
            _graph.purgeTrees<span class="asBracket">()</span>;
        <span class="asBracket">}</span>
        
        <span class="asDoc">/**
         * @inheritDoc
         * */</span>
        <span class="asBracket">[</span><span class="asMetadata">Bindable</span><span class="asBracket">]</span>
        <span class="asReserved">override</span> <span class="asReserved">public</span> <span class="asFunction">function</span> <span class="asReserved">set</span> linkLength<span class="asBracket">(</span>r<span class="asOperator">:</span>Number<span class="asBracket">)</span><span class="asOperator">:</span><span class="asReserved">void</span> <span class="asBracket">{</span>
            _radiusInc <span class="asOperator">=</span> r;
        <span class="asBracket">}</span>
        
        <span class="asDoc">/**
         * @private
         * */</span>
        <span class="asReserved">override</span> <span class="asReserved">public</span> <span class="asFunction">function</span> <span class="asReserved">get</span> linkLength<span class="asBracket">()</span><span class="asOperator">:</span>Number <span class="asBracket">{</span>
            <span class="asReserved">return</span> _radiusInc;
        <span class="asBracket">}</span>

        <span class="asDoc">/**
         * @inheritDoc
         * @internal
         * This method does the real layout pass, 
         * i.e. a full calculation of the new layout and
         * animating the nodes moving into the new position.
         * */</span>
        <span class="asReserved">override</span> <span class="asReserved">public</span> <span class="asFunction">function</span> layoutPass<span class="asBracket">()</span><span class="asOperator">:</span>Boolean <span class="asBracket">{</span>
             <span class="asVar">var</span> rv<span class="asOperator">:</span>Boolean;
            <span class="asVar">var</span> i<span class="asOperator">:</span>int;
            <span class="asVar">var</span> n<span class="asOperator">:</span>INode;
            <span class="asVar">var</span> nodes<span class="asOperator">:</span>Array;
            <span class="asVar">var</span> cindex<span class="asOperator">:</span>int;
    
            <span class="asComment">//trace(&quot;layoutPass called&quot;);
</span>            
            <span class="asReserved">if</span><span class="asBracket">(</span><span class="asOperator">!</span>_vgraph<span class="asBracket">)</span> <span class="asBracket">{</span>
                <span class="asReserved">throw</span> Error<span class="asBracket">(</span><span class="asString">&quot;No Vgraph set in ConcentricRadialLayouter, aborting&quot;</span><span class="asBracket">)</span>;
            <span class="asBracket">}</span>
            
            <span class="asReserved">if</span><span class="asBracket">(</span><span class="asOperator">!</span>_vgraph.currentRootVNode<span class="asBracket">)</span> <span class="asBracket">{</span>
                <span class="asReserved">throw</span> Error<span class="asBracket">(</span><span class="asString">&quot;This Layouter always requires a root node!&quot;</span><span class="asBracket">)</span>;
            <span class="asBracket">}</span>
            
            <span class="asComment">/* nothing to do if we have no nodes */</span>
            <span class="asReserved">if</span><span class="asBracket">(</span>_graph.noNodes <span class="asOperator">&lt;</span> 1<span class="asBracket">)</span> <span class="asBracket">{</span>
                <span class="asReserved">return</span> <span class="asReserved">false</span>;
            <span class="asBracket">}</span>
            
            killTimer<span class="asBracket">()</span>;
                
            <span class="asComment">/* establish the current root, if it has 
             * changed we need to reinit the drawing */</span>
            <span class="asReserved">if</span><span class="asBracket">(</span>_root <span class="asOperator">!=</span> _vgraph.currentRootVNode.node<span class="asBracket">)</span> <span class="asBracket">{</span>
                <span class="asComment">/* don&apos;t forget to save the root here */</span>
                _previousRoot <span class="asOperator">=</span> _root;
                _root <span class="asOperator">=</span> _vgraph.currentRootVNode.node;
                _layoutChanged <span class="asOperator">=</span> <span class="asReserved">true</span>;
            <span class="asBracket">}</span>
            
            <span class="asComment">/* we test to always reinit the drawing */</span>
            <span class="asReserved">if</span><span class="asBracket">(</span>_layoutChanged<span class="asBracket">)</span> <span class="asBracket">{</span>
                initDrawing<span class="asBracket">()</span>;
            <span class="asBracket">}</span>
            
            <span class="asComment">//trace(&quot;CCLayouter: current root:&quot;+_root.id);
</span>    
            <span class="asComment">/* set the coordinates in the drawing of root
             * to 0,0 */</span>
            _currentDrawing.setCartCoordinates<span class="asBracket">(</span>_root,<span class="asReserved">new</span> Point<span class="asBracket">(</span>0,0<span class="asBracket">))</span>;
            
            <span class="asComment">/* establish the spanning tree, but have it restricted to
             * visible nodes */</span>
            _stree <span class="asOperator">=</span> _graph.getTree<span class="asBracket">(</span>_root, <span class="asReserved">true</span><span class="asBracket">)</span>;
            
            <span class="asComment">/* calculate the relative width and the
             * new max Depth */</span>
            _maxDepth <span class="asOperator">=</span> 0;
            calcAngularWidth<span class="asBracket">(</span>_root,0<span class="asBracket">)</span>;
            
            <span class="asComment">/* calculate the radius increment to fit the screen */</span>
            <span class="asReserved">if</span><span class="asBracket">(</span>_autoFitEnabled<span class="asBracket">)</span> <span class="asBracket">{</span>
                autoFit<span class="asBracket">()</span>;
            <span class="asBracket">}</span>
            
            <span class="asComment">/* we may have preset angular bounds
             * XXX this is untested, yet */</span>
            <span class="asReserved">if</span><span class="asBracket">(</span>_setBounds<span class="asBracket">)</span> <span class="asBracket">{</span>
                calcAngularBounds<span class="asBracket">(</span>_root<span class="asBracket">)</span>;
            <span class="asBracket">}</span>
            
            <span class="asComment">/* do a static layout pass */</span>
            <span class="asReserved">if</span><span class="asBracket">(</span>_maxDepth <span class="asOperator">&gt;</span> 0<span class="asBracket">)</span> <span class="asBracket">{</span>
                calculateStaticLayout<span class="asBracket">(</span>_root,_radiusInc,_theta1,_theta2<span class="asBracket">)</span>;
            <span class="asBracket">}</span>
            
            <span class="asComment">/* now if we have no previous drawing we can just
             * apply the result and display it
             * if we do have (but maybe even if we don&apos;t have)
             * we interpolate the polar coordinates of the nodes */</span>
            
            
            resetAnimation<span class="asBracket">()</span>;
            
            <span class="asComment">/* start the animation by interpolating polar coordinates */</span>
            startAnimation<span class="asBracket">()</span>;
            
            _layoutChanged <span class="asOperator">=</span> <span class="asReserved">true</span>;
            <span class="asReserved">return</span> rv;
        <span class="asBracket">}</span>
        
        <span class="asDoc">/**
         * Presets the angular bounds of the layout, if desired.
         * This allows to restrict the layout from drawing a full circle
         * to only draw in a segment of the circle.
         * WARNING: XXX THIS HAS NOT BEEN TESTED YET
         * @param theta The starting angle in radians of the bounding segment. Default is 0.
         * @param width The angular width of the segment in radians. Default is 2*PI.
         * */</span>
        <span class="asReserved">public</span> <span class="asFunction">function</span> setAngularBounds<span class="asBracket">(</span>theta<span class="asOperator">:</span>Number, width<span class="asOperator">:</span>Number<span class="asBracket">)</span><span class="asOperator">:</span><span class="asReserved">void</span> <span class="asBracket">{</span>
            _theta1 <span class="asOperator">=</span> theta;
            _theta2 <span class="asOperator">=</span> _theta1 <span class="asOperator">+</span> width;
            _setBounds <span class="asOperator">=</span> <span class="asReserved">true</span>;
        <span class="asBracket">}</span>

        <span class="asComment">/*
         * private functions
         * */</span>
         
        <span class="asDoc">/**
         * @internal
         * create a new layout model object, which is required
         * on any root change (and possibly during other occasions)
         * */</span>
        <span class="asReserved">private</span> <span class="asFunction">function</span> initDrawing<span class="asBracket">()</span><span class="asOperator">:</span><span class="asReserved">void</span> <span class="asBracket">{</span>            
            _currentDrawing <span class="asOperator">=</span> <span class="asReserved">new</span> ConcentricRadialLayoutDrawing<span class="asBracket">()</span>;
            
            <span class="asComment">/* don&apos;t forget to set the object also in the 
             * BaseLayouter */</span>
            <span class="asReserved">super</span>.currentDrawing <span class="asOperator">=</span> _currentDrawing;
            
            _currentDrawing.originOffset <span class="asOperator">=</span> _vgraph.origin;
            _currentDrawing.centerOffset <span class="asOperator">=</span> _vgraph.center;
            _currentDrawing.centeredLayout <span class="asOperator">=</span> <span class="asReserved">true</span>;
            <span class="asComment">//trace(&quot;New Drawing with origin:&quot;+_currentDrawing.originOffset.toString());
</span>        <span class="asBracket">}</span>
        
        <span class="asDoc">/**
         * @internal
         * this autofit method sets the radius increment
         * so that it should fit into the screen
         * */</span>
        <span class="asReserved">private</span> <span class="asFunction">function</span> autoFit<span class="asBracket">()</span><span class="asOperator">:</span><span class="asReserved">void</span> <span class="asBracket">{</span>
            <span class="asVar">var</span> r<span class="asOperator">:</span>Number;
            r <span class="asOperator">=</span> Math.min<span class="asBracket">(</span>_vgraph.width, _vgraph.height<span class="asBracket">)</span> <span class="asOperator">/</span> 2.0;
            
            <span class="asReserved">if</span><span class="asBracket">(</span>_maxDepth <span class="asOperator">&gt;</span> 0<span class="asBracket">)</span> <span class="asBracket">{</span>
                _radiusInc <span class="asOperator">=</span> <span class="asBracket">(</span>r <span class="asOperator">-</span> <span class="asBracket">(</span>2 <span class="asOperator">*</span>DEFAULT_MARGIN<span class="asBracket">))</span> <span class="asOperator">/</span> _maxDepth;
            <span class="asBracket">}</span>
        <span class="asBracket">}</span>
        
        <span class="asDoc">/**
         * @internal
         * This calculates the angular width of a subtree.
         * @param n the root node of the subtree.
         * @param d the current depth.
         * @return The angular width of the subtree rooted in n at level d.
         * */</span>
        <span class="asReserved">private</span> <span class="asFunction">function</span> calcAngularWidth<span class="asBracket">(</span>n<span class="asOperator">:</span>INode, d<span class="asOperator">:</span>int<span class="asBracket">)</span><span class="asOperator">:</span>Number <span class="asBracket">{</span>
            <span class="asVar">var</span> aw<span class="asOperator">:</span>Number <span class="asOperator">=</span> 0;
            <span class="asVar">var</span> nw<span class="asOperator">:</span>Number;
            <span class="asVar">var</span> nh<span class="asOperator">:</span>Number;
            <span class="asVar">var</span> diameter<span class="asOperator">:</span>Number;
            <span class="asVar">var</span> cn<span class="asOperator">:</span>INode; <span class="asComment">// child node
</span>            
            <span class="asReserved">if</span><span class="asBracket">(</span>n <span class="asOperator">==</span> <span class="asReserved">null</span><span class="asBracket">)</span> <span class="asBracket">{</span>
                <span class="asReserved">throw</span> Error<span class="asBracket">(</span><span class="asString">&quot;Node to calculate Angular width is null&quot;</span><span class="asBracket">)</span>;
            <span class="asBracket">}</span>
            <span class="asReserved">if</span><span class="asBracket">(</span>n.vnode <span class="asOperator">==</span> <span class="asReserved">null</span><span class="asBracket">)</span> <span class="asBracket">{</span>
                <span class="asReserved">throw</span> Error<span class="asBracket">(</span><span class="asString">&quot;Node has no vnode&quot;</span><span class="asBracket">)</span>;
            <span class="asBracket">}</span>
            
            
            <span class="asComment">//trace(&quot;CalcAngWidth called with node:&quot;+n.id+&quot; and depth:&quot;+d);
</span>            
            <span class="asReserved">if</span><span class="asBracket">(</span><span class="asOperator">!</span>n.vnode.isVisible<span class="asBracket">)</span> <span class="asBracket">{</span>
                <span class="asTrace">trace</span><span class="asBracket">(</span><span class="asString">&quot;Node:&quot;</span><span class="asOperator">+</span>n.id<span class="asOperator">+</span><span class="asString">&quot; not yet visible but called in angular width calc&quot;</span><span class="asBracket">)</span>;
                <span class="asReserved">return</span> 0;
            <span class="asBracket">}</span>
            
            <span class="asComment">/* update current max Depth */</span>
            <span class="asReserved">if</span><span class="asBracket">(</span>d <span class="asOperator">&gt;</span> _maxDepth<span class="asBracket">)</span> <span class="asBracket">{</span>
                _maxDepth <span class="asOperator">=</span> d;
            <span class="asBracket">}</span>
            
            <span class="asComment">/* the following two may be 0 in an early stage
             * so we have to get around that issue 
             * if it is 0 we assign a default size */</span>
            nw <span class="asOperator">=</span> n.vnode.view.width;
            nh <span class="asOperator">=</span> n.vnode.view.height;
            
            <span class="asComment">/* update the max view width and height */</span>
            _maxviewwidth <span class="asOperator">=</span> Math.max<span class="asBracket">(</span>_maxviewwidth, nw<span class="asBracket">)</span>;
            _maxviewheight <span class="asOperator">=</span> Math.max<span class="asBracket">(</span>_maxviewheight, nh<span class="asBracket">)</span>;
            
            <span class="asReserved">if</span><span class="asBracket">(</span>nw <span class="asOperator">==</span> 0<span class="asBracket">)</span> <span class="asBracket">{</span>
                nw <span class="asOperator">=</span> _maxviewwidth;
            <span class="asBracket">}</span>
            <span class="asReserved">if</span><span class="asBracket">(</span>nh <span class="asOperator">==</span> 0<span class="asBracket">)</span> <span class="asBracket">{</span>
                nh <span class="asOperator">=</span> _maxviewheight;
            <span class="asBracket">}</span>
            
            <span class="asComment">//trace(&quot;nodes width:&quot;+nw+&quot; height:&quot;+nh);
</span>            
            <span class="asReserved">if</span><span class="asBracket">(</span>d <span class="asOperator">==</span> 0<span class="asBracket">)</span> <span class="asBracket">{</span>
                diameter <span class="asOperator">=</span> 0; <span class="asComment">// root node 
</span>            <span class="asBracket">}</span> <span class="asReserved">else</span> <span class="asBracket">{</span>
                <span class="asComment">/* in another implementation this divided the real
                 * diameter by d not by d times the radiusINcrement
                 * which yields way too large values */</span>
                diameter <span class="asOperator">=</span> Math.sqrt<span class="asBracket">(</span>nw<span class="asOperator">*</span>nw <span class="asOperator">+</span> nh<span class="asOperator">*</span>nh<span class="asBracket">)</span> <span class="asOperator">/</span> <span class="asBracket">(</span>d <span class="asOperator">*</span> _radiusInc<span class="asBracket">)</span>;
            <span class="asBracket">}</span>
            
            <span class="asComment">/* diameter is an angular width value in radians,
             * so we convert it to degrees when used */</span>
            diameter <span class="asOperator">=</span> Geometry.rad2deg<span class="asBracket">(</span>diameter<span class="asBracket">)</span>;
            
            
            <span class="asComment">//trace(&quot;depth:&quot;+d+&quot; diameter:&quot;+diameter);
</span>            
            <span class="asComment">/* here the code checks if the node &apos;is expanded&apos;
             * which means if he has visible children
             * we do it differently, if the node is invisible
             * his angular width is 0, so is it for all his
             * children in case they are not visible
             * this may be a bit less efficient, but it fits
             * our code */</span>
            <span class="asReserved">if</span><span class="asBracket">(</span>_stree.getNoChildren<span class="asBracket">(</span>n<span class="asBracket">)</span> <span class="asOperator">&gt;</span> 0<span class="asBracket">)</span> <span class="asBracket">{</span>
                <span class="asComment">//trace(&quot;node:&quot;+n.id+&quot; has children...&quot;);
</span>                <span class="asReserved">for</span> <span class="asReserved">each</span><span class="asBracket">(</span>cn <span class="asReserved">in</span> _stree.getChildren<span class="asBracket">(</span>n<span class="asBracket">))</span> <span class="asBracket">{</span>
                    aw <span class="asOperator">+=</span> calcAngularWidth<span class="asBracket">(</span>cn, d<span class="asOperator">+</span>1<span class="asBracket">)</span>;
                    <span class="asComment">//trace(&quot;current aw for node:&quot;+n.id+&quot; is:&quot;+aw);
</span>                <span class="asBracket">}</span>
                aw <span class="asOperator">=</span> Math.max<span class="asBracket">(</span>diameter,aw<span class="asBracket">)</span>;
            <span class="asBracket">}</span> <span class="asReserved">else</span> <span class="asBracket">{</span>
                <span class="asComment">//trace(&quot;node:&quot;+n.id+&quot; has NO children...&quot;);
</span>                aw <span class="asOperator">=</span> diameter;
                <span class="asComment">//trace(&quot;current aw for node:&quot;+n.id+&quot; is:&quot;+aw);
</span>            <span class="asBracket">}</span>
            
            _currentDrawing.setAngularWidth<span class="asBracket">(</span>n,aw<span class="asBracket">)</span>;
            <span class="asComment">//trace(&quot;Set angular witdh of node:&quot;+n.id+&quot; to:&quot;+aw);
</span>            
            <span class="asReserved">return</span> aw;
        <span class="asBracket">}</span>
        
        <span class="asDoc">/**
         * @internal
         * This calculates the angular bounds of the layout
         * based on the last layout and the set bounds.
         * @param r The current root node.
         * */</span>
        <span class="asReserved">private</span> <span class="asFunction">function</span> calcAngularBounds<span class="asBracket">(</span>r<span class="asOperator">:</span>INode<span class="asBracket">)</span><span class="asOperator">:</span><span class="asReserved">void</span> <span class="asBracket">{</span>

            <span class="asVar">var</span> ppr<span class="asOperator">:</span>INode;
            <span class="asVar">var</span> n<span class="asOperator">:</span>INode;
            <span class="asVar">var</span> oldtree<span class="asOperator">:</span>IGTree;
            <span class="asVar">var</span> dt<span class="asOperator">:</span>Number;
            <span class="asVar">var</span> rw<span class="asOperator">:</span>Number;
            <span class="asVar">var</span> pw<span class="asOperator">:</span>Number;
            <span class="asVar">var</span> childorder<span class="asOperator">:</span>Array;
            <span class="asVar">var</span> cc<span class="asOperator">:</span>int;
            <span class="asVar">var</span> i<span class="asOperator">:</span>int;
            <span class="asVar">var</span> cindex<span class="asOperator">:</span>int;
            <span class="asVar">var</span> rp<span class="asOperator">:</span>Point;
            <span class="asVar">var</span> pp<span class="asOperator">:</span>Point;
            
            <span class="asReserved">if</span><span class="asBracket">(</span>_previousRoot <span class="asOperator">==</span> <span class="asReserved">null</span> <span class="asOperator">||</span> r <span class="asOperator">==</span> _previousRoot<span class="asBracket">)</span> <span class="asBracket">{</span>
                _previousRoot <span class="asOperator">=</span> r;
                <span class="asReserved">return</span>;
            <span class="asBracket">}</span>
            
            ppr <span class="asOperator">=</span> _stree.parents<span class="asBracket">[</span>_previousRoot<span class="asBracket">]</span>;
            
            <span class="asComment">/* maybe we have no parent ?*/</span>
            <span class="asReserved">if</span><span class="asBracket">(</span>ppr <span class="asOperator">==</span> <span class="asReserved">null</span><span class="asBracket">)</span> <span class="asBracket">{</span>
                _previousRoot <span class="asOperator">=</span> r;
                <span class="asReserved">return</span>;
            <span class="asBracket">}</span>
            
            <span class="asComment">/* now ppr is the parent node of the previous root */</span>
            
            childorder <span class="asOperator">=</span> calculateSortChildrenArray<span class="asBracket">(</span>r<span class="asBracket">)</span>;
            cc <span class="asOperator">=</span> childorder.length;
            <span class="asReserved">for</span><span class="asBracket">(</span>i<span class="asOperator">=</span>0; i <span class="asOperator">&lt;</span> cc; <span class="asOperator">++</span>i<span class="asBracket">)</span> <span class="asBracket">{</span>
                <span class="asComment">/* get the index from the sorted array, beware that
                 * the indexes should start with 0, have to make sure
                 * this is the case in the calculate sort function */</span>
                cindex <span class="asOperator">=</span> childorder<span class="asBracket">[</span>i<span class="asBracket">]</span>;
                n <span class="asOperator">=</span> _stree.getIthChildPerNode<span class="asBracket">(</span>r,cindex<span class="asBracket">)</span>;
                
                <span class="asComment">/* unclear purpose, probably a root node */</span>
                <span class="asReserved">if</span><span class="asBracket">(</span>n <span class="asOperator">==</span> ppr<span class="asBracket">)</span> <span class="asBracket">{</span>
                    <span class="asReserved">break</span>;
                <span class="asBracket">}</span>
                dt <span class="asOperator">+=</span> _currentDrawing.getAngularWidth<span class="asBracket">(</span>n<span class="asBracket">)</span>;
            <span class="asBracket">}</span>
            rw <span class="asOperator">=</span> _currentDrawing.getAngularWidth<span class="asBracket">(</span>r<span class="asBracket">)</span>;
            pw <span class="asOperator">=</span> _currentDrawing.getAngularWidth<span class="asBracket">(</span>ppr<span class="asBracket">)</span>;
            dt <span class="asOperator">=</span> <span class="asOperator">-</span>360 <span class="asOperator">*</span> <span class="asBracket">(</span>dt<span class="asOperator">+</span> <span class="asBracket">(</span>pw<span class="asOperator">/</span>2<span class="asBracket">))</span> <span class="asOperator">/</span> rw;
            
            rp <span class="asOperator">=</span> _currentDrawing.getRelCartCoordinates<span class="asBracket">(</span>r<span class="asBracket">)</span>;
            pp <span class="asOperator">=</span> _currentDrawing.getRelCartCoordinates<span class="asBracket">(</span>ppr<span class="asBracket">)</span>;
            
            <span class="asComment">/* now set the angular bounds */</span>
            _theta1 <span class="asOperator">=</span> dt <span class="asOperator">+</span> Geometry.rad2deg<span class="asBracket">(</span>Math.atan2<span class="asBracket">((</span>pp.y <span class="asOperator">-</span> rp.y<span class="asBracket">)</span>,<span class="asBracket">(</span>pp.x <span class="asOperator">-</span> rp.y<span class="asBracket">)))</span>;
            _theta2 <span class="asOperator">=</span> _theta1 <span class="asOperator">+</span> 360;
            _previousRoot <span class="asOperator">=</span> r;
        <span class="asBracket">}</span>
        
        
        <span class="asDoc">/**
         * @internal
         * Creates an array which in turn holds the indexes
         * of the children according to the ordered defined by
         * the current angular orientation of the nodes.
         * @param n The node whose children should be sorted.
         * @return An Array of indexes, which may be used in the getIthChildPerNode() method of the GTree.
         * @see org.un.flex.graphLayout.data.IGTree#getIthChildPerNode()
         * */</span>
        <span class="asReserved">private</span> <span class="asFunction">function</span> calculateSortChildrenArray<span class="asBracket">(</span>n<span class="asOperator">:</span>INode<span class="asBracket">)</span><span class="asOperator">:</span>Array <span class="asBracket">{</span>
            <span class="asVar">var</span> base<span class="asOperator">:</span>Number;
            <span class="asVar">var</span> cc<span class="asOperator">:</span>int;
            <span class="asVar">var</span> angles<span class="asOperator">:</span>Array; <span class="asComment">// an array of Numbers, i.e. of the angles of the children
</span>            <span class="asVar">var</span> result<span class="asOperator">:</span>Array; <span class="asComment">// the resulting sort order array
</span>            <span class="asVar">var</span> pn<span class="asOperator">:</span>INode; <span class="asComment">//parent node
</span>            <span class="asVar">var</span> cn<span class="asOperator">:</span>INode; <span class="asComment">// current child
</span>            <span class="asVar">var</span> pp<span class="asOperator">:</span>Point; <span class="asComment">// parent point
</span>            <span class="asVar">var</span> np<span class="asOperator">:</span>Point; <span class="asComment">// node point
</span>            <span class="asVar">var</span> cp<span class="asOperator">:</span>Point; <span class="asComment">// child point
</span>            <span class="asVar">var</span> i<span class="asOperator">:</span>int;
            
            base <span class="asOperator">=</span> 0;
            pn <span class="asOperator">=</span> _stree.parents<span class="asBracket">[</span>n<span class="asBracket">]</span>;
            
            <span class="asComment">/* we need that anyway */</span>
            np <span class="asOperator">=</span> _currentDrawing.getRelCartCoordinates<span class="asBracket">(</span>n<span class="asBracket">)</span>;
            
            <span class="asReserved">if</span><span class="asBracket">(</span>pn <span class="asOperator">!=</span> <span class="asReserved">null</span><span class="asBracket">)</span> <span class="asBracket">{</span>
                pp <span class="asOperator">=</span> _currentDrawing.getRelCartCoordinates<span class="asBracket">(</span>pn<span class="asBracket">)</span>;
                base <span class="asOperator">=</span> Geometry.rad2deg<span class="asBracket">(</span>Geometry.normaliseAngle<span class="asBracket">(</span>Math.atan2<span class="asBracket">(</span>pp.y <span class="asOperator">-</span> np.y, pp.x <span class="asOperator">-</span> np.x<span class="asBracket">)))</span>; 
            <span class="asBracket">}</span>
            
            <span class="asComment">// else base remains 0
</span>            
            cc <span class="asOperator">=</span> _stree.getNoChildren<span class="asBracket">(</span>n<span class="asBracket">)</span>;
            
            <span class="asComment">/* if we have no children, the array is empty, thus null */</span>
            <span class="asReserved">if</span><span class="asBracket">(</span>cc <span class="asOperator">==</span> 0<span class="asBracket">)</span> <span class="asBracket">{</span>
                <span class="asComment">//trace(&quot;Node n:&quot;+n.id+&quot; has no children, returning null sort array&quot;);
</span>                <span class="asReserved">return</span> <span class="asReserved">null</span>;
            <span class="asBracket">}</span>
            
            <span class="asComment">/* now the java code uses some hack to determine
             * if a branch was newly expanded checking the isStartVisible
             * property of a node, which is unclear what it really does
             * we ignore this part for now */</span>
            
            angles <span class="asOperator">=</span> <span class="asReserved">new</span> Array<span class="asBracket">(</span>cc<span class="asBracket">)</span>;
        
            <span class="asReserved">for</span><span class="asBracket">(</span>i<span class="asOperator">=</span>0; i <span class="asOperator">&lt;</span> cc; <span class="asOperator">++</span>i<span class="asBracket">)</span> <span class="asBracket">{</span>
                cn <span class="asOperator">=</span> _stree.getIthChildPerNode<span class="asBracket">(</span>n,i<span class="asBracket">)</span>;
                cp <span class="asOperator">=</span> _currentDrawing.getRelCartCoordinates<span class="asBracket">(</span>cn<span class="asBracket">)</span>;
                angles<span class="asBracket">[</span>i<span class="asBracket">]</span> <span class="asOperator">=</span> Geometry.normaliseAngleDeg<span class="asBracket">(</span><span class="asOperator">-</span>base <span class="asOperator">+</span> Geometry.rad2deg<span class="asBracket">(</span>Math.atan2<span class="asBracket">(</span>cp.y <span class="asOperator">-</span> np.y, cp.x <span class="asOperator">-</span> np.x<span class="asBracket">)))</span>;
                
                <span class="asComment">/*
                trace(&quot;childorder angle for child:&quot;+cn.id+&quot; of node:&quot;+n.id+&quot; has base:&quot;+base+
                    &quot; and angle:&quot;+(angles[i] / (2*Math.PI) * 360));
                */</span>
            <span class="asBracket">}</span>
            
            result <span class="asOperator">=</span> angles.sort<span class="asBracket">(</span>Array.NUMERIC <span class="asOperator">|</span> Array.RETURNINDEXEDARRAY<span class="asBracket">)</span>;
            <span class="asComment">/*
            trace(&quot;Built indexarray:&quot;+result.toString()+&quot; of array:&quot;+angles.toString()+
                &quot; for children:&quot;+_stree.getChildren(n).toString());
            */</span>
            <span class="asReserved">return</span> result;
        <span class="asBracket">}</span>
        
        
        <span class="asDoc">/**
         * @internal
         * calculate recursiveley the layout of the current
         * subtree
         * @param n The root of the current subtree.
         * @param r The current radius (distance from center).
         * @param theta1 The start of the current subtrees angular bounds region.
         * @param theta2 The end of the current subtrees angular bounds region.
         * */</span>
        <span class="asReserved">private</span> <span class="asFunction">function</span> calculateStaticLayout<span class="asBracket">(</span>n<span class="asOperator">:</span>INode, r<span class="asOperator">:</span>Number, theta1<span class="asOperator">:</span>Number, theta2<span class="asOperator">:</span>Number<span class="asBracket">)</span><span class="asOperator">:</span><span class="asReserved">void</span> <span class="asBracket">{</span>
            
            <span class="asVar">var</span> dtheta<span class="asOperator">:</span>Number;
            <span class="asVar">var</span> dtheta2<span class="asOperator">:</span>Number;
            <span class="asVar">var</span> awidth<span class="asOperator">:</span>Number;
            <span class="asVar">var</span> cfrac<span class="asOperator">:</span>Number;
            <span class="asVar">var</span> nfrac<span class="asOperator">:</span>Number;
            <span class="asVar">var</span> childorder<span class="asOperator">:</span>Array;
            <span class="asVar">var</span> i<span class="asOperator">:</span>int;
            <span class="asVar">var</span> cindex<span class="asOperator">:</span>int;
            <span class="asVar">var</span> cc<span class="asOperator">:</span>int;
            <span class="asVar">var</span> cn<span class="asOperator">:</span>INode;

            dtheta <span class="asOperator">=</span> theta2 <span class="asOperator">-</span> theta1;
            dtheta2 <span class="asOperator">=</span> dtheta <span class="asOperator">/</span> 2.0;
            nfrac <span class="asOperator">=</span> 0.0;
            cfrac <span class="asOperator">=</span> 0.0;
            awidth <span class="asOperator">=</span> _currentDrawing.getAngularWidth<span class="asBracket">(</span>n<span class="asBracket">)</span>;    
            
            childorder <span class="asOperator">=</span> calculateSortChildrenArray<span class="asBracket">(</span>n<span class="asBracket">)</span>;
            cc <span class="asOperator">=</span> childorder.length;
            <span class="asReserved">for</span><span class="asBracket">(</span>i<span class="asOperator">=</span>0; i <span class="asOperator">&lt;</span> cc; <span class="asOperator">++</span>i<span class="asBracket">)</span> <span class="asBracket">{</span>
                
                <span class="asComment">/* get the index from the sorted array */</span>                
                cindex <span class="asOperator">=</span> childorder<span class="asBracket">[</span>i<span class="asBracket">]</span>;
                
                cn <span class="asOperator">=</span> _stree.getIthChildPerNode<span class="asBracket">(</span>n,cindex<span class="asBracket">)</span>;            
                cfrac <span class="asOperator">=</span> _currentDrawing.getAngularWidth<span class="asBracket">(</span>cn<span class="asBracket">)</span> <span class="asOperator">/</span> awidth;
                
                <span class="asComment">/* do we need to recurse, 
                 * we just recurse if the node has children */</span>
                <span class="asReserved">if</span><span class="asBracket">(</span>_stree.getNoChildren<span class="asBracket">(</span>cn<span class="asBracket">)</span> <span class="asOperator">&gt;</span> 0<span class="asBracket">)</span> <span class="asBracket">{</span>
                    calculateStaticLayout<span class="asBracket">(</span>cn, r<span class="asOperator">+</span>_radiusInc, 
                        theta1 <span class="asOperator">+</span> <span class="asBracket">(</span>nfrac <span class="asOperator">*</span> dtheta<span class="asBracket">)</span>,
                        theta1 <span class="asOperator">+</span> <span class="asBracket">((</span>nfrac <span class="asOperator">+</span> cfrac<span class="asBracket">)</span> <span class="asOperator">*</span> dtheta<span class="asBracket">))</span>;
                <span class="asBracket">}</span>
                
                <span class="asComment">//trace(&quot;CSL: current radius:&quot;+r);
</span>                _currentDrawing.setPolarCoordinates<span class="asBracket">(</span>cn, r, theta1<span class="asOperator">+</span><span class="asBracket">(</span>nfrac<span class="asOperator">*</span>dtheta<span class="asBracket">)</span><span class="asOperator">+</span><span class="asBracket">(</span>cfrac<span class="asOperator">*</span>dtheta2<span class="asBracket">))</span>;
                nfrac <span class="asOperator">+=</span> cfrac;    
            <span class="asBracket">}</span>
        <span class="asBracket">}</span>
    <span class="asBracket">}</span>
<span class="asBracket">}</span></pre></body>
</html>
