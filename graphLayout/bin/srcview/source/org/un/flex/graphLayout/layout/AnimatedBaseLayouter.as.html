<!-- saved from url=(0014)about:internet -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<title>AnimatedBaseLayouter.as</title>
<link rel="stylesheet" type="text/css" href="../../../../../../SourceStyles.css"/>
</head>

<body><pre><span class="asComment">/* 
 * The MIT License
 *
 * Copyright (c) 2007 The SixDegrees Project Team
 * (Jason Bellone, Juan Rodriguez, Segolene de Basquiat, Daniel Lang).
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the &quot;Software&quot;), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */</span>
<span class="asPackage">package</span> org.un.flex.graphLayout.layout <span class="asBracket">{</span>

    <span class="asReserved">import</span> org.un.flex.graphLayout.visual.IVisualGraph;
    <span class="asReserved">import</span> org.un.flex.graphLayout.data.IGraph;
    <span class="asReserved">import</span> org.un.flex.graphLayout.data.IGTree;
    <span class="asReserved">import</span> flash.events.MouseEvent;
    <span class="asReserved">import</span> org.un.flex.graphLayout.visual.IVisualNode;
    <span class="asReserved">import</span> org.un.flex.graphLayout.data.INode;
    <span class="asReserved">import</span> org.un.flex.graphLayout.data.Graph;
    <span class="asReserved">import</span> org.un.flex.utils.Geometry;
    <span class="asReserved">import</span> flash.events.Event;
    <span class="asReserved">import</span> flash.geom.Point;
    <span class="asReserved">import</span> flash.utils.Timer;
    <span class="asReserved">import</span> flash.utils.Dictionary;
    <span class="asReserved">import</span> flash.events.TimerEvent;
    
    <span class="asDoc">/**
     * This subclass to the BaseLayouter encapsulates the methods
     * for animation, since they are typically common in layouters.
     * */</span>
    <span class="asReserved">public</span> <span class="asClass">class</span> AnimatedBaseLayouter <span class="asReserved">extends</span> BaseLayouter <span class="asReserved">implements</span> ILayoutAlgorithm <span class="asBracket">{</span>

        <span class="asDoc">/**
         * constant to define the radial animation type, which
         * interpolates node&apos;s polar coordinates.
         * */</span>
        <span class="asReserved">public</span> <span class="asReserved">const</span> ANIM_RADIAL<span class="asOperator">:</span>int <span class="asOperator">=</span> 1;
        
        <span class="asDoc">/**
         * constant to define the radial animation type, which
         * interpolates node&apos;s polar coordinates.
         * */</span>
        <span class="asReserved">public</span> <span class="asReserved">const</span> ANIM_STRAIGHT<span class="asOperator">:</span>int <span class="asOperator">=</span> 2;
        
        <span class="asDoc">/**
         * @internal
         * The amount of interpolation steps for the animation.
         * 100 seems reasonable. The interpolation will be 
         * broken into exactly that amount of steps.
         * */</span>
        <span class="asReserved">private</span> <span class="asReserved">const</span> _ANIMATIONSTEPS<span class="asOperator">:</span>int <span class="asOperator">=</span> 50;
        
        <span class="asDoc">/**
         * @internal
         * The timing of the animation steps is done using the arctan()
         * function, to achieve a slow-in-slow-out effect. The input to the
         * arctan() function is a range of the negative of this value
         * to the positive of this value. The larger the interval, the
         * longer the slow-in and slow-out part of the animation.
         * We keep it rather short.
         * */</span>
        <span class="asReserved">private</span> <span class="asReserved">const</span> _ANIMATIONTIMINGINTERVALSIZE<span class="asOperator">:</span>Number <span class="asOperator">=</span> 10; <span class="asComment">// -4 ; 4
</span>        
        <span class="asDoc">/**
         * @internal
         * This is the maximum timer delay for each animation step.
         * The animation steps will be timed between 0 ms
         * and this value in ms. This value will be multiplied with the
         * result of the current steps fraction of the timing interval
         * (see above) to trigger the next animation step
         * */</span>
        <span class="asReserved">private</span> <span class="asReserved">const</span> _MAXANIMTIMERDELAY<span class="asOperator">:</span>int <span class="asOperator">=</span> 100;

        <span class="asDoc">/**
         * Indicator if there is currently an animation in progress
         * */</span>
        <span class="asReserved">protected</span> <span class="asVar">var</span> _animInProgress<span class="asOperator">:</span>Boolean <span class="asOperator">=</span> <span class="asReserved">false</span>;

        <span class="asReserved">private</span> <span class="asVar">var</span> _animationType<span class="asOperator">:</span>int <span class="asOperator">=</span> ANIM_RADIAL;

        <span class="asDoc">/**
         * @internal
         * to indicate if an animation cycle has finished */</span>
        <span class="asReserved">private</span> <span class="asVar">var</span> _animCycleFinished<span class="asOperator">:</span>Boolean;
        
        <span class="asDoc">/**
         * @internal
         * the current step in the animation cycle */</span>
        <span class="asReserved">private</span> <span class="asVar">var</span> _animStep<span class="asOperator">:</span>int; 
        
        <span class="asDoc">/**
         * @internal
         * timer object for the animation */</span>
        <span class="asReserved">private</span> <span class="asVar">var</span> _animTimer<span class="asOperator">:</span>Timer;
        
        <span class="asDoc">/**
         * this holds the data for a layout drawing.
         * */</span>
        <span class="asReserved">private</span> <span class="asVar">var</span> _currentDrawing<span class="asOperator">:</span>BaseLayoutDrawing;
        
        <span class="asDoc">/**
         * The constructor initializes the layouter and may assign
         * already a VisualGraph object, but this can also be set later.
         * @param vg The VisualGraph object on which this layouter should work on.
         * */</span>
        <span class="asReserved">public</span> <span class="asFunction">function</span> AnimatedBaseLayouter<span class="asBracket">(</span>vg<span class="asOperator">:</span>IVisualGraph <span class="asOperator">=</span> <span class="asReserved">null</span><span class="asBracket">)</span><span class="asOperator">:</span><span class="asReserved">void</span> <span class="asBracket">{</span>
            
            <span class="asReserved">super</span><span class="asBracket">(</span>vg<span class="asBracket">)</span>;
            _animInProgress <span class="asOperator">=</span> <span class="asReserved">false</span>;
            _animCycleFinished <span class="asOperator">=</span> <span class="asReserved">false</span>;
        <span class="asBracket">}</span>

        <span class="asDoc">/**
         * @inheritDoc
         * */</span>
        <span class="asReserved">override</span> <span class="asReserved">public</span> <span class="asFunction">function</span> <span class="asReserved">get</span> animInProgress<span class="asBracket">()</span><span class="asOperator">:</span>Boolean <span class="asBracket">{</span>
            <span class="asReserved">return</span> _animInProgress;
        <span class="asBracket">}</span>

        <span class="asDoc">/**
         * @inheritDoc
         * */</span>
        <span class="asReserved">override</span> <span class="asReserved">protected</span> <span class="asFunction">function</span> <span class="asReserved">set</span> currentDrawing<span class="asBracket">(</span>dr<span class="asOperator">:</span>BaseLayoutDrawing<span class="asBracket">)</span><span class="asOperator">:</span><span class="asReserved">void</span> <span class="asBracket">{</span>
            _currentDrawing <span class="asOperator">=</span> dr;
            
            <span class="asComment">/* also set in the super class */</span>
            <span class="asReserved">super</span>.currentDrawing <span class="asOperator">=</span> dr;
        <span class="asBracket">}</span>


        <span class="asDoc">/**
         * Access to the type of animation, currently supported
         * type is:
         * ANIM_RADIAL which does interpolation of polar coordinates.
         * */</span>
        <span class="asReserved">protected</span> <span class="asFunction">function</span> <span class="asReserved">set</span> animationType<span class="asBracket">(</span>type<span class="asOperator">:</span>int<span class="asBracket">)</span><span class="asOperator">:</span><span class="asReserved">void</span> <span class="asBracket">{</span>
            _animationType <span class="asOperator">=</span> type;
        <span class="asBracket">}</span>

        <span class="asDoc">/**
         * This method kills any currently running timers
         * which is needed if some data is going to be
         * reinitialised. Remaining timer events could trigger
         * code referring to stale data and crash the program
         * otherwise.
         * */</span>
        <span class="asReserved">protected</span> <span class="asFunction">function</span> killTimer<span class="asBracket">()</span><span class="asOperator">:</span><span class="asReserved">void</span> <span class="asBracket">{</span>
            <span class="asReserved">if</span><span class="asBracket">(</span>_animTimer <span class="asOperator">!=</span> <span class="asReserved">null</span><span class="asBracket">)</span> <span class="asBracket">{</span>
                <span class="asComment">//trace(&quot;timer killed&quot;);
</span>                _animTimer.stop<span class="asBracket">()</span>;
                _animTimer <span class="asOperator">=</span> <span class="asReserved">null</span>;
            <span class="asBracket">}</span>
        <span class="asBracket">}</span>

        <span class="asDoc">/**
         * Reset/Reinitialise animation related variables.
         * */</span>
        <span class="asReserved">protected</span> <span class="asFunction">function</span> resetAnimation<span class="asBracket">()</span><span class="asOperator">:</span><span class="asReserved">void</span> <span class="asBracket">{</span>        
            <span class="asComment">/* reset animation cycle */</span>
            _animCycleFinished <span class="asOperator">=</span> <span class="asReserved">false</span>;
            _animStep <span class="asOperator">=</span> 0;
        <span class="asBracket">}</span>

        <span class="asDoc">/**
         * This method starts the animation according
         * to the preset type in the _animationType
         * variable. Currently only valid type is
         * &quot;RADIAL&quot; which animates by interpolating
         * polar coordinates. Other types like &quot;LINEAR&quot;
         * (interpolating cartesian coordinates) may be
         * added.
         * */</span>
        <span class="asReserved">protected</span> <span class="asFunction">function</span> startAnimation<span class="asBracket">()</span><span class="asOperator">:</span><span class="asReserved">void</span> <span class="asBracket">{</span>
            <span class="asReserved">switch</span><span class="asBracket">(</span>_animationType<span class="asBracket">)</span> <span class="asBracket">{</span>
                <span class="asReserved">case</span> ANIM_RADIAL<span class="asOperator">:</span>
                    interpolatePolarCoords<span class="asBracket">()</span>;
                    <span class="asReserved">break</span>;
                <span class="asReserved">case</span> ANIM_STRAIGHT<span class="asOperator">:</span>    
                    interpolateCartCoords<span class="asBracket">()</span>;
                    <span class="asReserved">break</span>;
                <span class="asReserved">default</span><span class="asOperator">:</span>
                    <span class="asTrace">trace</span><span class="asBracket">(</span><span class="asString">&quot;Illegal animation Type, default to ANIM_RADIAL&quot;</span><span class="asBracket">)</span>;
                    interpolatePolarCoords<span class="asBracket">()</span>;
                    <span class="asReserved">break</span>;
            <span class="asBracket">}</span>            
        <span class="asBracket">}</span>

        <span class="asDoc">/**
         * Interpolates the target Polar coordinates with the current real coordinates
         * achieving a smooth animation.
         * 
         * This method always executes only one step as part of the animation.
         * For each node, it&apos;s current coordinates are requested (and translated
         * into the relative polar coordinates. From the drawing object, the target
         * coordinates are taken and divided by the remaining interpolation steps.
         * With that the coordinates of the current interpolation step can be
         * calculated, which are subsequently directly applied to the node.
         * The method then checks if the animation target coordinates have been
         * reached. If not, and there are no more animation steps left, the
         * actual target coordinates are applied.
         * If there are animation steps left, a timer is started to call
         * the same function again for the next animation step.
         * */</span>
        <span class="asReserved">protected</span> <span class="asFunction">function</span> interpolatePolarCoords<span class="asBracket">()</span><span class="asOperator">:</span><span class="asReserved">void</span> <span class="asBracket">{</span>
            <span class="asVar">var</span> visVNodes<span class="asOperator">:</span>Dictionary;
            <span class="asVar">var</span> vn<span class="asOperator">:</span>IVisualNode;
            <span class="asVar">var</span> n<span class="asOperator">:</span>INode;
            <span class="asVar">var</span> i<span class="asOperator">:</span>int;
            <span class="asVar">var</span> currRadius<span class="asOperator">:</span>Number;
            <span class="asVar">var</span> currPhi<span class="asOperator">:</span>Number;
            <span class="asVar">var</span> currPoint<span class="asOperator">:</span>Point;
            <span class="asVar">var</span> targetRadius<span class="asOperator">:</span>Number;
            <span class="asVar">var</span> targetPhi<span class="asOperator">:</span>Number;
            <span class="asVar">var</span> deltaRadius<span class="asOperator">:</span>Number;
            <span class="asVar">var</span> deltaPhi<span class="asOperator">:</span>Number;
            <span class="asVar">var</span> stepRadius<span class="asOperator">:</span>Number;
            <span class="asVar">var</span> stepPhi<span class="asOperator">:</span>Number;
            <span class="asVar">var</span> stepPoint<span class="asOperator">:</span>Point;
            <span class="asVar">var</span> cyclefinished<span class="asOperator">:</span>Boolean;
            
            <span class="asComment">/* indicate an animation in progress */</span>
            _animInProgress <span class="asOperator">=</span> <span class="asReserved">true</span>;
             
            cyclefinished <span class="asOperator">=</span> <span class="asReserved">true</span>; <span class="asComment">// init to true, if any one node is not target, will be set to false
</span>            
            <span class="asComment">/* careful for invisible nodes, the values are not
             * calculated (obviously), so we need to make sure
             * to exclude them */</span>
            visVNodes <span class="asOperator">=</span> _vgraph.visibleVNodes;
            <span class="asReserved">for</span> <span class="asReserved">each</span><span class="asBracket">(</span>vn <span class="asReserved">in</span> visVNodes<span class="asBracket">)</span> <span class="asBracket">{</span>
                
                <span class="asComment">/* should be visible otherwise somethings wrong */</span>
                <span class="asReserved">if</span><span class="asBracket">(</span><span class="asOperator">!</span>vn.isVisible<span class="asBracket">)</span> <span class="asBracket">{</span>
                    <span class="asReserved">throw</span> Error<span class="asBracket">(</span><span class="asString">&quot;received invisible vnode from list of visible vnodes&quot;</span><span class="asBracket">)</span>;
                <span class="asBracket">}</span>
                
                n <span class="asOperator">=</span> vn.node;

                <span class="asComment">/* get relative target coordinates in polar form */</span>
                targetRadius <span class="asOperator">=</span> _currentDrawing.getPolarR<span class="asBracket">(</span>n<span class="asBracket">)</span>;
                targetPhi <span class="asOperator">=</span> _currentDrawing.getPolarPhi<span class="asBracket">(</span>n<span class="asBracket">)</span>;
                
                <span class="asComment">/* when we get the current values, we have to make sure
                 * that we convert the coordinates into relative ones,
                 * i.e. we need to subtract the origin */</span>
                n.vnode.refresh<span class="asBracket">()</span>;
                currPoint <span class="asOperator">=</span> <span class="asReserved">new</span> Point<span class="asBracket">(</span>vn.x, vn.y<span class="asBracket">)</span>;
                currPoint <span class="asOperator">=</span> currPoint.subtract<span class="asBracket">(</span>_currentDrawing.originOffset<span class="asBracket">)</span>;
                
                <span class="asReserved">if</span><span class="asBracket">(</span>_currentDrawing.centeredLayout<span class="asBracket">)</span> <span class="asBracket">{</span>
                    currPoint <span class="asOperator">=</span> currPoint.subtract<span class="asBracket">(</span>_currentDrawing.centerOffset<span class="asBracket">)</span>;
                <span class="asBracket">}</span>
                
                currRadius <span class="asOperator">=</span> Geometry.polarRadius<span class="asBracket">(</span>currPoint<span class="asBracket">)</span>;
                currPhi <span class="asOperator">=</span> Geometry.polarAngleDeg<span class="asBracket">(</span>currPoint<span class="asBracket">)</span>;
                
                <span class="asComment">/* not sure if this really fixes the animation end cycle ... */</span>
                deltaRadius <span class="asOperator">=</span> <span class="asBracket">(</span>targetRadius <span class="asOperator">-</span> currRadius<span class="asBracket">)</span> <span class="asOperator">*</span> _animStep <span class="asOperator">/</span> _ANIMATIONSTEPS;
                deltaPhi <span class="asOperator">=</span> <span class="asBracket">(</span>targetPhi <span class="asOperator">-</span> currPhi<span class="asBracket">)</span> <span class="asOperator">*</span> _animStep <span class="asOperator">/</span> _ANIMATIONSTEPS;
                
                
                <span class="asComment">/* calculate the intermediate coordinates */</span>
                stepRadius <span class="asOperator">=</span> currRadius <span class="asOperator">+</span> deltaRadius;
                stepPhi <span class="asOperator">=</span> currPhi <span class="asOperator">+</span> deltaPhi;
                
                <span class="asComment">/* check if we are already done or not */</span>
                <span class="asReserved">if</span><span class="asBracket">(</span>currPoint <span class="asOperator">!=</span> _currentDrawing.getRelCartCoordinates<span class="asBracket">(</span>n<span class="asBracket">))</span> <span class="asBracket">{</span>
                    cyclefinished <span class="asOperator">=</span> <span class="asReserved">false</span>;
                <span class="asBracket">}</span>
                
                <span class="asComment">/* we cannot set the coordinates in the _currentDrawing,
                 * as we store our target coordinates there,
                 * we need to set them directly in the vnode */</span>
                stepPoint <span class="asOperator">=</span> Geometry.cartFromPolarDeg<span class="asBracket">(</span>stepRadius,stepPhi<span class="asBracket">)</span>;
                
                <span class="asComment">/* adjust the origin */</span>
                stepPoint <span class="asOperator">=</span> stepPoint.add<span class="asBracket">(</span>_currentDrawing.originOffset<span class="asBracket">)</span>;
                
                <span class="asComment">/* here we may need to add the center offset */</span>
                <span class="asReserved">if</span><span class="asBracket">(</span>_currentDrawing.centeredLayout<span class="asBracket">)</span> <span class="asBracket">{</span>
                    stepPoint <span class="asOperator">=</span> stepPoint.add<span class="asBracket">(</span>_currentDrawing.centerOffset<span class="asBracket">)</span>;
                <span class="asBracket">}</span>
                
                <span class="asComment">/*
                trace(&quot;interpolating node:&quot;+n.id+&quot; cP:&quot;+currPoint.toString()+&quot; cr:&quot;+currRadius+&quot; cp:&quot;+currPhi+
                    &quot; tr:&quot;+targetRadius+&quot; tp:&quot;+targetPhi+&quot; sP:&quot;+stepPoint.toString()+&quot; sr:&quot;+stepRadius+
                    &quot; sp:&quot;+stepPhi); 
                */</span>
                
                <span class="asComment">/* set into the vnode */</span>
                vn.x <span class="asOperator">=</span> stepPoint.x;
                vn.y <span class="asOperator">=</span> stepPoint.y;
                
                <span class="asComment">/* commit, i.e. move the node */</span>
                vn.commit<span class="asBracket">()</span>;
                
                <span class="asComment">/* make sure the edges are redrawn */</span>
                _layoutChanged <span class="asOperator">=</span> <span class="asReserved">true</span>;
                _vgraph.invalidateDisplayList<span class="asBracket">()</span>;
            <span class="asBracket">}</span>
            
            <span class="asComment">/* check if we ran out of anim cycles, but are not finished */</span>
            <span class="asReserved">if</span><span class="asBracket">(</span>_animStep <span class="asOperator">&gt;=</span> _ANIMATIONSTEPS<span class="asBracket">)</span> <span class="asBracket">{</span>
                <span class="asReserved">if</span><span class="asBracket">(</span>cyclefinished<span class="asBracket">)</span> <span class="asBracket">{</span>
                    _animCycleFinished <span class="asOperator">=</span> <span class="asReserved">true</span>;
                <span class="asBracket">}</span> <span class="asReserved">else</span> <span class="asBracket">{</span>
                    <span class="asTrace">trace</span><span class="asBracket">(</span><span class="asString">&quot;Exceeded animation steps, but still not finished&quot;</span><span class="asBracket">)</span>;
                    <span class="asComment">/* cap the animStep here */</span>
                    _animStep <span class="asOperator">=</span> _ANIMATIONSTEPS;
                    applyTargetToNodes<span class="asBracket">(</span>visVNodes<span class="asBracket">)</span>;
                    _animCycleFinished <span class="asOperator">=</span> <span class="asReserved">true</span>;
                <span class="asBracket">}</span>
            <span class="asBracket">}</span> <span class="asReserved">else</span> <span class="asBracket">{</span>
                _animCycleFinished <span class="asOperator">=</span> <span class="asReserved">false</span>;
                <span class="asOperator">++</span>_animStep;
            <span class="asBracket">}</span>
            
            <span class="asComment">/* now we have to call start the timer, to do the next
             * step, unless the cycle is completed */</span>
            <span class="asReserved">if</span><span class="asBracket">(</span><span class="asOperator">!</span>_animCycleFinished<span class="asBracket">)</span> <span class="asBracket">{</span>
                startAnimTimer<span class="asBracket">()</span>;
            <span class="asBracket">}</span> <span class="asReserved">else</span> <span class="asBracket">{</span>
                <span class="asComment">/* indicate the animation has finished */</span>
                _animInProgress <span class="asOperator">=</span> <span class="asReserved">false</span>;
            <span class="asBracket">}</span>
        <span class="asBracket">}</span>
        
        <span class="asDoc">/**
         * Interpolates the target coordinates with the current real coordinates
         * achieving a smooth animation.
         * It works in the same way as interpolatePolarCoords() but
         * uses cartesian coordinates.
         * @see interpolatePolarCoords()
         * */</span>
        <span class="asReserved">protected</span> <span class="asFunction">function</span> interpolateCartCoords<span class="asBracket">()</span><span class="asOperator">:</span><span class="asReserved">void</span> <span class="asBracket">{</span>
            <span class="asVar">var</span> visVNodes<span class="asOperator">:</span>Dictionary;
            <span class="asVar">var</span> vn<span class="asOperator">:</span>IVisualNode;
            <span class="asVar">var</span> n<span class="asOperator">:</span>INode;
            <span class="asVar">var</span> i<span class="asOperator">:</span>int;
            <span class="asVar">var</span> currPoint<span class="asOperator">:</span>Point;
            <span class="asVar">var</span> deltaPoint<span class="asOperator">:</span>Point;
            <span class="asVar">var</span> stepPoint<span class="asOperator">:</span>Point;
            <span class="asVar">var</span> targetPoint<span class="asOperator">:</span>Point;
            <span class="asVar">var</span> cyclefinished<span class="asOperator">:</span>Boolean;
            
            <span class="asComment">/* indicate an animation in progress */</span>
            _animInProgress <span class="asOperator">=</span> <span class="asReserved">true</span>;
             
            cyclefinished <span class="asOperator">=</span> <span class="asReserved">true</span>; <span class="asComment">// init to true, if any one node is not target, will be set to false
</span>            
            <span class="asComment">/* careful for invisible nodes, the values are not
             * calculated (obviously), so we need to make sure
             * to exclude them */</span>
            visVNodes <span class="asOperator">=</span> _vgraph.visibleVNodes;
            <span class="asReserved">for</span> <span class="asReserved">each</span><span class="asBracket">(</span>vn <span class="asReserved">in</span> visVNodes<span class="asBracket">)</span> <span class="asBracket">{</span>
                
                <span class="asComment">/* should be visible otherwise somethings wrong */</span>
                <span class="asReserved">if</span><span class="asBracket">(</span><span class="asOperator">!</span>vn.isVisible<span class="asBracket">)</span> <span class="asBracket">{</span>
                    <span class="asReserved">throw</span> Error<span class="asBracket">(</span><span class="asString">&quot;received invisible vnode from list of visible vnodes&quot;</span><span class="asBracket">)</span>;
                <span class="asBracket">}</span>
                
                n <span class="asOperator">=</span> vn.node;

                <span class="asComment">/* get relative target coordinates in polar form */</span>
                targetPoint <span class="asOperator">=</span> _currentDrawing.getRelCartCoordinates<span class="asBracket">(</span>n<span class="asBracket">)</span>;

                <span class="asComment">/* when we get the current values, we have to make sure
                 * that we convert the coordinates into relative ones,
                 * i.e. we need to subtract the origin */</span>
                n.vnode.refresh<span class="asBracket">()</span>;
                currPoint <span class="asOperator">=</span> <span class="asReserved">new</span> Point<span class="asBracket">(</span>vn.x, vn.y<span class="asBracket">)</span>;
                currPoint <span class="asOperator">=</span> currPoint.subtract<span class="asBracket">(</span>_currentDrawing.originOffset<span class="asBracket">)</span>;
                
                <span class="asReserved">if</span><span class="asBracket">(</span>_currentDrawing.centeredLayout<span class="asBracket">)</span> <span class="asBracket">{</span>
                    currPoint <span class="asOperator">=</span> currPoint.subtract<span class="asBracket">(</span>_currentDrawing.centerOffset<span class="asBracket">)</span>;
                <span class="asBracket">}</span>

                <span class="asComment">/* check if we are already done or not */</span>
                <span class="asReserved">if</span><span class="asBracket">(</span>currPoint <span class="asOperator">!=</span> targetPoint<span class="asBracket">)</span> <span class="asBracket">{</span>
                    cyclefinished <span class="asOperator">=</span> <span class="asReserved">false</span>;
                <span class="asBracket">}</span>

                deltaPoint <span class="asOperator">=</span> <span class="asReserved">new</span> Point<span class="asBracket">(</span> <span class="asBracket">(</span>targetPoint.x <span class="asOperator">-</span> currPoint.x<span class="asBracket">)</span> <span class="asOperator">*</span> _animStep <span class="asOperator">/</span> _ANIMATIONSTEPS,
                    <span class="asBracket">(</span>targetPoint.y <span class="asOperator">-</span> currPoint.y<span class="asBracket">)</span> <span class="asOperator">*</span> _animStep <span class="asOperator">/</span> _ANIMATIONSTEPS<span class="asBracket">)</span>;
                
                stepPoint <span class="asOperator">=</span> currPoint.add<span class="asBracket">(</span>deltaPoint<span class="asBracket">)</span>;
                                
                <span class="asComment">/* adjust the origin */</span>
                stepPoint <span class="asOperator">=</span> stepPoint.add<span class="asBracket">(</span>_currentDrawing.originOffset<span class="asBracket">)</span>;
                
                <span class="asComment">/* here we may need to add the center offset */</span>
                <span class="asReserved">if</span><span class="asBracket">(</span>_currentDrawing.centeredLayout<span class="asBracket">)</span> <span class="asBracket">{</span>
                    stepPoint <span class="asOperator">=</span> stepPoint.add<span class="asBracket">(</span>_currentDrawing.centerOffset<span class="asBracket">)</span>;
                <span class="asBracket">}</span>
                                
                <span class="asComment">/* set into the vnode */</span>
                vn.x <span class="asOperator">=</span> stepPoint.x;
                vn.y <span class="asOperator">=</span> stepPoint.y;
                
                <span class="asComment">/* commit, i.e. move the node */</span>
                vn.commit<span class="asBracket">()</span>;
                
                <span class="asComment">/* make sure the edges are redrawn */</span>
                _layoutChanged <span class="asOperator">=</span> <span class="asReserved">true</span>;
                _vgraph.invalidateDisplayList<span class="asBracket">()</span>;
            <span class="asBracket">}</span>
            
            <span class="asComment">/* check if we ran out of anim cycles, but are not finished */</span>
            <span class="asReserved">if</span><span class="asBracket">(</span>_animStep <span class="asOperator">&gt;=</span> _ANIMATIONSTEPS<span class="asBracket">)</span> <span class="asBracket">{</span>
                <span class="asReserved">if</span><span class="asBracket">(</span>cyclefinished<span class="asBracket">)</span> <span class="asBracket">{</span>
                    _animCycleFinished <span class="asOperator">=</span> <span class="asReserved">true</span>;
                <span class="asBracket">}</span> <span class="asReserved">else</span> <span class="asBracket">{</span>
                    <span class="asTrace">trace</span><span class="asBracket">(</span><span class="asString">&quot;Exceeded animation steps, but still not finished&quot;</span><span class="asBracket">)</span>;
                    <span class="asComment">/* cap the animStep here */</span>
                    _animStep <span class="asOperator">=</span> _ANIMATIONSTEPS;
                    applyTargetToNodes<span class="asBracket">(</span>visVNodes<span class="asBracket">)</span>;
                    _animCycleFinished <span class="asOperator">=</span> <span class="asReserved">true</span>;
                <span class="asBracket">}</span>
            <span class="asBracket">}</span> <span class="asReserved">else</span> <span class="asBracket">{</span>
                _animCycleFinished <span class="asOperator">=</span> <span class="asReserved">false</span>;
                <span class="asOperator">++</span>_animStep;
            <span class="asBracket">}</span>
            
            <span class="asComment">/* now we have to call start the timer, to do the next
             * step, unless the cycle is completed */</span>
            <span class="asReserved">if</span><span class="asBracket">(</span><span class="asOperator">!</span>_animCycleFinished<span class="asBracket">)</span> <span class="asBracket">{</span>
                startAnimTimer<span class="asBracket">()</span>;
            <span class="asBracket">}</span> <span class="asReserved">else</span> <span class="asBracket">{</span>
                <span class="asComment">/* indicate the animation has finished */</span>
                _animInProgress <span class="asOperator">=</span> <span class="asReserved">false</span>;
            <span class="asBracket">}</span>
        <span class="asBracket">}</span>
        
        
        
        <span class="asDoc">/**
         * @internal
         * This calculates the timer delay for a slow-in / slow-out
         * animation in each animation step.
         * */</span>
        <span class="asReserved">private</span> <span class="asFunction">function</span> startAnimTimer<span class="asBracket">()</span><span class="asOperator">:</span><span class="asReserved">void</span> <span class="asBracket">{</span>
            <span class="asVar">var</span> timerdelay<span class="asOperator">:</span>Number;
            <span class="asVar">var</span> factor<span class="asOperator">:</span>Number;
            <span class="asVar">var</span> signedAnimStep<span class="asOperator">:</span>int;
            <span class="asVar">var</span> factorinput<span class="asOperator">:</span>Number;
                
            <span class="asComment">/* modify the current animation step to range from -/+ around 0 */</span>
            signedAnimStep <span class="asOperator">=</span> _animStep <span class="asOperator">-</span> <span class="asBracket">(</span>_ANIMATIONSTEPS <span class="asOperator">/</span> 2<span class="asBracket">)</span>; <span class="asComment">// so we should be at 0 at the middle
</span>
            <span class="asComment">/* this is the input into into the atan() function, which depends on the
             * timing interval and the current signed animation step */</span>
            factorinput <span class="asOperator">=</span> _ANIMATIONTIMINGINTERVALSIZE <span class="asOperator">*</span> <span class="asBracket">(</span>signedAnimStep <span class="asOperator">/</span> _ANIMATIONSTEPS<span class="asBracket">)</span>;            
            
            <span class="asComment">//trace(&quot;factor input:&quot;+factorinput);
</span>            
            <span class="asComment">/* calculate the timing factor using the atan() function
             * since we take the absolute value, 
             * its range goes from PI / 2 to 0 back to PI / 2 */</span>
            factor <span class="asOperator">=</span> Math.abs<span class="asBracket">(</span>Math.atan<span class="asBracket">(</span>factorinput<span class="asBracket">))</span>;
            
            <span class="asComment">//trace(&quot;factor fraction of PI:&quot;+(factor / Math.PI));
</span>            
            <span class="asComment">/* now the delay for our timer is now the factors fraction
             * of PI/2 times the maximum timer delay, i.e. the full timer
             * delay if the factor has a value of PI / 2 */</span>
            timerdelay <span class="asOperator">=</span> <span class="asBracket">(</span>factor <span class="asOperator">/</span> <span class="asBracket">(</span>Math.PI <span class="asOperator">/</span> 2<span class="asBracket">))</span> <span class="asOperator">*</span> _MAXANIMTIMERDELAY;
            
            <span class="asComment">//trace(&quot;Setting timerdelay to:&quot;+timerdelay+&quot; milliseconds in step:&quot;+_animStep);
</span>            
            <span class="asComment">/* now creating the new timer with the specified delay
             * and ask for one execution, then the event handler will be
             * called, which does nothing except to call the interpolation
             * method again */</span>
            _animTimer <span class="asOperator">=</span> <span class="asReserved">new</span> Timer<span class="asBracket">(</span>timerdelay, 1<span class="asBracket">)</span>;
            _animTimer.addEventListener<span class="asBracket">(</span>TimerEvent.TIMER_COMPLETE, animTimerFired<span class="asBracket">)</span>;
            _animTimer.start<span class="asBracket">()</span>;
        <span class="asBracket">}</span>
        
        <span class="asDoc">/**
         * @internal
         * Event handler when the timer fired, just calls the
         * interpolation function again to do another animation
         * cycle.
         * @param event The fired timer event, will be ignored anyway.
         * */</span>
        <span class="asReserved">private</span> <span class="asFunction">function</span> animTimerFired<span class="asBracket">(</span>event<span class="asOperator">:</span>TimerEvent <span class="asOperator">=</span> <span class="asReserved">null</span><span class="asBracket">)</span><span class="asOperator">:</span><span class="asReserved">void</span> <span class="asBracket">{</span>
            <span class="asComment">//trace(&quot;Timer fired!&quot;);
</span>            startAnimation<span class="asBracket">()</span>;
        <span class="asBracket">}</span>    

    <span class="asBracket">}</span>
<span class="asBracket">}</span></pre></body>
</html>
