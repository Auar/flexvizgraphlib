<!-- saved from url=(0014)about:internet -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<title>VisualGraph.as</title>
<link rel="stylesheet" type="text/css" href="../../../../../../SourceStyles.css"/>
</head>

<body><pre><span class="asComment">/* 
 * The MIT License
 *
 * Copyright (c) 2007 The SixDegrees Project Team
 * (Jason Bellone, Juan Rodriguez, Segolene de Basquiat, Daniel Lang).
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the &quot;Software&quot;), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */</span>
<span class="asPackage">package</span> org.un.flex.graphLayout.visual <span class="asBracket">{</span>
    
    <span class="asReserved">import</span> mx.core.UIComponent;
    <span class="asReserved">import</span> mx.containers.Canvas;
    
    <span class="asReserved">import</span> flash.utils.Timer;
    
    <span class="asReserved">import</span> org.un.flex.graphLayout.data.IGraph;
    <span class="asReserved">import</span> org.un.flex.graphLayout.data.INode;
    <span class="asReserved">import</span> org.un.flex.graphLayout.layout.ILayoutAlgorithm;
    <span class="asReserved">import</span> org.un.flex.graphLayout.layout.IEdgeRenderer;
    
    <span class="asReserved">import</span> org.un.flex.graphLayout.layout.DefaultEdgeRenderer;
    <span class="asReserved">import</span> org.un.flex.utils.events.VGraphEvent;
    
    <span class="asReserved">import</span> flash.events.MouseEvent;
    <span class="asReserved">import</span> mx.events.FlexEvent;
    <span class="asReserved">import</span> org.un.flex.graphLayout.data.IEdge;
    <span class="asReserved">import</span> mx.effects.Effect;
    <span class="asReserved">import</span> mx.events.EffectEvent;
    <span class="asReserved">import</span> flash.events.Event;
    <span class="asReserved">import</span> flash.utils.Dictionary;
    <span class="asReserved">import</span> flash.events.TimerEvent;
    <span class="asReserved">import</span> flash.geom.Rectangle;
    <span class="asReserved">import</span> mx.events.IndexChangedEvent;
    <span class="asReserved">import</span> mx.core.IFactory;
    <span class="asReserved">import</span> mx.core.IDataRenderer;
    <span class="asReserved">import</span> flash.display.DisplayObject;
    <span class="asReserved">import</span> flash.geom.Point;
    <span class="asReserved">import</span> flash.display.Graphics;

    <span class="asDoc">/**
     *  Dispatched when there is any change to the nodes and/or links of this graph.
     *
     *  @eventType flash.events.Event
     */</span>
    <span class="asBracket">[</span><span class="asMetadata">Event</span><span class="asBracket">(</span>name<span class="asOperator">=</span><span class="asString">&quot;vgraphChanged&quot;</span>, type<span class="asOperator">=</span><span class="asString">&quot;flash.events.Event&quot;</span><span class="asBracket">)]</span>

    <span class="asDoc">/**
     * This component can visualize and layout a graph data structure in 
     * a Flex application. It is derived from canvas and thus behaves much
     * like that in general.
     * 
     * Currently the graphs are required to be connected. And for most layouts
     * a root node is required (as they are tree based).
     * 
     * A graph object needs to be specified as well as a layouter object
     * that implements the ILayoutAlgorithm interface.
     * 
     * XXX provide example code here
     * */</span>
    <span class="asReserved">public</span> <span class="asClass">class</span> VisualGraph <span class="asReserved">extends</span> Canvas <span class="asReserved">implements</span> IVisualGraph <span class="asBracket">{</span>

        <span class="asDoc">/**
         * We keep a reference to ourselves (this) in this attribute.
         * Not really necessary, but it makes the code more clear if
         * a method is called, that really belongs to the super class.
         * */</span>
        <span class="asReserved">private</span> <span class="asVar">var</span> _canvas<span class="asOperator">:</span>Canvas;

        <span class="asDoc">/**
         * This property holds the Graph object with the graph
         * data, that is supposed to be visualised. This is also
         * the only data structure that keeps track of nodes and
         * edges.
         * */</span>
        <span class="asReserved">private</span> <span class="asVar">var</span> _graph<span class="asOperator">:</span>IGraph <span class="asOperator">=</span> <span class="asReserved">null</span>;
    
        <span class="asDoc">/**
         * This property holds the layouter object. The layouter does the 
         * calculation of the layout and the placement of the nodes.
         * It may be exchanged on the fly.
         * */</span>
        <span class="asReserved">private</span> <span class="asVar">var</span> _layouter<span class="asOperator">:</span>ILayoutAlgorithm;

        <span class="asDoc">/**
         * This is a drawing surface to draw the edges on. It is only
         * used for the edges and is added as a child to the canvas.
         * */</span>
        <span class="asReserved">private</span> <span class="asVar">var</span> _drawingSurface<span class="asOperator">:</span>UIComponent; 

        <span class="asDoc">/**
         * Every visual node is associated with an UIComponent that 
         * will be the actual visual representation of the node in the
         * Flashplayer. This UIComponent (which is typically an ItemRenderer)
         * is called a &quot;view&quot;. Node&apos;s views are now mainly created on
         * demand and destroyed if the node is currently not visible
         * to save resources. This map keeps track of which VNode belongs
         * to which view. This is required as in certain events, we get
         * only access to the UIComponent and we need to get hold of
         * the corresponding node.
         * */</span>
        <span class="asReserved">private</span> <span class="asVar">var</span> _viewToVNodeMap<span class="asOperator">:</span>Dictionary;

        <span class="asDoc">/**
         * The standard origin is the upper left corner, but if
         * the graph is scrolled, this origin may change, so we keep
         * track of that here.
         * */</span>
        <span class="asReserved">private</span> <span class="asVar">var</span> _origin<span class="asOperator">:</span>Point;
        
        <span class="asComment">/* drag and drop support */</span>
        
        <span class="asDoc">/**
         * This is the current UIComponent that is dragged by the mouse.
         * */</span>
        <span class="asReserved">private</span> <span class="asVar">var</span> _dragComponent<span class="asOperator">:</span>UIComponent;

        <span class="asDoc">/**
         * These two maps keep the drag cursor offset positions
         * for each dragged component. This allows to (theoretically)
         * drag more than one component at once and to correctly reposition the
         * component during the drag and at the drop.
         * */</span>
        <span class="asReserved">private</span> <span class="asVar">var</span> _drag_x_offsetMap<span class="asOperator">:</span>Dictionary;
        <span class="asReserved">private</span> <span class="asVar">var</span> _drag_y_offsetMap<span class="asOperator">:</span>Dictionary;
        
        <span class="asDoc">/**
         * There is generally support to restrict dragging and dropping
         * to a certain area. These bounds are kept for each dragged
         * component in this map.
         * */</span>
        <span class="asReserved">private</span> <span class="asVar">var</span> _drag_boundsMap<span class="asOperator">:</span>Dictionary;

        <span class="asDoc">/**
         * The drag cursors starting position is required
         * if we do a &quot;background drag&quot;, i.e. scroll the whole
         * VisualGraph around. All this does is basically moving all
         * components with the mouse, thus creating the effect of a 
         * background drag.
         * */</span>
        <span class="asReserved">private</span> <span class="asVar">var</span> _dragCursorStartX<span class="asOperator">:</span>Number;
        <span class="asReserved">private</span> <span class="asVar">var</span> _dragCursorStartY<span class="asOperator">:</span>Number;
        
        <span class="asDoc">/**
         * To distinguish an active mouse move drag that drags
         * a component from one that should drag the background, 
         * we need this property.
         * */</span>
        <span class="asReserved">private</span> <span class="asVar">var</span> _backgroundDragInProgress<span class="asOperator">:</span>Boolean <span class="asOperator">=</span> <span class="asReserved">false</span>;

        <span class="asComment">/* Rendering */</span>

        <span class="asDoc">/**
         * We allow the specification of an EdgeRenderer object
         * that draws the Edges using the graphics part of the
         * drawing surface.
         * */</span>
        <span class="asReserved">private</span> <span class="asVar">var</span> _edgeRenderer<span class="asOperator">:</span>IEdgeRenderer <span class="asOperator">=</span> <span class="asReserved">null</span>;

        <span class="asDoc">/**
         * We allow the specification of an ItemRenderer (i.e. an IFactory)
         * that allows us to specify the view&apos;s for each node in MXML
         * */</span>
        <span class="asReserved">private</span> <span class="asVar">var</span> _itemRendererFactory<span class="asOperator">:</span>IFactory <span class="asOperator">=</span> <span class="asReserved">null</span>;
        
        <span class="asComment">/* Spring Graph also allowed a specification of an IViewFactory
         * which is a custom implementation of a factory that returns
         * UIComponents to be used as a view for a node.
         * Currently not implemented, nor needed.
        private var _viewFactory:IViewFactory = null;
         */</span>

        <span class="asDoc">/**
         * We currently keep the global default parameters
         * to draw edges (line width, color, alpha channel)
         * in this object. The params to be expected are
         * &quot;alpha&quot;
         * &quot;thickness&quot;
         * &quot;color&quot;
         * &quot;distcolor&quot; 
         * I am not too happy with this, but we keep it for now.
         * */</span>
        <span class="asReserved">private</span> <span class="asVar">var</span> _globalEdgeSettings<span class="asOperator">:</span>Object;

        <span class="asComment">/* The visibility of nodes can be controlled in a few ways.
         * The principal limit is to restrict nodes to only be visible if they
         * are within a certain distance (in degrees of separation) from the
         * current root node. In addition previous root nodes can be
         * made visible */</span>

        <span class="asDoc">/**
         * This property controls if any visibility limit is currently
         * active at all. Strongly recommended for large graphs.
         * The application will be brought to its knees if thousands of nodes
         * should be displayed. 
         * */</span>
        <span class="asReserved">private</span> <span class="asVar">var</span> _visibilityLimitActive<span class="asOperator">:</span>Boolean <span class="asOperator">=</span> <span class="asReserved">true</span>;
        
        <span class="asDoc">/**
         * Controls the maximum distance from the root that a node
         * can have to still be visible.
         * */</span>
        <span class="asReserved">private</span> <span class="asVar">var</span> _maxVisibleDistance<span class="asOperator">:</span>uint <span class="asOperator">=</span> uint.MAX_VALUE;

        <span class="asDoc">/**
         * This object hash contains all node ids 
         * of nodes which are currently within the visible
         * distance limit. This hash is typically initialised from
         * from the Graph object. These nodes are NOT all
         * visible nodes (since the history nodes are also
         * visible).
         * */</span>
        <span class="asReserved">private</span> <span class="asVar">var</span> _nodeIDsWithinDistanceLimit<span class="asOperator">:</span>Dictionary;
        
        <span class="asDoc">/**
         * This object contains the previuos hash of nodes
         * within the distance. To keep this helps to avoid
         * running through all nodes to render the olds
         * invisible and the new ones visible.
         * */</span>
        <span class="asReserved">private</span> <span class="asVar">var</span> _prevNodeIDsWithinDistanceLimit<span class="asOperator">:</span>Dictionary;
        
        <span class="asDoc">/**
         * This is the number of nodes within the distance
         * limit.
         * */</span>
        <span class="asReserved">private</span> <span class="asVar">var</span> _noNodesWithinDistance<span class="asOperator">:</span>uint;
        
        <span class="asDoc">/**
         * This Dictionary holds all visible nodes,
         * i.e. those within the limit and the history
         * nodes (if the history is enabled), or even all
         * nodes, if the visibility limitation is disabled.
         * This directory is indexed by VNode and the values
         * are the same VNode.
         * */</span>
        <span class="asReserved">private</span> <span class="asVar">var</span> _visibleVNodes<span class="asOperator">:</span>Dictionary;
        
        <span class="asDoc">/**
         * The number of currently visible VNodes.
         * */</span>
        <span class="asReserved">private</span> <span class="asVar">var</span> _noVisibleVNodes<span class="asOperator">:</span>uint;
        
        <span class="asDoc">/**
         * This Dictionary keeps track of all currently
         * visible edges. An edge is visible iff both
         * attached nodes are visible. This hash is indexed
         * with Edges and the values are the same Edge objects.
         * (We do not work really with VEdges, so we keep the
         * Graph Edges here).
         * */</span>
        <span class="asReserved">private</span> <span class="asVar">var</span> _visibleEdges<span class="asOperator">:</span>Dictionary;
        
        <span class="asComment">/* root nodes, distinguished nodes and history */</span>
        
        <span class="asDoc">/**
         * This is the current focused / root node. It will be
         * used as the root for any tree computations and
         * currently all layouters depend on this.
         * Typically the root node is selected by double-click.
         * */</span>
        <span class="asReserved">private</span> <span class="asVar">var</span> _currentRootVNode<span class="asOperator">:</span>IVisualNode <span class="asOperator">=</span> <span class="asReserved">null</span>;
                
        <span class="asDoc">/**
         * There is currently a &quot;distinguished&quot; node, which is
         * different from the root node. The distinguished node is
         * selected by single-click. The current effect of having
         * a distinguished node, is that it&apos;s attached edges are
         * drawn in a different colour. This may be changed.
         * */</span>
        <span class="asReserved">private</span> <span class="asVar">var</span> _distinguishedNode<span class="asOperator">:</span>IVisualNode <span class="asOperator">=</span> <span class="asReserved">null</span>;
    
        <span class="asDoc">/**
         * This hash keeps track of all the past root VNodes
         * thus being the history. If showHistory is enabled,
         * these nodes are also visible even if they are outside
         * the visible distance.
         * */</span>
        <span class="asReserved">private</span> <span class="asVar">var</span> _currentVNodeHistory<span class="asOperator">:</span>Array <span class="asOperator">=</span> <span class="asReserved">null</span>;
        
        <span class="asDoc">/**
         * This flag controls whether to show the history nodes or not.
         * */</span>
        <span class="asReserved">private</span> <span class="asVar">var</span> _showCurrentNodeHistory<span class="asOperator">:</span>Boolean <span class="asOperator">=</span> <span class="asReserved">false</span>;


        <span class="asComment">/* public attributes */</span>

        <span class="asDoc">/**
         * Default visibility setting for new nodes. If
         * set all new nodes are created visible and with
         * a view component. Beware of that if you have
         * many nodes.
         * */</span>
        <span class="asReserved">public</span> <span class="asVar">var</span> newNodesDefaultVisible<span class="asOperator">:</span>Boolean <span class="asOperator">=</span> <span class="asReserved">false</span>;

        <span class="asDoc">/**
         * This property controls whether the mouse cursor
         * should be locked in the dragged node&apos;s center or not.
         * */</span>
        <span class="asReserved">public</span> <span class="asVar">var</span> dragLockCenter<span class="asOperator">:</span>Boolean <span class="asOperator">=</span> <span class="asReserved">false</span>;

        <span class="asDoc">/**
         * If set, this effect will be applied if a view
         * is created (e.g. while a node becomes visible
         * or if a new node is created).
         * */</span>
        <span class="asReserved">public</span> <span class="asVar">var</span> addItemEffect<span class="asOperator">:</span>Effect;
        
        <span class="asDoc">/**
         * If set, this effect will be applied if a view
         * is removed (e.g. a node becomes invisible or
         * is removed).
         * */</span>
        <span class="asReserved">public</span> <span class="asVar">var</span> removeItemEffect<span class="asOperator">:</span>Effect;

        <span class="asComment">/* for debugging purposes we need a component counter */</span>
        <span class="asReserved">private</span> <span class="asVar">var</span> _componentCounter<span class="asOperator">:</span>int <span class="asOperator">=</span> 0;

        <span class="asDoc">/**
         * The constructor just initialises most data structures, but not all
         * required. Currently it does neither set a Graph object, nor a 
         * Layouter object. Reasonable defaults may be added as an option.
         * */</span>
        <span class="asReserved">public</span> <span class="asFunction">function</span> VisualGraph<span class="asBracket">()</span><span class="asOperator">:</span><span class="asReserved">void</span> <span class="asBracket">{</span>
            
            <span class="asComment">/* call super class constructor */</span>
            <span class="asReserved">super</span><span class="asBracket">()</span>;
            
            <span class="asComment">/* initialise the global edge settings */</span>
            _globalEdgeSettings <span class="asOperator">=</span> <span class="asReserved">new</span> Object;
            _globalEdgeSettings.thickness <span class="asOperator">=</span> 1;
            _globalEdgeSettings.alpha <span class="asOperator">=</span> 1.0;
            _globalEdgeSettings.color <span class="asOperator">=</span> 0xcccccc; <span class="asComment">//
</span>            _globalEdgeSettings.distcolor <span class="asOperator">=</span> 0xff0000; <span class="asComment">// ?? red maybe
</span>            
            <span class="asComment">/* initialize maps for drag and drop */</span>
            _drag_x_offsetMap <span class="asOperator">=</span> <span class="asReserved">new</span> Dictionary;
            _drag_y_offsetMap <span class="asOperator">=</span> <span class="asReserved">new</span> Dictionary;
            _drag_boundsMap <span class="asOperator">=</span> <span class="asReserved">new</span> Dictionary;
            
            
            <span class="asComment">/* set an edge renderer, for now we use the Default,
             * but at a later stage this could be set externally */</span>
            _edgeRenderer <span class="asOperator">=</span> <span class="asReserved">new</span> DefaultEdgeRenderer<span class="asBracket">()</span>;
            
            <span class="asComment">/* initialise view/ItemRenderer and visibility mapping */</span>
            _viewToVNodeMap <span class="asOperator">=</span> <span class="asReserved">new</span> Dictionary;
            _visibleVNodes <span class="asOperator">=</span> <span class="asReserved">new</span> Dictionary;
            _visibleEdges <span class="asOperator">=</span> <span class="asReserved">new</span> Dictionary;
            _noVisibleVNodes <span class="asOperator">=</span> 0;
            _visibilityLimitActive <span class="asOperator">=</span> <span class="asReserved">true</span>;
            
            <span class="asComment">/* init the history array */</span>
            _currentVNodeHistory <span class="asOperator">=</span> <span class="asReserved">new</span> Array;
            
            <span class="asComment">/* set the drawing surface for the edges */</span>
            _drawingSurface <span class="asOperator">=</span> <span class="asReserved">new</span> UIComponent<span class="asBracket">()</span>;
            
            <span class="asComment">/* initialize the canvas, we are our own canvas obviously */</span>
            _canvas <span class="asOperator">=</span> <span class="asReserved">this</span>;
            _canvas.addChild<span class="asBracket">(</span>_drawingSurface<span class="asBracket">)</span>;
            
            <span class="asComment">/* disable scrollbars */</span>
            _canvas.verticalScrollPolicy <span class="asOperator">=</span> <span class="asString">&quot;off&quot;</span>;
            _canvas.horizontalScrollPolicy <span class="asOperator">=</span> <span class="asString">&quot;off&quot;</span>;
            
            <span class="asComment">/* add event handlers for background drag/drop i.e. scrolling */</span>
            _canvas.addEventListener<span class="asBracket">(</span>MouseEvent.MOUSE_DOWN,backgroundDragBegin<span class="asBracket">)</span>;
            _canvas.addEventListener<span class="asBracket">(</span>MouseEvent.MOUSE_UP,dragEnd<span class="asBracket">)</span>;
            
            _origin <span class="asOperator">=</span> <span class="asReserved">new</span> Point<span class="asBracket">(</span>0,0<span class="asBracket">)</span>;
        <span class="asBracket">}</span>
        
        <span class="asDoc">/**
         * This property allows access and setting of the underlying
         * graph object. If set, it will automatically initialise the VGraph
         * from the Graph object, i.e. create VNodes and VEdges for each
         * Graph node and Graph edge.
         * If there was already a Graph present, the VGraph is purged, but no other
         * cleanup is done, which means that there could still be
         * some references floating around thus leaking memory.
         * For now, avoid setting it more than once in the same
         * VGraph.
         * @param g The Graph object to be assigned.
         * */</span>
        <span class="asReserved">public</span> <span class="asFunction">function</span> <span class="asReserved">set</span> graph<span class="asBracket">(</span>g<span class="asOperator">:</span>IGraph<span class="asBracket">)</span><span class="asOperator">:</span><span class="asReserved">void</span> <span class="asBracket">{</span>
            
            <span class="asReserved">if</span><span class="asBracket">(</span>_graph <span class="asOperator">!=</span> <span class="asReserved">null</span><span class="asBracket">)</span> <span class="asBracket">{</span>
                <span class="asTrace">trace</span><span class="asBracket">(</span><span class="asString">&quot;WARNING: _graph in VisualGraph was not null when new graph was assigned.&quot;</span><span class="asOperator">+</span>
                    <span class="asString">&quot; Some cleanup done, but this may leak memory&quot;</span><span class="asBracket">)</span>;
                <span class="asComment">/* this cleanes the VGraph so we are pristine */</span>
                purgeVGraph<span class="asBracket">()</span>;
            <span class="asBracket">}</span>
            
            <span class="asComment">/* assign defaults */</span>
            _graph <span class="asOperator">=</span> g;
            <span class="asComment">/* better safe than sorry even if it is an empty one */</span>
            initFromGraph<span class="asBracket">()</span>;
        <span class="asBracket">}</span>

        <span class="asDoc">/**
         * @private
         * */</span>
        <span class="asReserved">public</span> <span class="asFunction">function</span> <span class="asReserved">get</span> graph<span class="asBracket">()</span><span class="asOperator">:</span>IGraph <span class="asBracket">{</span>
            <span class="asReserved">return</span> _graph;
        <span class="asBracket">}</span>
            
        
        <span class="asDoc">/**
         * @inheritDoc
         * */</span>
        <span class="asReserved">public</span> <span class="asFunction">function</span> <span class="asReserved">get</span> globalEdgeSettings<span class="asBracket">()</span><span class="asOperator">:</span>Object <span class="asBracket">{</span>
            <span class="asReserved">return</span> _globalEdgeSettings; <span class="asComment">// shouldn&apos;t we rather pass a copy XXX
</span>        <span class="asBracket">}</span>
        
        <span class="asDoc">/**
         * @private
         * */</span>        
        <span class="asReserved">public</span> <span class="asFunction">function</span> <span class="asReserved">set</span> globalEdgeSettings<span class="asBracket">(</span>s<span class="asOperator">:</span>Object<span class="asBracket">)</span><span class="asOperator">:</span><span class="asReserved">void</span> <span class="asBracket">{</span>
            _globalEdgeSettings <span class="asOperator">=</span> s;
        <span class="asBracket">}</span>

        <span class="asDoc">/**
         * @inheritDoc
         * */</span>
        <span class="asReserved">public</span> <span class="asFunction">function</span> <span class="asReserved">set</span> itemRenderer<span class="asBracket">(</span>ifac<span class="asOperator">:</span>IFactory<span class="asBracket">)</span><span class="asOperator">:</span><span class="asReserved">void</span> <span class="asBracket">{</span>
            _itemRendererFactory <span class="asOperator">=</span> ifac;
        <span class="asBracket">}</span>

        <span class="asDoc">/**
         * @inheritDoc
         * */</span>
        <span class="asReserved">public</span> <span class="asFunction">function</span> <span class="asReserved">get</span> layouter<span class="asBracket">()</span><span class="asOperator">:</span>ILayoutAlgorithm <span class="asBracket">{</span>
            <span class="asReserved">return</span> _layouter;
        <span class="asBracket">}</span>
    
        <span class="asDoc">/**
         * @private
         * */</span>
        <span class="asReserved">public</span> <span class="asFunction">function</span> <span class="asReserved">set</span> layouter<span class="asBracket">(</span>l<span class="asOperator">:</span>ILayoutAlgorithm<span class="asBracket">)</span><span class="asOperator">:</span><span class="asReserved">void</span> <span class="asBracket">{</span>
            _layouter <span class="asOperator">=</span> l;
        <span class="asBracket">}</span>

        <span class="asDoc">/**
         * @inheritDoc
         * */</span>
        <span class="asReserved">public</span> <span class="asFunction">function</span> <span class="asReserved">get</span> origin<span class="asBracket">()</span><span class="asOperator">:</span>Point <span class="asBracket">{</span>
            <span class="asReserved">return</span> _origin;
        <span class="asBracket">}</span>
        
        <span class="asDoc">/**
         * @inheritDoc
         * */</span>
        <span class="asReserved">public</span> <span class="asFunction">function</span> <span class="asReserved">get</span> center<span class="asBracket">()</span><span class="asOperator">:</span>Point <span class="asBracket">{</span>
            <span class="asReserved">return</span> <span class="asReserved">new</span> Point<span class="asBracket">(</span>_canvas.width <span class="asOperator">/</span> 2.0, _canvas.height <span class="asOperator">/</span> 2.0<span class="asBracket">)</span>;
        <span class="asBracket">}</span>

        <span class="asDoc">/**
         * @inheritDoc
         * */</span>
        <span class="asReserved">public</span> <span class="asFunction">function</span> <span class="asReserved">get</span> visibleVNodes<span class="asBracket">()</span><span class="asOperator">:</span>Dictionary <span class="asBracket">{</span>
            <span class="asReserved">return</span> _visibleVNodes;
        <span class="asBracket">}</span>

        <span class="asDoc">/**
         * @inheritDoc
         * */</span>
        <span class="asReserved">public</span> <span class="asFunction">function</span> <span class="asReserved">get</span> noVisibleVNodes<span class="asBracket">()</span><span class="asOperator">:</span>uint <span class="asBracket">{</span>
            <span class="asReserved">return</span> _noVisibleVNodes;
        <span class="asBracket">}</span>

        <span class="asDoc">/**
         * @inheritDoc
         * */</span>
        <span class="asReserved">public</span> <span class="asFunction">function</span> <span class="asReserved">get</span> visibleEdges<span class="asBracket">()</span><span class="asOperator">:</span>Dictionary <span class="asBracket">{</span>
            <span class="asReserved">return</span> _visibleEdges;
        <span class="asBracket">}</span>
        
        <span class="asDoc">/**
         * @inheritDoc
         * */</span>
        <span class="asBracket">[</span><span class="asMetadata">Bindable</span><span class="asBracket">]</span>
        <span class="asReserved">public</span> <span class="asFunction">function</span> <span class="asReserved">get</span> visibilityLimitActive<span class="asBracket">()</span><span class="asOperator">:</span>Boolean <span class="asBracket">{</span>
            <span class="asReserved">return</span> _visibilityLimitActive;
        <span class="asBracket">}</span>
        <span class="asDoc">/**
         * @private
         * */</span>
        <span class="asReserved">public</span> <span class="asFunction">function</span> <span class="asReserved">set</span> visibilityLimitActive<span class="asBracket">(</span>ac<span class="asOperator">:</span>Boolean<span class="asBracket">)</span><span class="asOperator">:</span><span class="asReserved">void</span> <span class="asBracket">{</span>
            <span class="asComment">/* check for a change */</span>
            <span class="asReserved">if</span><span class="asBracket">(</span>_visibilityLimitActive <span class="asOperator">!=</span> ac<span class="asBracket">)</span> <span class="asBracket">{</span>    
                <span class="asComment">/* execute the change */</span>
                _visibilityLimitActive <span class="asOperator">=</span> ac;
                <span class="asComment">/* activate? */</span>
                <span class="asReserved">if</span><span class="asBracket">(</span>ac<span class="asBracket">)</span> <span class="asBracket">{</span>
                    <span class="asReserved">if</span><span class="asBracket">(</span>_currentRootVNode <span class="asOperator">==</span> <span class="asReserved">null</span><span class="asBracket">)</span> <span class="asBracket">{</span>
                        <span class="asTrace">trace</span><span class="asBracket">(</span><span class="asString">&quot;No root selected, not creating limited graph, not doing anything.&quot;</span><span class="asBracket">)</span>;
                        <span class="asReserved">return</span>;
                    <span class="asBracket">}</span>
                    <span class="asComment">//trace(&quot;getting limited node ids with limit:&quot;+_maxVisibleDistance);
</span>                    
                    <span class="asComment">/* 1. Get the spanning tree, rooted in our current root node from
                     *    the graph object.
                     * 2. Get the hash from this tree, that contains only the nodes
                     *    within the set distance.
                     * 3. Use this to set our properties for the nodes within the distance
                     *    limit.
                     */</span>
                    setDistanceLimitedNodeIds<span class="asBracket">(</span>_graph.getTree<span class="asBracket">(</span>_currentRootVNode.node<span class="asBracket">)</span>.
                        getLimitedNodes<span class="asBracket">(</span>_maxVisibleDistance<span class="asBracket">))</span>;
                    
                    <span class="asComment">/* now update all other visibility data structure
                     * this also forces a redraw() (and layout) of the 
                     * visualisation */</span>
                    updateVisibility<span class="asBracket">()</span>;
                <span class="asBracket">}</span>
                <span class="asComment">/* when we deactivate this limit, we render all nodes
                 * visible! */</span>
                <span class="asReserved">else</span> <span class="asBracket">{</span>
                    setAllVisible<span class="asBracket">()</span>;
                <span class="asBracket">}</span>
            <span class="asBracket">}</span>
        <span class="asBracket">}</span>
        

        <span class="asDoc">/**
         * @inheritDoc
         * */</span>
        <span class="asBracket">[</span><span class="asMetadata">Bindable</span><span class="asBracket">]</span>
        <span class="asReserved">public</span> <span class="asFunction">function</span> <span class="asReserved">get</span> maxVisibleDistance<span class="asBracket">()</span><span class="asOperator">:</span>int <span class="asBracket">{</span>
            <span class="asReserved">return</span> _maxVisibleDistance;
        <span class="asBracket">}</span>
        
        <span class="asDoc">/**
         * @private
         * */</span>
        <span class="asReserved">public</span> <span class="asFunction">function</span> <span class="asReserved">set</span> maxVisibleDistance<span class="asBracket">(</span>md<span class="asOperator">:</span>int<span class="asBracket">)</span><span class="asOperator">:</span><span class="asReserved">void</span> <span class="asBracket">{</span>
            <span class="asComment">/* check if there was a change */</span>
            <span class="asReserved">if</span><span class="asBracket">(</span>_maxVisibleDistance <span class="asOperator">!=</span> md<span class="asBracket">)</span> <span class="asBracket">{</span>
                <span class="asComment">/* if yes, apply the change */</span>
                _maxVisibleDistance <span class="asOperator">=</span> md;
                <span class="asComment">//trace(&quot;visible distance changed to: &quot;+md);
</span>                
                <span class="asComment">/* if our current limits are active we create a new
                 * set of nodes within the distance and update the
                 * visibility */</span>
                <span class="asReserved">if</span><span class="asBracket">(</span>_visibilityLimitActive<span class="asBracket">)</span> <span class="asBracket">{</span>
                    <span class="asReserved">if</span><span class="asBracket">(</span>_currentRootVNode <span class="asOperator">==</span> <span class="asReserved">null</span><span class="asBracket">)</span> <span class="asBracket">{</span>
                        <span class="asTrace">trace</span><span class="asBracket">(</span><span class="asString">&quot;No root selected, not creating limited graph&quot;</span><span class="asBracket">)</span>;
                        <span class="asReserved">return</span>;
                    <span class="asBracket">}</span> <span class="asReserved">else</span> <span class="asBracket">{</span>
                        setDistanceLimitedNodeIds<span class="asBracket">(</span>_graph.getTree<span class="asBracket">(</span>_currentRootVNode.node<span class="asBracket">)</span>.
                            getLimitedNodes<span class="asBracket">(</span>_maxVisibleDistance<span class="asBracket">))</span>;
                        updateVisibility<span class="asBracket">()</span>;
                    <span class="asBracket">}</span>
                <span class="asBracket">}</span>
            <span class="asBracket">}</span>
        <span class="asBracket">}</span>
        
        
        <span class="asDoc">/**
         * This was added for testing. It may be removed
         * again.
         * */</span>
        <span class="asReserved">public</span> <span class="asFunction">function</span> <span class="asReserved">get</span> currentRootSID<span class="asBracket">()</span><span class="asOperator">:</span>String <span class="asBracket">{</span>
            <span class="asReserved">return</span> _currentRootVNode.node.stringid;
        <span class="asBracket">}</span>
        
        <span class="asDoc">/**
         * @inheritDoc
         * */</span>
        <span class="asBracket">[</span><span class="asMetadata">Bindable</span><span class="asBracket">]</span>
        <span class="asReserved">public</span> <span class="asFunction">function</span> <span class="asReserved">get</span> currentRootVNode<span class="asBracket">()</span><span class="asOperator">:</span>IVisualNode <span class="asBracket">{</span>
            <span class="asReserved">return</span> _currentRootVNode;
        <span class="asBracket">}</span>
        <span class="asDoc">/**
         * @private
         * */</span>
        <span class="asReserved">public</span> <span class="asFunction">function</span> <span class="asReserved">set</span> currentRootVNode<span class="asBracket">(</span>vn<span class="asOperator">:</span>IVisualNode<span class="asBracket">)</span><span class="asOperator">:</span><span class="asReserved">void</span> <span class="asBracket">{</span>
            <span class="asComment">/* check for a change */</span>
            <span class="asReserved">if</span><span class="asBracket">(</span>_currentRootVNode <span class="asOperator">!=</span> vn<span class="asBracket">)</span> <span class="asBracket">{</span>
                
                <span class="asComment">/* apply the change */</span>
                _currentRootVNode <span class="asOperator">=</span> vn;

                <span class="asComment">/* now update the history with the new node */</span>
                _currentVNodeHistory.unshift<span class="asBracket">(</span>_currentRootVNode<span class="asBracket">)</span>;
                
                <span class="asComment">//trace(&quot;node:&quot;+_currentRootVNode.id+&quot; added to history&quot;);
</span>                
                <span class="asComment">/* if we are currently limiting node visibility,
                 * update the set of visible nodes since we 
                 * have changed the root, the spanning tree has changed
                 * and thus the set of visible nodes */</span>
                <span class="asReserved">if</span><span class="asBracket">(</span>_visibilityLimitActive<span class="asBracket">)</span> <span class="asBracket">{</span>
                    setDistanceLimitedNodeIds<span class="asBracket">(</span>_graph.getTree<span class="asBracket">(</span>_currentRootVNode.node<span class="asBracket">)</span>.
                        getLimitedNodes<span class="asBracket">(</span>_maxVisibleDistance<span class="asBracket">))</span>;
                    updateVisibility<span class="asBracket">()</span>;
                <span class="asBracket">}</span> <span class="asReserved">else</span> <span class="asBracket">{</span>
                    <span class="asComment">/* if we do not limit visibility, we still need
                     * to force a new layout and redraw()
                     * (in the other case, this is done by updateVisibility()) */</span>
                    draw<span class="asBracket">()</span>;
                <span class="asBracket">}</span>
            <span class="asBracket">}</span>
        <span class="asBracket">}</span>        

        <span class="asDoc">/**
         * @inheritDoc
         * */</span>
        <span class="asReserved">public</span> <span class="asFunction">function</span> <span class="asReserved">get</span> showHistory<span class="asBracket">()</span><span class="asOperator">:</span>Boolean <span class="asBracket">{</span>
            <span class="asReserved">return</span> _showCurrentNodeHistory;
        <span class="asBracket">}</span>

        <span class="asDoc">/**
         * @private
         * */</span>
        <span class="asReserved">public</span> <span class="asFunction">function</span> <span class="asReserved">set</span> showHistory<span class="asBracket">(</span>h<span class="asOperator">:</span>Boolean<span class="asBracket">)</span><span class="asOperator">:</span><span class="asReserved">void</span> <span class="asBracket">{</span>
            <span class="asComment">/* check for a change */</span>
            <span class="asReserved">if</span><span class="asBracket">(</span>_showCurrentNodeHistory <span class="asOperator">!=</span> h<span class="asBracket">)</span> <span class="asBracket">{</span>
                _showCurrentNodeHistory <span class="asOperator">=</span> h;
            
                <span class="asComment">/* makes no sense without root set */</span>
                <span class="asReserved">if</span><span class="asBracket">(</span>_currentRootVNode <span class="asOperator">!=</span> <span class="asReserved">null</span><span class="asBracket">)</span> <span class="asBracket">{</span>
                    <span class="asComment">/* becomes only active if we have the limit active */</span>
                    <span class="asReserved">if</span><span class="asBracket">(</span>_visibilityLimitActive<span class="asBracket">)</span> <span class="asBracket">{</span>
                        <span class="asComment">/* now update the visibility. This also applies the
                         * history information to the node visibility */</span>
                        updateVisibility<span class="asBracket">()</span>;
                    <span class="asBracket">}</span>
                <span class="asBracket">}</span>
            <span class="asBracket">}</span>
        <span class="asBracket">}</span>

        <span class="asDoc">/**
         * @inheritDoc
         * */</span>
        <span class="asReserved">public</span> <span class="asFunction">function</span> <span class="asReserved">set</span> lineColor<span class="asBracket">(</span>color<span class="asOperator">:</span>int<span class="asBracket">)</span><span class="asOperator">:</span><span class="asReserved">void</span> <span class="asBracket">{</span>
            _globalEdgeSettings.color <span class="asOperator">=</span> color;
            refresh<span class="asBracket">()</span>;
        <span class="asBracket">}</span>

        <span class="asDoc">/**
         * This initialises a VGraph from a Graph object.
         * I.e. it crates a VNode for every Node found in
         * the Graph and a VEdge for every Edge in the Graph.
         * Careful, this currently does not check if the VGraph
         * was already initialised and it does not purge anything.
         * Things could break of used on an already initialized VGraph.
         * */</span>
        <span class="asReserved">public</span> <span class="asFunction">function</span> initFromGraph<span class="asBracket">()</span><span class="asOperator">:</span><span class="asReserved">void</span> <span class="asBracket">{</span>
            
            <span class="asVar">var</span> node<span class="asOperator">:</span>INode;
            <span class="asVar">var</span> edge<span class="asOperator">:</span>IEdge;
            
            <span class="asComment">/* create the vnode from the node */</span>
            <span class="asReserved">for</span> <span class="asReserved">each</span><span class="asBracket">(</span>node <span class="asReserved">in</span> _graph.nodes<span class="asBracket">)</span> <span class="asBracket">{</span>
                <span class="asReserved">this</span>.createVNode<span class="asBracket">(</span>node<span class="asBracket">)</span>;
            <span class="asBracket">}</span>
            
            <span class="asComment">/* we also create the edge objects, since they
             * may carry additional label information or something
             * like that, but they do not have a view */</span>
            <span class="asReserved">for</span> <span class="asReserved">each</span><span class="asBracket">(</span>edge <span class="asReserved">in</span> _graph.edges<span class="asBracket">)</span> <span class="asBracket">{</span>
                <span class="asReserved">this</span>.createVEdge<span class="asBracket">(</span>edge<span class="asBracket">)</span>;
            <span class="asBracket">}</span>
        <span class="asBracket">}</span>
        
        <span class="asDoc">/**
         * @inheritDoc
         * */</span>
        <span class="asReserved">public</span> <span class="asFunction">function</span> clearHistory<span class="asBracket">()</span><span class="asOperator">:</span><span class="asReserved">void</span> <span class="asBracket">{</span>
            _currentVNodeHistory <span class="asOperator">=</span> <span class="asReserved">new</span> Array<span class="asBracket">()</span>;
        <span class="asBracket">}</span>



        <span class="asDoc">/**
         * @inheritDoc
         * */</span>
        <span class="asReserved">public</span> <span class="asFunction">function</span> calcNodesBoundingBox<span class="asBracket">()</span><span class="asOperator">:</span>Rectangle <span class="asBracket">{</span>
            
            <span class="asVar">var</span> children<span class="asOperator">:</span>Array;
            <span class="asVar">var</span> result<span class="asOperator">:</span>Rectangle;
            
            <span class="asComment">/* get all children of our canvas, these should only
             * be node views and the edge drawing surface. */</span>
            children <span class="asOperator">=</span> _canvas.getChildren<span class="asBracket">()</span>;
            
            <span class="asComment">/* init the rectangle with some large values. 
             * Originally I wanted to use Number.MAX_VALUE / Number.MIN_VALUE but
             * ran into serious numerical problems, thus 
             * we use +/- 999999 for now, although this is 
             * more like a hack.
             * Note that the coordinates are reversed, i.e. the origin of the rectangle
             * has been pushed to the far bottom right, and the height and width
             * are negative */</span>
            result <span class="asOperator">=</span> <span class="asReserved">new</span> Rectangle<span class="asBracket">(</span>999999, 999999, <span class="asOperator">-</span>999999, <span class="asOperator">-</span>999999<span class="asBracket">)</span>;

            <span class="asComment">//trace(&quot;THIS CANVAS currently HAS:&quot;+children.length+&quot; children!!&quot;);
</span>
            <span class="asComment">/* if there are no children at all, there may be something
             * wrong as it should at least contain the drawing surface */</span>
            <span class="asReserved">if</span><span class="asBracket">(</span>children.length <span class="asOperator">==</span> 0<span class="asBracket">)</span> <span class="asBracket">{</span>
                <span class="asTrace">trace</span><span class="asBracket">(</span><span class="asString">&quot;Canvas has no children, not even the drawing surface!&quot;</span><span class="asBracket">)</span>;
                <span class="asReserved">return</span> <span class="asReserved">null</span>;
            <span class="asBracket">}</span>
            
            <span class="asComment">/* The children should only be the visible node&apos;s views and
             * the drawing surface for the edges, so we
             * add a safeguard here to see of these are actually much more */</span>
            <span class="asReserved">if</span><span class="asBracket">(</span>children.length <span class="asOperator">&gt;</span> _noVisibleVNodes <span class="asOperator">+</span> 1<span class="asBracket">)</span> <span class="asBracket">{</span>
                <span class="asReserved">throw</span> Error<span class="asBracket">(</span><span class="asString">&quot;Children are more than visible nodes plus drawing surface&quot;</span><span class="asBracket">)</span>;
            <span class="asBracket">}</span>
            
            <span class="asComment">/* now walk through all children, which are UIComponents
             * and not our drawing surface and expand the result rectangle */</span>
            <span class="asReserved">for</span><span class="asBracket">(</span><span class="asVar">var</span> i<span class="asOperator">:</span>int <span class="asOperator">=</span> 0;i <span class="asOperator">&lt;</span> children.length; <span class="asOperator">++</span>i<span class="asBracket">)</span> <span class="asBracket">{</span>
                    
                <span class="asVar">var</span> view<span class="asOperator">:</span>UIComponent <span class="asOperator">=</span> <span class="asBracket">(</span>children<span class="asBracket">[</span>i<span class="asBracket">]</span> <span class="asReserved">as</span> UIComponent<span class="asBracket">)</span>;
                
                <span class="asComment">/* only consider currently visible views */</span>
                <span class="asReserved">if</span><span class="asBracket">(</span>view.visible<span class="asBracket">)</span> <span class="asBracket">{</span>
                    <span class="asReserved">if</span><span class="asBracket">(</span>view <span class="asOperator">!=</span> _drawingSurface<span class="asBracket">)</span> <span class="asBracket">{</span>
                        result.left <span class="asOperator">=</span> Math.min<span class="asBracket">(</span>result.left, view.x<span class="asBracket">)</span>;
                        result.right <span class="asOperator">=</span> Math.max<span class="asBracket">(</span>result.right, view.x <span class="asOperator">+</span> view.width<span class="asBracket">)</span>;
                        result.top <span class="asOperator">=</span> Math.min<span class="asBracket">(</span>result.top, view.y<span class="asBracket">)</span>;
                        result.bottom <span class="asOperator">=</span> Math.max<span class="asBracket">(</span>result.bottom, view.y<span class="asOperator">+</span>view.height<span class="asBracket">)</span>;
                    <span class="asBracket">}</span> <span class="asReserved">else</span> <span class="asBracket">{</span>
                        <span class="asReserved">if</span><span class="asBracket">(</span>children.length <span class="asOperator">==</span> 1<span class="asBracket">)</span> <span class="asBracket">{</span>
                            <span class="asComment">/* only child is the drawing surface, we return an empty Rectangle
                             * anchored in the middle */</span>
                            <span class="asReserved">return</span> <span class="asReserved">new</span> Rectangle<span class="asBracket">(</span>_canvas.width <span class="asOperator">/</span> 2, _canvas.height <span class="asOperator">/</span> 2, 0, 0<span class="asBracket">)</span>;
                        <span class="asBracket">}</span>
                    <span class="asBracket">}</span>
                <span class="asBracket">}</span>
            <span class="asBracket">}</span>
            <span class="asReserved">return</span> result;
        <span class="asBracket">}</span>
        
        <span class="asDoc">/** 
         * @inheritDoc
         * */</span>
        <span class="asReserved">public</span> <span class="asFunction">function</span> createNode<span class="asBracket">(</span>sid<span class="asOperator">:</span>String <span class="asOperator">=</span> <span class="asString">&quot;&quot;</span>, o<span class="asOperator">:</span>Object <span class="asOperator">=</span> <span class="asReserved">null</span><span class="asBracket">)</span><span class="asOperator">:</span>IVisualNode <span class="asBracket">{</span>
            
            <span class="asVar">var</span> gnode<span class="asOperator">:</span>INode;
            <span class="asVar">var</span> vnode<span class="asOperator">:</span>IVisualNode;
            
            <span class="asComment">/* first add a new node to the underlying graph */</span>
            gnode <span class="asOperator">=</span> _graph.createNode<span class="asBracket">(</span>sid,o<span class="asBracket">)</span>;
            
            <span class="asComment">/* Then create the VNode with associated with the graph node */</span>
            vnode <span class="asOperator">=</span> createVNode<span class="asBracket">(</span>gnode<span class="asBracket">)</span>;
            
            <span class="asComment">/* since it is a requirement from most layouters
             * to always have a current root node
             * we assign the current root node to the newly
             * created node so we have one. Note that this does
             * not affect the root node history. */</span>
            _currentRootVNode <span class="asOperator">=</span> vnode;

            <span class="asReserved">return</span> vnode;
        <span class="asBracket">}</span>
    
        <span class="asDoc">/**
         * @inheritDoc
         * */</span>
        <span class="asReserved">public</span> <span class="asFunction">function</span> removeNode<span class="asBracket">(</span>vn<span class="asOperator">:</span>IVisualNode<span class="asBracket">)</span><span class="asOperator">:</span><span class="asReserved">void</span> <span class="asBracket">{</span>
            
            <span class="asVar">var</span> n<span class="asOperator">:</span>INode;
            <span class="asVar">var</span> iedges<span class="asOperator">:</span>Array;
            <span class="asVar">var</span> oedges<span class="asOperator">:</span>Array;
            <span class="asVar">var</span> e<span class="asOperator">:</span>IEdge;
            <span class="asVar">var</span> ve<span class="asOperator">:</span>IVisualEdge;
            <span class="asVar">var</span> i<span class="asOperator">:</span>int;
            
            n <span class="asOperator">=</span> vn.node;
            iedges <span class="asOperator">=</span> n.inEdges;
            oedges <span class="asOperator">=</span> n.outEdges;
            
            
            <span class="asComment">/* if the current root node is the
             * node to be removed it must be
             * changed.
             *
             * First, we set it to null, then we remove the
             * node, then at the end we reset it
             * to the first node still in the
             * nodes array */</span>
            <span class="asReserved">if</span><span class="asBracket">(</span>vn <span class="asOperator">==</span> _currentRootVNode<span class="asBracket">)</span> <span class="asBracket">{</span>
                <span class="asComment">/* temporary set to null */</span>
                _currentRootVNode <span class="asOperator">=</span> <span class="asReserved">null</span>;
            <span class="asBracket">}</span>
            
            <span class="asComment">/* remove all incoming edges */</span>
            <span class="asReserved">for</span><span class="asBracket">(</span>i<span class="asOperator">=</span>0; i <span class="asOperator">&lt;</span> iedges.length; <span class="asOperator">++</span>i<span class="asBracket">)</span> <span class="asBracket">{</span>
                e <span class="asOperator">=</span> iedges<span class="asBracket">[</span>i<span class="asBracket">]</span> <span class="asReserved">as</span> IEdge;
                ve <span class="asOperator">=</span> e.vedge;
                removeVEdge<span class="asBracket">(</span>ve<span class="asBracket">)</span>;
                _graph.removeEdge<span class="asBracket">(</span>e<span class="asBracket">)</span>;
            <span class="asBracket">}</span>
            
            <span class="asComment">/* remove all outgoing edges */</span>
            <span class="asReserved">for</span><span class="asBracket">(</span>i<span class="asOperator">=</span>0; i <span class="asOperator">&lt;</span> oedges.length; <span class="asOperator">++</span>i<span class="asBracket">)</span> <span class="asBracket">{</span>
                e <span class="asOperator">=</span> oedges<span class="asBracket">[</span>i<span class="asBracket">]</span> <span class="asReserved">as</span> IEdge;
                ve <span class="asOperator">=</span> e.vedge;
                removeVEdge<span class="asBracket">(</span>ve<span class="asBracket">)</span>;
                _graph.removeEdge<span class="asBracket">(</span>e<span class="asBracket">)</span>;
            <span class="asBracket">}</span>
            
            <span class="asComment">/* remove the vnode */</span>
            removeVNode<span class="asBracket">(</span>vn<span class="asBracket">)</span>;
            
            <span class="asComment">/* remove the node from the graph */</span>
            _graph.removeNode<span class="asBracket">(</span>n<span class="asBracket">)</span>;
            
            <span class="asComment">/* now set a new root node, implies that there is
             * still a node */</span>
            <span class="asReserved">if</span><span class="asBracket">(</span>_currentRootVNode <span class="asOperator">==</span> <span class="asReserved">null</span> <span class="asOperator">&amp;&amp;</span> _graph.noNodes <span class="asOperator">&gt;</span> 0<span class="asBracket">)</span> <span class="asBracket">{</span>
                _currentRootVNode <span class="asOperator">=</span> <span class="asBracket">(</span>_graph.nodes<span class="asBracket">[</span>0<span class="asBracket">]</span> <span class="asReserved">as</span> INode<span class="asBracket">)</span>.vnode;
            <span class="asBracket">}</span>
            
            <span class="asComment">/* since we removed also edges, we need a refresh */</span>
            refresh<span class="asBracket">()</span>;
        <span class="asBracket">}</span>
    
        
        <span class="asDoc">/** 
         * @inheritDoc
         * */</span>
        <span class="asReserved">public</span> <span class="asFunction">function</span> linkNodes<span class="asBracket">(</span>v1<span class="asOperator">:</span>IVisualNode, v2<span class="asOperator">:</span>IVisualNode<span class="asBracket">)</span><span class="asOperator">:</span>IVisualEdge <span class="asBracket">{</span>
            
            <span class="asVar">var</span> n1<span class="asOperator">:</span>INode;
            <span class="asVar">var</span> n2<span class="asOperator">:</span>INode;
            <span class="asVar">var</span> e<span class="asOperator">:</span>IEdge;
            <span class="asVar">var</span> ve<span class="asOperator">:</span>IVisualEdge;
            
            <span class="asComment">/* make sure both nodes do exist */</span>
            <span class="asReserved">if</span><span class="asBracket">(</span>v1 <span class="asOperator">==</span> <span class="asReserved">null</span> <span class="asOperator">||</span> v2 <span class="asOperator">==</span> <span class="asReserved">null</span><span class="asBracket">)</span> <span class="asBracket">{</span>
                <span class="asReserved">throw</span> Error<span class="asBracket">(</span><span class="asString">&quot;linkNodes: one of the nodes does not exist&quot;</span><span class="asBracket">)</span>;
                <span class="asComment">//return null;
</span>            <span class="asBracket">}</span>
            
            n1 <span class="asOperator">=</span> v1.node;
            n2 <span class="asOperator">=</span> v2.node;
            
            <span class="asComment">/* now first link the graph nodes and create the corresponding edge */</span>
            e <span class="asOperator">=</span> _graph.link<span class="asBracket">(</span>n1,n2,<span class="asReserved">null</span><span class="asBracket">)</span>;
            
            <span class="asComment">/* if the edge existed already, e is just the
             * already existing edge. But if it existed
             * previously it might already have a VEdge.
             * So we only create a new VEdge, if it did not exist
             * already. */</span>        
            <span class="asReserved">if</span><span class="asBracket">(</span>e <span class="asOperator">==</span> <span class="asReserved">null</span><span class="asBracket">)</span> <span class="asBracket">{</span>
                <span class="asReserved">throw</span> Error<span class="asBracket">(</span><span class="asString">&quot;Could not create or find Graph edge!!&quot;</span><span class="asBracket">)</span>;
            <span class="asBracket">}</span> <span class="asReserved">else</span> <span class="asBracket">{</span>
                <span class="asReserved">if</span><span class="asBracket">(</span>e.vedge <span class="asOperator">==</span> <span class="asReserved">null</span><span class="asBracket">)</span> <span class="asBracket">{</span>
                    <span class="asComment">/* we have a new edge, so we create a new VEdge */</span>
                    ve <span class="asOperator">=</span> createVEdge<span class="asBracket">(</span>e<span class="asBracket">)</span>;
                <span class="asBracket">}</span> <span class="asReserved">else</span> <span class="asBracket">{</span>
                    <span class="asComment">/* existing one, so we use the existing vedge */</span>
                    <span class="asTrace">trace</span><span class="asBracket">(</span><span class="asString">&quot;Edge already existed, returning existing vedge&quot;</span><span class="asBracket">)</span>;
                    ve <span class="asOperator">=</span> e.vedge;
                <span class="asBracket">}</span>
            <span class="asBracket">}</span>
    
            <span class="asComment">//trace(&quot;linkNodes, created edge &quot;+(e as Object).toString()+&quot; from nodes: &quot;+n1.id+&quot;, &quot;+n2.id);
</span>
            <span class="asComment">/* this changes the layout, so we have to do a full redraw */</span>
            draw<span class="asBracket">()</span>;
            <span class="asReserved">return</span> ve;
        <span class="asBracket">}</span>

        <span class="asDoc">/** 
         * @inheritDoc
         * */</span>
        <span class="asReserved">public</span> <span class="asFunction">function</span> unlinkNodes<span class="asBracket">(</span>v1<span class="asOperator">:</span>IVisualNode, v2<span class="asOperator">:</span>IVisualNode<span class="asBracket">)</span><span class="asOperator">:</span><span class="asReserved">void</span> <span class="asBracket">{</span>

            <span class="asVar">var</span> n1<span class="asOperator">:</span>INode;
            <span class="asVar">var</span> n2<span class="asOperator">:</span>INode;
            <span class="asVar">var</span> e<span class="asOperator">:</span>IEdge;
            <span class="asVar">var</span> ve<span class="asOperator">:</span>IVisualEdge;
            
            <span class="asComment">/* make sure both nodes exist */</span>
            <span class="asReserved">if</span><span class="asBracket">(</span>v1 <span class="asOperator">==</span> <span class="asReserved">null</span> <span class="asOperator">||</span> v2 <span class="asOperator">==</span> <span class="asReserved">null</span><span class="asBracket">)</span> <span class="asBracket">{</span>
                <span class="asReserved">throw</span> Error<span class="asBracket">(</span><span class="asString">&quot;unlink nodes: one of the nodes does not exist&quot;</span><span class="asBracket">)</span>;
                <span class="asReserved">return</span>;
            <span class="asBracket">}</span>
            
            n1 <span class="asOperator">=</span> v1.node;
            n2 <span class="asOperator">=</span> v2.node;
            
            <span class="asComment">/* find the graph edge */</span>
            e <span class="asOperator">=</span> _graph.getEdge<span class="asBracket">(</span>n1,n2<span class="asBracket">)</span>;
            
            <span class="asComment">/* if we do not get an edge, it may simply not exist */</span>
            <span class="asReserved">if</span><span class="asBracket">(</span>e <span class="asOperator">==</span> <span class="asReserved">null</span><span class="asBracket">)</span> <span class="asBracket">{</span>
                <span class="asTrace">trace</span><span class="asBracket">(</span><span class="asString">&quot;No edge found between: &quot;</span><span class="asOperator">+</span>n1.id<span class="asOperator">+</span><span class="asString">&quot; and &quot;</span><span class="asOperator">+</span>n2.id<span class="asBracket">)</span>;
                <span class="asReserved">return</span>;
            <span class="asBracket">}</span>
            
            <span class="asComment">/* now get and remove the VEdge first */</span>
            ve <span class="asOperator">=</span> e.vedge;            
            removeVEdge<span class="asBracket">(</span>ve<span class="asBracket">)</span>;
    
            <span class="asComment">/* now remove the edge itself, basically
             * unlinking the nodes */</span>
            _graph.removeEdge<span class="asBracket">(</span>e<span class="asBracket">)</span>;

            <span class="asComment">//trace(&quot;removed edge: &quot;+e.id+&quot; : &quot;+n1.id+&quot; and &quot;+n2.id);            
</span>            
            <span class="asComment">/* again a full redraw is required */</span>
            draw<span class="asBracket">()</span>;
        <span class="asBracket">}</span>


        <span class="asDoc">/**
         * @inheritDoc
         * */</span>
        <span class="asReserved">public</span> <span class="asFunction">function</span> scroll<span class="asBracket">(</span>deltaX<span class="asOperator">:</span>Number, deltaY<span class="asOperator">:</span>Number<span class="asBracket">)</span><span class="asOperator">:</span><span class="asReserved">void</span> <span class="asBracket">{</span>
            
            <span class="asVar">var</span> i<span class="asOperator">:</span>uint;
            <span class="asVar">var</span> children<span class="asOperator">:</span>Array;
            <span class="asVar">var</span> view<span class="asOperator">:</span>UIComponent;
            
            children <span class="asOperator">=</span> _canvas.getChildren<span class="asBracket">()</span>;
            
            <span class="asComment">/* we walk through all children of the canvas, which
             * are not the drawing surface and which are UIComponents
             * (they should be all node views) and move them according
             * to the scroll offset */</span>
            <span class="asComment">//for(i = 1;i &lt; children.length; ++i) {
</span>            <span class="asComment">//    var view:UIComponent = (children[i] as UIComponent);
</span>            <span class="asReserved">for</span> <span class="asReserved">each</span><span class="asBracket">(</span>view <span class="asReserved">in</span> children<span class="asBracket">)</span> <span class="asBracket">{</span>
                <span class="asReserved">if</span><span class="asBracket">(</span>view <span class="asOperator">!=</span> _drawingSurface<span class="asBracket">)</span> <span class="asBracket">{</span>
                    view.x <span class="asOperator">+=</span> deltaX;
                    view.y <span class="asOperator">+=</span> deltaY;
                <span class="asBracket">}</span>
            <span class="asBracket">}</span>
            
            <span class="asComment">/* adjust the current origin of the canvas
             * (not 100% sure if this is a good idea but seems
             * to work) XXX */</span>
            _origin.offset<span class="asBracket">(</span>deltaX,deltaY<span class="asBracket">)</span>;
            <span class="asComment">//trace(&quot;Setting new origin to:&quot;+_origin.toString());
</span>        <span class="asBracket">}</span>

        <span class="asDoc">/**
         * @inheritDoc
         * */</span>
        <span class="asReserved">public</span> <span class="asFunction">function</span> refresh<span class="asBracket">()</span><span class="asOperator">:</span><span class="asReserved">void</span> <span class="asBracket">{</span>
            <span class="asComment">/* this forces the next call of updateDisplayList()
             * to redraw all edges */</span>
            <span class="asReserved">if</span><span class="asBracket">(</span>_layouter<span class="asBracket">)</span> <span class="asBracket">{</span>
                _layouter.layoutChanged <span class="asOperator">=</span> <span class="asReserved">true</span>;
            <span class="asBracket">}</span>
            _canvas.invalidateDisplayList<span class="asBracket">()</span>;
        <span class="asBracket">}</span>

        <span class="asDoc">/**
         * @inheritDoc
         * */</span>
        <span class="asReserved">public</span> <span class="asFunction">function</span> draw<span class="asBracket">()</span><span class="asOperator">:</span><span class="asReserved">void</span> <span class="asBracket">{</span>    
            
            <span class="asComment">/* first refresh does layoutChanges to true and
             * invalidate display list */</span>
            refresh<span class="asBracket">()</span>;
            
            <span class="asComment">/* then force a layout pass in the layouter */</span>
            <span class="asReserved">if</span><span class="asBracket">(</span>_layouter<span class="asBracket">)</span> <span class="asBracket">{</span>
                _layouter.layoutPass<span class="asBracket">()</span>;
            <span class="asBracket">}</span>
            
            <span class="asComment">/* after the layout was passed, the layout has
             * probably changed again, the layouter will have
             * itself set to that, but has maybe not
             * invalidated the display list, so we make sure it
             * happens here (may not always be necessary) */</span>
            _canvas.invalidateDisplayList<span class="asBracket">()</span>;
            
            <span class="asComment">/* dispatch this change event, so some UI items
             * in the application can poll for updated values
             * for labels or something.
             * XXX To do: define a proper event for this or
             * use an appropriate event from the canvas.
             */</span>
            dispatchEvent<span class="asBracket">(</span><span class="asReserved">new</span> Event<span class="asBracket">(</span><span class="asString">&quot;vgraphChanged&quot;</span><span class="asBracket">))</span>;
        <span class="asBracket">}</span>


        <span class="asDoc">/**
         * This calls the base updateDisplayList() method of the
         * Canvas and in addition redraws all edges if the layouter
         * indicates that the layout has changed.
         * 
         * @inheritDoc
         * */</span>
        <span class="asReserved">override</span> <span class="asReserved">protected</span> <span class="asFunction">function</span> updateDisplayList<span class="asBracket">(</span>unscaledWidth<span class="asOperator">:</span>Number, unscaledHeight<span class="asOperator">:</span>Number<span class="asBracket">)</span><span class="asOperator">:</span><span class="asReserved">void</span> <span class="asBracket">{</span>
            <span class="asComment">/* call the original function */</span>
            <span class="asReserved">super</span>.updateDisplayList<span class="asBracket">(</span>unscaledWidth,unscaledHeight<span class="asBracket">)</span>;
            
            <span class="asComment">/* now add our part */</span>
            <span class="asReserved">if</span><span class="asBracket">(</span>_layouter <span class="asOperator">&amp;&amp;</span> _layouter.layoutChanged<span class="asBracket">)</span> <span class="asBracket">{</span>
                redrawEdges<span class="asBracket">()</span>;
                <span class="asComment">/* reset the flag */</span>
                _layouter.layoutChanged <span class="asOperator">=</span> <span class="asReserved">false</span>;
            <span class="asBracket">}</span>
        <span class="asBracket">}</span>

        <span class="asComment">/* private methods */</span>

        <span class="asDoc">/**
         * Creates VNode and requires a Graph node to associate
         * it with. Originally also created the view, but we no
         * longer do that directly but only on demand.
         * @param n The graph node to be associated with.
         * @return The created VisualNode.
         * */</span>
        <span class="asReserved">private</span> <span class="asFunction">function</span> createVNode<span class="asBracket">(</span>n<span class="asOperator">:</span>INode<span class="asBracket">)</span><span class="asOperator">:</span>IVisualNode <span class="asBracket">{</span>
            
            <span class="asVar">var</span> vnode<span class="asOperator">:</span>IVisualNode;
            
            <span class="asComment">/* as an id we use the id of the graph node for simplicity
             * for now, it is not really used separately anywhere
             * we also use the graph data object as our data object.
             * the view is set to null and remains so. */</span>
            vnode <span class="asOperator">=</span> <span class="asReserved">new</span> VisualNode<span class="asBracket">(</span><span class="asReserved">this</span>, n, n.id, <span class="asReserved">null</span>, n.data<span class="asBracket">)</span>;
            
            <span class="asComment">/* if the node should be visible by default 
             * we need to make sure that the view is created */</span>
            <span class="asReserved">if</span><span class="asBracket">(</span>newNodesDefaultVisible<span class="asBracket">)</span> <span class="asBracket">{</span>
                setNodeVisibility<span class="asBracket">(</span>vnode, <span class="asReserved">true</span><span class="asBracket">)</span>;
            <span class="asBracket">}</span>

            <span class="asComment">/* now set the vnode in the node */</span>
            n.vnode <span class="asOperator">=</span> vnode;
            
            <span class="asReserved">return</span> vnode;
        <span class="asBracket">}</span>

        <span class="asDoc">/**
         * Removes a VNode, this also removes the node&apos;s view
         * if it existed, but does not touch the Graph node.
         * @param vn The VisualNode to be removed.
         * */</span>
        <span class="asReserved">private</span> <span class="asFunction">function</span> removeVNode<span class="asBracket">(</span>vn<span class="asOperator">:</span>IVisualNode<span class="asBracket">)</span><span class="asOperator">:</span><span class="asReserved">void</span> <span class="asBracket">{</span>
            
            <span class="asVar">var</span> view<span class="asOperator">:</span>UIComponent;
            
            <span class="asComment">/* get access to the node&apos;s view, but get the 
             * raw view to avoid unnecessary creation of a view
             */</span>
            view <span class="asOperator">=</span> vn.rawview;
            
            <span class="asComment">/* delete reference to the view from the node */</span>
            vn.view <span class="asOperator">=</span> <span class="asReserved">null</span>;
            
            <span class="asComment">/* remove the reference to this node from the graph node */</span>
            vn.node.vnode <span class="asOperator">=</span> <span class="asReserved">null</span>;
            
            <span class="asComment">/* now remove the view component if it existed */</span>
            <span class="asReserved">if</span><span class="asBracket">(</span>view <span class="asOperator">!=</span> <span class="asReserved">null</span><span class="asBracket">)</span> <span class="asBracket">{</span>
                removeComponent<span class="asBracket">(</span>view<span class="asBracket">)</span>;
            <span class="asBracket">}</span>
            
            <span class="asComment">/* remove from the visible vnode map if present */</span>
            <span class="asReserved">delete</span> _visibleVNodes<span class="asBracket">[</span>vn<span class="asBracket">]</span>;
            <span class="asOperator">--</span>_noVisibleVNodes;
            
            <span class="asComment">/* this should clean up all references to this VNode
             * thus freeing it for garbage collection */</span>
        <span class="asBracket">}</span>


        <span class="asDoc">/**
         * Creates a VEdge from a graph Edge.
         * @param e The Graph Edge.
         * @return The created VEdge.
         * */</span>
        <span class="asReserved">private</span> <span class="asFunction">function</span> createVEdge<span class="asBracket">(</span>e<span class="asOperator">:</span>IEdge<span class="asBracket">)</span><span class="asOperator">:</span>IVisualEdge <span class="asBracket">{</span>
            
            <span class="asVar">var</span> vedge<span class="asOperator">:</span>IVisualEdge;
            <span class="asVar">var</span> n1<span class="asOperator">:</span>INode;
            <span class="asVar">var</span> n2<span class="asOperator">:</span>INode;
            
            vedge <span class="asOperator">=</span> <span class="asReserved">new</span> VisualEdge<span class="asBracket">(</span><span class="asReserved">this</span>, e, e.id<span class="asBracket">)</span>;
            
            <span class="asComment">/* set the VisualEdge reference in the graph edge */</span>
            e.vedge <span class="asOperator">=</span> vedge;
            
            <span class="asComment">/* check if the edge is supposed to be visible */</span>
            n1 <span class="asOperator">=</span> e.node1;
            n2 <span class="asOperator">=</span> e.node2;
            
            <span class="asReserved">if</span><span class="asBracket">(</span>n1.vnode.isVisible <span class="asOperator">&amp;&amp;</span> n2.vnode.isVisible<span class="asBracket">)</span> <span class="asBracket">{</span>
                _visibleEdges<span class="asBracket">[</span>e<span class="asBracket">]</span> <span class="asOperator">=</span> e;
            <span class="asBracket">}</span>
            
            <span class="asReserved">return</span> vedge;
        <span class="asBracket">}</span>

        <span class="asDoc">/**
         * Remove a VisualEdge, but leaves the Graph Edge alone.
         * @param ve The VisualEdge to be removed.
         * */</span>
        <span class="asReserved">private</span> <span class="asFunction">function</span> removeVEdge<span class="asBracket">(</span>ve<span class="asOperator">:</span>IVisualEdge<span class="asBracket">)</span><span class="asOperator">:</span><span class="asReserved">void</span> <span class="asBracket">{</span>
            
            <span class="asComment">/* remove the reference from the real edge */</span>
            ve.edge.vedge <span class="asOperator">=</span> <span class="asReserved">null</span>;
            
            <span class="asComment">/* remove the visible edge if present */</span>
            <span class="asReserved">delete</span> _visibleEdges<span class="asBracket">[</span>ve.edge<span class="asBracket">]</span>;
            
            <span class="asComment">/* that should actually do */</span>
        <span class="asBracket">}</span>
    
        <span class="asDoc">/**
         * Purges the VGraph by dropping all VNodes and VEdges.
         * This is a bit tricky, since we do not really
         * keep track of them in the VGraph, they are only referenced
         * by the Graph nodes and egdes.
         * */</span>
        <span class="asReserved">private</span> <span class="asFunction">function</span> purgeVGraph<span class="asBracket">()</span><span class="asOperator">:</span><span class="asReserved">void</span> <span class="asBracket">{</span>
            
            <span class="asVar">var</span> edges<span class="asOperator">:</span>Array;
            <span class="asVar">var</span> nodes<span class="asOperator">:</span>Array;
            <span class="asVar">var</span> edge<span class="asOperator">:</span>IEdge;
            <span class="asVar">var</span> node<span class="asOperator">:</span>INode;
            
            <span class="asTrace">trace</span><span class="asBracket">(</span><span class="asString">&quot;purgeVGraph called&quot;</span><span class="asBracket">)</span>;
            
            <span class="asReserved">if</span><span class="asBracket">(</span>_graph <span class="asOperator">!=</span> <span class="asReserved">null</span><span class="asBracket">)</span> <span class="asBracket">{</span>
                edges <span class="asOperator">=</span> _graph.edges;
                nodes <span class="asOperator">=</span> _graph.nodes;
            
                <span class="asReserved">for</span> <span class="asReserved">each</span><span class="asBracket">(</span>edge <span class="asReserved">in</span> edges<span class="asBracket">)</span> <span class="asBracket">{</span>
                    removeVEdge<span class="asBracket">(</span>edge.vedge<span class="asBracket">)</span>;
                <span class="asBracket">}</span>
                <span class="asReserved">for</span> <span class="asReserved">each</span><span class="asBracket">(</span>node <span class="asReserved">in</span> nodes<span class="asBracket">)</span> <span class="asBracket">{</span>
                    removeVNode<span class="asBracket">(</span>node.vnode<span class="asBracket">)</span>;
                <span class="asBracket">}</span>
            <span class="asBracket">}</span> <span class="asReserved">else</span> <span class="asBracket">{</span>
                <span class="asTrace">trace</span><span class="asBracket">(</span><span class="asString">&quot;we had no graph to purge from, so nothing was done&quot;</span><span class="asBracket">)</span>;
            <span class="asBracket">}</span>                
        <span class="asBracket">}</span>
    
        <span class="asDoc">/**
         * Redraw all edges, this is called from the updateDisplayList()
         * method.
         * */</span>
        <span class="asReserved">private</span> <span class="asFunction">function</span> redrawEdges<span class="asBracket">()</span><span class="asOperator">:</span><span class="asReserved">void</span> <span class="asBracket">{</span>
            
            <span class="asVar">var</span> vn1<span class="asOperator">:</span>IVisualNode;
            <span class="asVar">var</span> vn2<span class="asOperator">:</span>IVisualNode;
            <span class="asVar">var</span> color<span class="asOperator">:</span>int;
            <span class="asVar">var</span> edge<span class="asOperator">:</span>IEdge;
            
            <span class="asVar">var</span> distinguished<span class="asOperator">:</span>Boolean;
            
            <span class="asComment">/* make sure we have a graph */</span>
            <span class="asReserved">if</span><span class="asBracket">(</span>_graph <span class="asOperator">==</span> <span class="asReserved">null</span><span class="asBracket">)</span> <span class="asBracket">{</span>
                <span class="asReserved">throw</span> Error<span class="asBracket">(</span><span class="asString">&quot;_graph object in VisualGraph is null&quot;</span><span class="asBracket">)</span>;
            <span class="asBracket">}</span>
    
            <span class="asComment">/* clear the drawing surface and remove previous
             * edges */</span>
            _drawingSurface.graphics.clear<span class="asBracket">()</span>;
            
            <span class="asComment">/* now walk through all currently visible egdes */</span>
            <span class="asReserved">for</span> <span class="asReserved">each</span><span class="asBracket">(</span>edge <span class="asReserved">in</span> _visibleEdges<span class="asBracket">)</span> <span class="asBracket">{</span>
                
                <span class="asComment">/* get the two nodes attached to the edge */</span>
                vn1 <span class="asOperator">=</span> edge.node1.vnode;
                vn2 <span class="asOperator">=</span> edge.node2.vnode;
                
                <span class="asComment">/* all nodes should be visible, so we make an assertion
                 * here */</span>
                <span class="asReserved">if</span><span class="asBracket">(</span><span class="asOperator">!</span>vn1.isVisible <span class="asOperator">||</span> <span class="asOperator">!</span>vn2.isVisible<span class="asBracket">)</span> <span class="asBracket">{</span>
                    <span class="asReserved">throw</span> Error<span class="asBracket">(</span><span class="asString">&quot;One of the nodes of the checked edge is not visible, but should be!&quot;</span><span class="asBracket">)</span>;
                <span class="asBracket">}</span>
                
                <span class="asComment">/* XXX
                 * The following controls the colouring but this should
                 * be optimised and handled more flexible */</span>
                <span class="asReserved">if</span><span class="asBracket">(</span>vn1 <span class="asOperator">==</span> _distinguishedNode <span class="asOperator">||</span> vn2 <span class="asOperator">==</span> _distinguishedNode<span class="asBracket">)</span> <span class="asBracket">{</span>
                    distinguished <span class="asOperator">=</span> <span class="asReserved">true</span>;
                <span class="asBracket">}</span> <span class="asReserved">else</span> <span class="asBracket">{</span>
                    distinguished <span class="asOperator">=</span> <span class="asReserved">false</span>;
                <span class="asBracket">}</span>

                <span class="asComment">/* Change: we do not pass the nodes or the vnodes, but the
                 * edge. The reason is that the edge can have properties
                 * assigned with it that affect the drawing. Right now we 
                 * pass the fact if this is a &apos;distinguished&apos; edge and leave
                 * the color choice up to the edgerenderer */</span>
                drawEdge<span class="asBracket">(</span>edge,distinguished<span class="asBracket">)</span>;
            <span class="asBracket">}</span>
            <span class="asComment">// we are done, so we reset the indicator
</span>            _layouter.layoutChanged <span class="asOperator">=</span> <span class="asReserved">false</span>;
        <span class="asBracket">}</span>
        
        <span class="asDoc">/**
         * this currently ONLY calls the edge renderer, this 
         * method is basically useless and we could move the call
         * into redrawEdges(). For now we leave it like this */</span>
        <span class="asReserved">private</span> <span class="asFunction">function</span> drawEdge<span class="asBracket">(</span>edge<span class="asOperator">:</span>IEdge, distinguished<span class="asOperator">:</span>Boolean<span class="asBracket">)</span><span class="asOperator">:</span><span class="asReserved">void</span> <span class="asBracket">{</span>
            <span class="asComment">/* at this point, the edgeRenderer takes over,
             * SG had kind of a default renderer implicitly added
             * while we stick to that being modular
             */</span>
            
            <span class="asComment">/* another idea would be to let the edge implement the
             * edge renderer interface and draw itself, but that would
             * make this less modular and interchangeable
             * we stick to the separate edge renderer */</span>
            _edgeRenderer.draw<span class="asBracket">(</span>_drawingSurface.graphics, edge, distinguished<span class="asBracket">)</span>;
        <span class="asBracket">}</span>
        

        <span class="asDoc">/**
         * Lookup a node by its UIComponent. This is more a convenience
         * method with some sanity check. Primarily used by event handlers.
         * @param c The component to find the VisualNode for.
         * @return The found Node.
         * @throws An Error if the component was not registered in the map.
         * */</span>
        <span class="asReserved">private</span> <span class="asFunction">function</span> lookupNode<span class="asBracket">(</span>c<span class="asOperator">:</span>UIComponent<span class="asBracket">)</span><span class="asOperator">:</span>IVisualNode <span class="asBracket">{</span>
            <span class="asVar">var</span> vn<span class="asOperator">:</span>IVisualNode <span class="asOperator">=</span> _viewToVNodeMap<span class="asBracket">[</span>c<span class="asBracket">]</span>;
            <span class="asReserved">if</span><span class="asBracket">(</span>vn <span class="asOperator">==</span> <span class="asReserved">null</span><span class="asBracket">)</span> <span class="asBracket">{</span>
                <span class="asReserved">throw</span> Error<span class="asBracket">(</span><span class="asString">&quot;Component not in viewToVNodeMap&quot;</span><span class="asBracket">)</span>;
            <span class="asBracket">}</span>
            <span class="asReserved">return</span> vn;
        <span class="asBracket">}</span>
        
        
        
        <span class="asDoc">/**
         * Create a &quot;view&quot; object (UIComponent) for the given node and
         * return it. These methods are only exported to be used by
         * the VisualNode. Alas, AS does not provide the &quot;friend&quot; directive.
         * Not sure how to get around this problem right now.
         * @param vn The node to replace/add a view object.
         * @return The created view object.
         * */</span>
        <span class="asReserved">private</span> <span class="asFunction">function</span> createVNodeComponent<span class="asBracket">(</span>vn<span class="asOperator">:</span>IVisualNode<span class="asBracket">)</span><span class="asOperator">:</span>UIComponent <span class="asBracket">{</span>
            
            <span class="asVar">var</span> mycomponent<span class="asOperator">:</span>UIComponent <span class="asOperator">=</span> <span class="asReserved">null</span>;
            
             <span class="asComment">/*
              * a possible view factory is our own implementation
              * of such a Factory, currently not used.
             if(_viewFactory != null) {
                 result = viewFactory.getView(VNode) as UIComponent;
             }
             */</span>

            <span class="asReserved">if</span><span class="asBracket">(</span>_itemRendererFactory <span class="asOperator">!=</span> <span class="asReserved">null</span><span class="asBracket">)</span> <span class="asBracket">{</span>
                mycomponent <span class="asOperator">=</span> _itemRendererFactory.newInstance<span class="asBracket">()</span>;
            <span class="asBracket">}</span> <span class="asReserved">else</span> <span class="asBracket">{</span>
                mycomponent <span class="asOperator">=</span> <span class="asReserved">new</span> UIComponent<span class="asBracket">()</span>;
            <span class="asBracket">}</span>            
                
            <span class="asComment">/* assigns the item (VisualNode) to the IDataRenderer part of the view
             * this is important to access the data object of the VNode
             * which contains information for rendering. */</span>        
            <span class="asReserved">if</span><span class="asBracket">(</span>mycomponent <span class="asReserved">is</span> IDataRenderer<span class="asBracket">)</span> <span class="asBracket">{</span>
                <span class="asBracket">(</span>mycomponent <span class="asReserved">as</span> IDataRenderer<span class="asBracket">)</span>.data <span class="asOperator">=</span> vn;
            <span class="asBracket">}</span>
            
            <span class="asComment">/* set initial x/y values */</span>
            mycomponent.x <span class="asOperator">=</span> _canvas.width <span class="asOperator">/</span> 2.0;
            mycomponent.y <span class="asOperator">=</span> _canvas.height <span class="asOperator">/</span> 2.0;
            
            <span class="asComment">/* add event handlers for dragging and double click */</span>            
            mycomponent.doubleClickEnabled <span class="asOperator">=</span> <span class="asReserved">true</span>;
            mycomponent.addEventListener<span class="asBracket">(</span>MouseEvent.DOUBLE_CLICK,nodeDoubleClick<span class="asBracket">)</span>;
            mycomponent.addEventListener<span class="asBracket">(</span>MouseEvent.MOUSE_DOWN,nodeMouseDown<span class="asBracket">)</span>;

            <span class="asComment">/* add the component to its parent component */</span>
            _canvas.addChild<span class="asBracket">(</span>mycomponent<span class="asBracket">)</span>;
            
            <span class="asComment">/* do we have an effect set for addition of
             * items? If yes, create and start it. */</span>
            <span class="asReserved">if</span><span class="asBracket">(</span>addItemEffect <span class="asOperator">!=</span> <span class="asReserved">null</span><span class="asBracket">)</span> <span class="asBracket">{</span>
                addItemEffect.createInstance<span class="asBracket">(</span>mycomponent<span class="asBracket">)</span>.startEffect<span class="asBracket">()</span>;
            <span class="asBracket">}</span>
            
            <span class="asComment">/* register it the view in the vnode and the mapping */</span>
            vn.view <span class="asOperator">=</span> mycomponent;
            _viewToVNodeMap<span class="asBracket">[</span>mycomponent<span class="asBracket">]</span> <span class="asOperator">=</span> vn;
            
            <span class="asComment">/* increase the component counter */</span>
            <span class="asOperator">++</span>_componentCounter;
            
            <span class="asComment">/* assertion there should not be more components than
             * visible nodes */</span>
            <span class="asReserved">if</span><span class="asBracket">(</span>_componentCounter <span class="asOperator">&gt;</span> <span class="asBracket">(</span>_noVisibleVNodes<span class="asBracket">))</span> <span class="asBracket">{</span>
                <span class="asReserved">throw</span> Error<span class="asBracket">(</span><span class="asString">&quot;Got too many components:&quot;</span><span class="asOperator">+</span>_componentCounter<span class="asOperator">+</span><span class="asString">&quot; but only:&quot;</span><span class="asOperator">+</span>_noVisibleVNodes
                <span class="asOperator">+</span><span class="asString">&quot; nodes visible&quot;</span><span class="asBracket">)</span>;
            <span class="asBracket">}</span>
            
            <span class="asComment">/* we need to invalidate the display list since
             * we created new children */</span>
            refresh<span class="asBracket">()</span>;
            
            <span class="asReserved">return</span> mycomponent;
        <span class="asBracket">}</span>
        
        <span class="asDoc">/**
         * Remove a &quot;view&quot; object (UIComponent) for the given node and specify whether
         * this should honor any specified add/remove effects.
         * These methods are only exported to be used by
         * the VisualNode. Alas, AS does not provide the &quot;friend&quot; directive.
         * Not sure how to get around this problem right now.
         * @param component The UIComponent to be removed.
         * @param honorEffect To specify whether the effect should be applied or not.
         * */</span>
        <span class="asReserved">private</span> <span class="asFunction">function</span> removeComponent<span class="asBracket">(</span>component<span class="asOperator">:</span>UIComponent, honorEffect<span class="asOperator">:</span>Boolean <span class="asOperator">=</span> <span class="asReserved">true</span><span class="asBracket">)</span><span class="asOperator">:</span><span class="asReserved">void</span> <span class="asBracket">{</span>
            
            <span class="asVar">var</span> vn<span class="asOperator">:</span>IVisualNode;
            
            <span class="asComment">/* if there is an effect, start the effect and register a
             * handler that actually calls this method again, but
             * with honorEffect set to false */</span>
            <span class="asReserved">if</span><span class="asBracket">(</span>honorEffect <span class="asOperator">&amp;&amp;</span> <span class="asBracket">(</span>removeItemEffect <span class="asOperator">!=</span> <span class="asReserved">null</span><span class="asBracket">))</span> <span class="asBracket">{</span>
                removeItemEffect.addEventListener<span class="asBracket">(</span>EffectEvent.EFFECT_END,
                                                   removeEffectDone<span class="asBracket">)</span>;
                removeItemEffect.createInstance<span class="asBracket">(</span>component<span class="asBracket">)</span>.startEffect<span class="asBracket">()</span>;
            <span class="asBracket">}</span> <span class="asReserved">else</span> <span class="asBracket">{</span>
                <span class="asComment">/* remove the component from it&apos;s parent (which should be the canvas) */</span>
                <span class="asReserved">if</span><span class="asBracket">(</span>component.parent <span class="asOperator">!=</span> <span class="asReserved">null</span><span class="asBracket">)</span> <span class="asBracket">{</span>
                    component.parent.removeChild<span class="asBracket">(</span>component<span class="asBracket">)</span>;
                <span class="asBracket">}</span>
                
                <span class="asComment">/* remove event mouse listeners */</span>
                component.removeEventListener<span class="asBracket">(</span>MouseEvent.DOUBLE_CLICK,nodeDoubleClick<span class="asBracket">)</span>;
                component.removeEventListener<span class="asBracket">(</span>MouseEvent.MOUSE_DOWN,nodeMouseDown<span class="asBracket">)</span>;
                
                <span class="asComment">/* get the associated VNode and remove the view from it
                 * and also remove the map entry */</span>
                vn <span class="asOperator">=</span> _viewToVNodeMap<span class="asBracket">[</span>component<span class="asBracket">]</span>;
                vn.view <span class="asOperator">=</span> <span class="asReserved">null</span>;
                <span class="asReserved">delete</span> _viewToVNodeMap<span class="asBracket">[</span>component<span class="asBracket">]</span>;
                
                <span class="asComment">/* decreate component counter */</span>
                <span class="asOperator">--</span>_componentCounter;
                
                <span class="asComment">//trace(&quot;removed component from node:&quot;+vn.id);
</span>            <span class="asBracket">}</span>
        <span class="asBracket">}</span>
        
        <span class="asDoc">/**
         * Event handler for a removal node procedure. Calls
         * removeComponent with a flag to avoid doing the effect again.
         * */</span>
        <span class="asReserved">private</span> <span class="asFunction">function</span> removeEffectDone<span class="asBracket">(</span>event<span class="asOperator">:</span>EffectEvent<span class="asBracket">)</span><span class="asOperator">:</span><span class="asReserved">void</span> <span class="asBracket">{</span>
            <span class="asVar">var</span> mycomponent<span class="asOperator">:</span>UIComponent <span class="asOperator">=</span> event.effectInstance.target <span class="asReserved">as</span> UIComponent;
            <span class="asComment">/* call remove component again, but specify to ignore the effect */</span>
            removeComponent<span class="asBracket">(</span>mycomponent, <span class="asReserved">false</span><span class="asBracket">)</span>;
        <span class="asBracket">}</span>
        
        <span class="asDoc">/**
         * Event handler to work on double-click events.
         * Any double click also counts as a drop event to
         * the layouter. But primarily the double click
         * sets a new root node.
         * @param e The corresponding event.
         * */</span>
        <span class="asReserved">private</span> <span class="asFunction">function</span> nodeDoubleClick<span class="asBracket">(</span>e<span class="asOperator">:</span>MouseEvent<span class="asBracket">)</span><span class="asOperator">:</span><span class="asReserved">void</span> <span class="asBracket">{</span>
            <span class="asVar">var</span> comp<span class="asOperator">:</span>UIComponent;
            <span class="asVar">var</span> vnode<span class="asOperator">:</span>IVisualNode;
            
            <span class="asComment">/* get the view object that was klicked on (actually
             * the one that has the event handler registered, which
             * is the VNode&apos;s view */</span>
            comp <span class="asOperator">=</span> <span class="asBracket">(</span>e.currentTarget <span class="asReserved">as</span> UIComponent<span class="asBracket">)</span>;
            
            <span class="asComment">/* get the associated VNode */</span>
            vnode <span class="asOperator">=</span> lookupNode<span class="asBracket">(</span>comp<span class="asBracket">)</span>;
            
            <span class="asComment">//trace(&quot;double click!&quot;);
</span>            
            <span class="asComment">/* if the node was dragged, we notify the 
             * layouter of the drop event */</span>
            _layouter.dropEvent<span class="asBracket">(</span>e,vnode<span class="asBracket">)</span>;
            
            <span class="asComment">/* Now we change the root node, we go through
             * our public setter method to get all associated
             * updates done. */</span>
            <span class="asReserved">this</span>.currentRootVNode <span class="asOperator">=</span> vnode;
            
            <span class="asComment">//trace(&quot;currentVNode:&quot;+this.currentRootVNode.id);
</span>        <span class="asBracket">}</span>

        <span class="asDoc">/**
         * This is the event handler for a single click 
         * event. Currently does two things:
         * 1. It highlights the node that
         *    was clicked on (highlight in terms of making it
         *    a distinguished node, which changes the colours
         *    of its associated edges).
         * 2. Starts a drag operation of this node.
         * @param e The associated event.
         * */</span>
        <span class="asReserved">private</span> <span class="asFunction">function</span> nodeMouseDown<span class="asBracket">(</span>e<span class="asOperator">:</span>MouseEvent<span class="asBracket">)</span><span class="asOperator">:</span><span class="asReserved">void</span> <span class="asBracket">{</span>
            highlightNode<span class="asBracket">(</span>e<span class="asBracket">)</span>;
            dragBegin<span class="asBracket">(</span>e<span class="asBracket">)</span>;
        <span class="asBracket">}</span>
        <span class="asDoc">/**
         * Highlight a node that was target of the passed
         * event by making it the distinguished node.
         * @param event The Mouse event that was triggered by click.
         * */</span>
        <span class="asReserved">private</span> <span class="asFunction">function</span> highlightNode<span class="asBracket">(</span>event<span class="asOperator">:</span>MouseEvent<span class="asBracket">)</span><span class="asOperator">:</span><span class="asReserved">void</span> <span class="asBracket">{</span>
            <span class="asVar">var</span> comp<span class="asOperator">:</span>UIComponent;
            <span class="asVar">var</span> vnode<span class="asOperator">:</span>IVisualNode;
            
            <span class="asComment">/* get the view object that was klicked on (actually
             * the one that has the event handler registered, which
             * is the VNode&apos;s view */</span>
            comp <span class="asOperator">=</span> <span class="asBracket">(</span>event.currentTarget <span class="asReserved">as</span> UIComponent<span class="asBracket">)</span>;
            
            <span class="asComment">/* get the associated VNode */</span>
            vnode <span class="asOperator">=</span> lookupNode<span class="asBracket">(</span>comp<span class="asBracket">)</span>;
            
            
            
            <span class="asReserved">if</span><span class="asBracket">(</span>vnode<span class="asBracket">)</span> <span class="asBracket">{</span>                
                <span class="asComment">/* set the node as distinguished */</span>
                _distinguishedNode <span class="asOperator">=</span> vnode;
                
                <span class="asComment">/* make sure the edges are redrawn so that
                 * the changed color is shown */</span>
                refresh<span class="asBracket">()</span>;
            <span class="asBracket">}</span>
        <span class="asBracket">}</span>
        
        <span class="asDoc">/**
         * Start a drag operation. This sets the drag node and
         * registeres a &apos;MouseMove&apos; event handler with the
         * VNode, so it can follow the mouse movement.
         * @param event The MouseEvent that was triggered by clicking on the node.
         * @see handleDrag()
         * */</span>
        <span class="asReserved">private</span> <span class="asFunction">function</span> dragBegin<span class="asBracket">(</span>event<span class="asOperator">:</span>MouseEvent<span class="asBracket">)</span><span class="asOperator">:</span><span class="asReserved">void</span> <span class="asBracket">{</span>
            
            <span class="asVar">var</span> ecomponent<span class="asOperator">:</span>UIComponent;
            <span class="asVar">var</span> evnode<span class="asOperator">:</span>IVisualNode;
            <span class="asVar">var</span> pt<span class="asOperator">:</span>Point;
            
            <span class="asComment">//trace(&quot;DragBegin was called...&quot;);
</span>            
            <span class="asComment">/* if there is an animation in progress, we ignore
             * the drag attempt */</span>
            <span class="asReserved">if</span><span class="asBracket">(</span>_layouter.animInProgress<span class="asBracket">)</span> <span class="asBracket">{</span>
                <span class="asTrace">trace</span><span class="asBracket">(</span><span class="asString">&quot;Animation in progress, drag attempt ignored&quot;</span><span class="asBracket">)</span>;
                <span class="asReserved">return</span>;
            <span class="asBracket">}</span>
            
            <span class="asComment">/* make sure we get the right component */</span>
            <span class="asReserved">if</span><span class="asBracket">(</span>event.currentTarget <span class="asReserved">is</span> UIComponent<span class="asBracket">)</span> <span class="asBracket">{</span>
                
                ecomponent <span class="asOperator">=</span> <span class="asBracket">(</span>event.currentTarget <span class="asReserved">as</span> UIComponent<span class="asBracket">)</span>;
                
                <span class="asComment">/* get the associated VNode of the view */</span>
                evnode <span class="asOperator">=</span> _viewToVNodeMap<span class="asBracket">[</span>ecomponent<span class="asBracket">]</span>;
                
                <span class="asComment">/* stop propagation to prevent a concurrent backgroundDrag */</span>
                event.stopImmediatePropagation<span class="asBracket">()</span>;
                
                <span class="asReserved">if</span><span class="asBracket">(</span>evnode <span class="asOperator">!=</span> <span class="asReserved">null</span><span class="asBracket">)</span> <span class="asBracket">{</span>
                    <span class="asReserved">if</span><span class="asBracket">(</span><span class="asOperator">!</span>dragLockCenter<span class="asBracket">)</span> <span class="asBracket">{</span>
                        <span class="asComment">// lockCenter is false, use the mouse coordinates at the point
</span>                        pt <span class="asOperator">=</span> ecomponent.localToGlobal<span class="asBracket">(</span><span class="asReserved">new</span> Point<span class="asBracket">(</span>ecomponent.mouseX, ecomponent.mouseY<span class="asBracket">))</span>;
                    <span class="asBracket">}</span> <span class="asReserved">else</span> <span class="asBracket">{</span>
                        <span class="asComment">// lockCenter is true, ignore the mouse coordinates
</span>                        <span class="asComment">// and use (0,0) instead as the point
</span>                        pt <span class="asOperator">=</span> ecomponent.localToGlobal<span class="asBracket">(</span><span class="asReserved">new</span> Point<span class="asBracket">(</span>0,0<span class="asBracket">))</span>;
                    <span class="asBracket">}</span>
            
                    <span class="asComment">/* Save the offset values in the map 
                     * so we can compute x and y correctly in case
                     * we use lockCenter */</span>
                    _drag_x_offsetMap<span class="asBracket">[</span>ecomponent<span class="asBracket">]</span> <span class="asOperator">=</span> pt.x <span class="asOperator">-</span> ecomponent.x;
                    _drag_y_offsetMap<span class="asBracket">[</span>ecomponent<span class="asBracket">]</span> <span class="asOperator">=</span> pt.y <span class="asOperator">-</span> ecomponent.y;
            
                    <span class="asComment">/* now we would need to set the bounds
                     * rectangle in _drag_boundsMap, but this is
                     * currently not implemented *
                    _drag_boundsMap[ecomponent] = rectangle;
                     */</span>
                    
                    <span class="asComment">/* Registeran eventListener with the component&apos;s stage that
                     * handles any mouse move. This wires the component
                     * to the mouse. On every mouse move, the event handler
                     * is called, which updates its coordinates.
                     * We need to save the drag component, since we have to 
                     * register the event handler with the stage, not the component
                     * itself. But from the stage we have no way to get back to
                     * the component or the VNode in case of the mouse move or 
                     * drop event. 
                     */</span>
                    _dragComponent <span class="asOperator">=</span> ecomponent;
                    ecomponent.stage.addEventListener<span class="asBracket">(</span>MouseEvent.MOUSE_MOVE, handleDrag<span class="asBracket">)</span>;
            
                    <span class="asComment">/* also register a drop event listener */</span>
                    ecomponent.stage.addEventListener<span class="asBracket">(</span>MouseEvent.MOUSE_UP, dragEnd<span class="asBracket">)</span>;
                    
                    <span class="asComment">/* and inform the layouter about the dragEvent */</span>
                    _layouter.dragEvent<span class="asBracket">(</span>event, evnode<span class="asBracket">)</span>;
                <span class="asBracket">}</span> <span class="asReserved">else</span> <span class="asBracket">{</span>
                    <span class="asReserved">throw</span> Error<span class="asBracket">(</span><span class="asString">&quot;Event Component was not in the viewToVNode Map&quot;</span><span class="asBracket">)</span>;
                <span class="asBracket">}</span>
            <span class="asBracket">}</span> <span class="asReserved">else</span> <span class="asBracket">{</span>
                <span class="asReserved">throw</span> Error<span class="asBracket">(</span><span class="asString">&quot;MouseEvent target was no UIComponent&quot;</span><span class="asBracket">)</span>;
            <span class="asBracket">}</span>
        <span class="asBracket">}</span>

        <span class="asDoc">/**
         * Called everytime the mouse moves after the dragBegin() method has
         * been called.  Updates the position of the Component based on
         * the location of the mouse cursor.
         * @param event The MouseMove event that has been triggered.
         */</span>
        <span class="asReserved">private</span> <span class="asFunction">function</span> handleDrag<span class="asBracket">(</span>event<span class="asOperator">:</span>MouseEvent<span class="asBracket">)</span><span class="asOperator">:</span><span class="asReserved">void</span> <span class="asBracket">{</span>
            <span class="asVar">var</span> sp<span class="asOperator">:</span>UIComponent;
            
            <span class="asComment">//var bounds:Rectangle;
</span>            
            <span class="asComment">/* we set our Component to be the saved
             * dragComponent, because we cannot access it
             * through the event. */</span>
            sp <span class="asOperator">=</span> _dragComponent;
            
            <span class="asComment">/* Sometimes we get spurious events */</span>
            <span class="asReserved">if</span><span class="asBracket">(</span>_dragComponent <span class="asOperator">==</span> <span class="asReserved">null</span><span class="asBracket">)</span> <span class="asBracket">{</span>
                <span class="asTrace">trace</span><span class="asBracket">(</span><span class="asString">&quot;received handleDrag event but _dragComponent is null, ignoring&quot;</span><span class="asBracket">)</span>;
                <span class="asReserved">return</span>;
            <span class="asBracket">}</span>
            
            <span class="asComment">/* bounds are not implemented:
            bounds = _drag_boundsMap[sp];
            */</span>
            
            <span class="asComment">/* update the coordinates with the current
             * event&apos;s stage coordinates (i.e. current mouse position),
             * modified by the lock-center offset */</span>
            sp.x <span class="asOperator">=</span> event.stageX <span class="asOperator">-</span> _drag_x_offsetMap<span class="asBracket">[</span>sp<span class="asBracket">]</span>;
            sp.y <span class="asOperator">=</span> event.stageY <span class="asOperator">-</span> _drag_y_offsetMap<span class="asBracket">[</span>sp<span class="asBracket">]</span>;
            
            <span class="asComment">/* bounds code, currently unused 
            if ( bounds != null ) {
                if ( sp.x &lt; bounds.left ) {
                    sp.x = bounds.left;
                } else if ( sp.x &gt; bounds.right ) {
                    sp.x = bounds.right;
                }    
                if ( sp.y &lt; bounds.top ) {
                    sp.y = bounds.top;    
                } else if ( sp.y &gt; bounds.bottom ) {
                    sp.y = bounds.bottom;    
                }
            }
            */</span>
            
            <span class="asComment">/* make sure flashplayer does an update after the event */</span>
            refresh<span class="asBracket">()</span>;
            event.updateAfterEvent<span class="asBracket">()</span>;
        <span class="asBracket">}</span>

        <span class="asDoc">/**
         * This handles a background drag (i.e. scroll). The
         * event listener is usually registered with the canvas,
         * i.e. this object.
         * @param event The triggered event.
         * */</span>
        <span class="asReserved">private</span> <span class="asFunction">function</span> backgroundDragBegin<span class="asBracket">(</span>event<span class="asOperator">:</span>MouseEvent<span class="asBracket">)</span><span class="asOperator">:</span><span class="asReserved">void</span> <span class="asBracket">{</span>
        
            <span class="asVar">var</span> mycomponent<span class="asOperator">:</span>UIComponent;
        
            <span class="asComment">/* if there is an animation in progress, we ignore
             * the drag attempt */</span>
            <span class="asReserved">if</span><span class="asBracket">(</span>_layouter.animInProgress<span class="asBracket">)</span> <span class="asBracket">{</span>
                <span class="asTrace">trace</span><span class="asBracket">(</span><span class="asString">&quot;Animation in progress, drag attempt ignored&quot;</span><span class="asBracket">)</span>;
                <span class="asReserved">return</span>;
            <span class="asBracket">}</span>
        
        
            <span class="asComment">/* this should be the canvas, i.e. &quot;this&quot; */</span>
            mycomponent <span class="asOperator">=</span> <span class="asBracket">(</span>event.currentTarget <span class="asReserved">as</span> UIComponent<span class="asBracket">)</span>;
            
            <span class="asComment">/* check for validity */</span>
            <span class="asReserved">if</span><span class="asBracket">(</span>mycomponent <span class="asOperator">==</span> <span class="asReserved">null</span><span class="asBracket">)</span> <span class="asBracket">{</span>
                <span class="asReserved">throw</span> Error<span class="asBracket">(</span><span class="asString">&quot;Got backgroundDragBegin without UIComponent target!&quot;</span><span class="asBracket">)</span>;
            <span class="asBracket">}</span>
            
            <span class="asComment">/* set the progress flag and save the starting coordinates */</span>
            _backgroundDragInProgress <span class="asOperator">=</span> <span class="asReserved">true</span>;
            _dragCursorStartX <span class="asOperator">=</span> event.stageX;
            _dragCursorStartY <span class="asOperator">=</span> event.stageY;

            <span class="asComment">/* register the backgroundDrag listener to react to
             * the mouse movements */</span>
            mycomponent.addEventListener<span class="asBracket">(</span>MouseEvent.MOUSE_MOVE,backgroundDragContinue<span class="asBracket">)</span>;
        <span class="asBracket">}</span>
        
        <span class="asDoc">/**
         * This does the actual background drag by having
         * all UIComponents move to follow the mouse
         * @param event The triggered mouse move event.
         * */</span> 
        <span class="asReserved">private</span> <span class="asFunction">function</span> backgroundDragContinue<span class="asBracket">(</span>event<span class="asOperator">:</span>MouseEvent<span class="asBracket">)</span><span class="asOperator">:</span><span class="asReserved">void</span> <span class="asBracket">{</span>
            
            <span class="asVar">var</span> deltaX<span class="asOperator">:</span>Number;
            <span class="asVar">var</span> deltaY<span class="asOperator">:</span>Number;
            
            <span class="asComment">/* compute the movement offset of this move by
             * subtracting the current mouse position from
             * the last mouse position */</span>
            deltaX <span class="asOperator">=</span> event.stageX <span class="asOperator">-</span> _dragCursorStartX;
            deltaY <span class="asOperator">=</span> event.stageY <span class="asOperator">-</span> _dragCursorStartY;
             
            <span class="asComment">/* reset the origin for the next step */</span>
            _dragCursorStartX <span class="asOperator">=</span> event.stageX;
            _dragCursorStartY <span class="asOperator">=</span> event.stageY;
            
            <span class="asComment">/* scroll all objects by this offset */</span>
            scroll<span class="asBracket">(</span>deltaX, deltaY<span class="asBracket">)</span>;
            
            <span class="asComment">/* make sure edges are redrawn */</span>
            <span class="asComment">//_drawingSurface.invalidateDisplayList();
</span>            refresh<span class="asBracket">()</span>;
        <span class="asBracket">}</span>


        <span class="asDoc">/**
         * This method handles the drop event (usually MOUSE_UP).
         * It stops any dragging in progress (including background drag)
         * and unregisters the current dragged node.
         * @param event The triggered event.
         * */</span>
        <span class="asReserved">private</span> <span class="asFunction">function</span> dragEnd<span class="asBracket">(</span>event<span class="asOperator">:</span>MouseEvent<span class="asBracket">)</span><span class="asOperator">:</span><span class="asReserved">void</span> <span class="asBracket">{</span>
            
            <span class="asVar">var</span> mycomp<span class="asOperator">:</span>UIComponent;
            <span class="asVar">var</span> myback<span class="asOperator">:</span>DisplayObject;
            <span class="asVar">var</span> myvnode<span class="asOperator">:</span>IVisualNode;
            
            <span class="asReserved">if</span><span class="asBracket">(</span>_backgroundDragInProgress<span class="asBracket">)</span> <span class="asBracket">{</span>
                
                <span class="asComment">/* if it was a background drag we stop it here */</span>
                _backgroundDragInProgress <span class="asOperator">=</span> <span class="asReserved">false</span>;
                
                <span class="asComment">/* get the background drag object, which is usually
                 * the canvas */</span>
                myback <span class="asOperator">=</span> <span class="asBracket">(</span>event.currentTarget <span class="asReserved">as</span> DisplayObject<span class="asBracket">)</span>;
                <span class="asReserved">if</span><span class="asBracket">(</span>myback <span class="asOperator">==</span> <span class="asReserved">null</span><span class="asBracket">)</span> <span class="asBracket">{</span>
                    <span class="asComment">/* this can happen if we let go of the button
                     * outside of the window */</span>
                    <span class="asTrace">trace</span><span class="asBracket">(</span><span class="asString">&quot;dragEnd: background drop event target was no DisplayObject but &quot;</span><span class="asOperator">+</span>event.currentTarget.toString<span class="asBracket">())</span>;
                <span class="asBracket">}</span>
                
                <span class="asComment">/* unregister event handler */</span>                
                myback.removeEventListener<span class="asBracket">(</span>MouseEvent.MOUSE_MOVE,backgroundDragContinue<span class="asBracket">)</span>;
                myback.removeEventListener<span class="asBracket">(</span>MouseEvent.MOUSE_MOVE,dragEnd<span class="asBracket">)</span>;
                
            <span class="asBracket">}</span> <span class="asReserved">else</span> <span class="asBracket">{</span>
                
                <span class="asComment">/* if it was no background drag, the component
                 * is the saved dragComponent */</span>
                mycomp <span class="asOperator">=</span> _dragComponent;
                
                <span class="asComment">/* But sometimes the dragComponent was already null, 
                 * in this case we have to ignore the thing. */</span>
                <span class="asReserved">if</span><span class="asBracket">(</span>mycomp <span class="asOperator">==</span> <span class="asReserved">null</span><span class="asBracket">)</span> <span class="asBracket">{</span>
                    <span class="asTrace">trace</span><span class="asBracket">(</span><span class="asString">&quot;dragEnd: received dragEnd but _dragComponent was null, ignoring&quot;</span><span class="asBracket">)</span>;
                    <span class="asReserved">return</span>;
                <span class="asBracket">}</span>
                
                <span class="asComment">/* remove the event listeners */</span>
                mycomp.stage.removeEventListener<span class="asBracket">(</span>MouseEvent.MOUSE_DOWN, dragEnd<span class="asBracket">)</span>;
                mycomp.stage.removeEventListener<span class="asBracket">(</span>MouseEvent.MOUSE_MOVE, handleDrag<span class="asBracket">)</span>;
                
                <span class="asComment">/* get the associated VNode to notify the layouter */</span>
                myvnode <span class="asOperator">=</span> _viewToVNodeMap<span class="asBracket">[</span>mycomp<span class="asBracket">]</span>;
                _layouter.dropEvent<span class="asBracket">(</span>event, myvnode<span class="asBracket">)</span>;
                
                <span class="asComment">/* reset the dragComponent */</span>
                _dragComponent <span class="asOperator">=</span> <span class="asReserved">null</span>;
                
            <span class="asBracket">}</span>
            
            <span class="asComment">/* and stop propagation, as otherwise we could get the
             * event multiple times */</span>
            event.stopImmediatePropagation<span class="asBracket">()</span>;            
        <span class="asBracket">}</span>
        
        <span class="asDoc">/** 
         * 1. saves the old nodeID hash object.
         * 2. sets the new _nodeIDsWithinDistanceLimit Object from the object
         *    provided (typically provided from the GTree of a Graph).
         * 3. updates the amount of nodes in that object, by linearly
         *    counting them. This may be optimized...
         * @param vnids Object containing a hash with all node id&apos;s currently within the distance limit.
         * */</span>
        <span class="asReserved">private</span> <span class="asFunction">function</span> setDistanceLimitedNodeIds<span class="asBracket">(</span>vnids<span class="asOperator">:</span>Dictionary<span class="asBracket">)</span><span class="asOperator">:</span><span class="asReserved">void</span> <span class="asBracket">{</span>
            <span class="asVar">var</span> val<span class="asOperator">:</span>Boolean;
            <span class="asVar">var</span> amount<span class="asOperator">:</span>uint;
            <span class="asVar">var</span> vn<span class="asOperator">:</span>IVisualNode;
            <span class="asVar">var</span> n<span class="asOperator">:</span>INode;
            
            <span class="asComment">/* reset the amount */</span>
            amount <span class="asOperator">=</span> 0;
            
            <span class="asComment">/* save the old hash */</span>
            _prevNodeIDsWithinDistanceLimit <span class="asOperator">=</span> _nodeIDsWithinDistanceLimit;
            
            <span class="asComment">/* set the new hash object */</span>
            _nodeIDsWithinDistanceLimit <span class="asOperator">=</span> <span class="asReserved">new</span> Dictionary;
            
            <span class="asComment">/* walk through the hash and build the distanceLimit hash */</span>
            <span class="asReserved">for</span> <span class="asReserved">each</span><span class="asBracket">(</span>n <span class="asReserved">in</span> vnids<span class="asBracket">)</span> <span class="asBracket">{</span>
                vn <span class="asOperator">=</span> n.vnode;
                _nodeIDsWithinDistanceLimit<span class="asBracket">[</span>vn<span class="asBracket">]</span> <span class="asOperator">=</span> vn;
                
                <span class="asComment">/* increase the amount */</span>
                <span class="asOperator">++</span>amount;
            <span class="asBracket">}</span>
        
            <span class="asComment">/* count all entries in this hash */</span>
            <span class="asReserved">for</span> <span class="asReserved">each</span><span class="asBracket">(</span>val <span class="asReserved">in</span> vnids<span class="asBracket">)</span> <span class="asBracket">{</span>
                <span class="asReserved">if</span><span class="asBracket">(</span>val<span class="asBracket">)</span> <span class="asBracket">{</span>
                    <span class="asOperator">++</span>amount;
                <span class="asBracket">}</span>
            <span class="asBracket">}</span>
            <span class="asComment">/* set the new amount */</span>
            _noNodesWithinDistance <span class="asOperator">=</span> amount;
            
            <span class="asComment">//trace(&quot;current visible nodeids:&quot;+_noNodesWithinDistance);
</span>        <span class="asBracket">}</span>
        
        <span class="asDoc">/**
         * This needs to walk through all nodes in the graph, as some nodes
         * have become invisible and other have become visible. There may be
         * a better way to do this, when adjusting the visibility but it is
         * not that clear.
         * 
         * walk through the graph and the limitedGraph and
         * turn off visibility for those that are not listed in
         * both
         * beware that the limited graph has no VItems, so 
         * we don&apos;t really need it, we would rather need
         * an array of node ids....
         * */</span>
        <span class="asReserved">private</span> <span class="asFunction">function</span> updateVisibility<span class="asBracket">()</span><span class="asOperator">:</span><span class="asReserved">void</span> <span class="asBracket">{</span>
            <span class="asVar">var</span> n<span class="asOperator">:</span>INode;
            <span class="asVar">var</span> e<span class="asOperator">:</span>IEdge;
            <span class="asVar">var</span> edges<span class="asOperator">:</span>Array;
            <span class="asVar">var</span> treeparents<span class="asOperator">:</span>Dictionary;
            <span class="asVar">var</span> vn<span class="asOperator">:</span>IVisualNode;
            <span class="asVar">var</span> vno<span class="asOperator">:</span>IVisualNode;
            
            <span class="asVar">var</span> newVisibleNodes<span class="asOperator">:</span>Dictionary;
            <span class="asVar">var</span> toInvisibleNodes<span class="asOperator">:</span>Dictionary;
            
            <span class="asComment">/* since a layouter that uses timer based iterations
             * might find itself on a changing node set, we need
             * to stop/reset anything before altering the node
             * visibility */</span>
            _layouter.resetAll<span class="asBracket">()</span>;
            
            
            <span class="asComment">//trace(&quot;update node visibility&quot;);
</span>            
            <span class="asComment">/* create a copy of the currently visible 
             * node set, as the set for nodes to potentially
             * turned invisible */</span>
            toInvisibleNodes <span class="asOperator">=</span> <span class="asReserved">new</span> Dictionary;
            <span class="asReserved">for</span> <span class="asReserved">each</span><span class="asBracket">(</span>vn <span class="asReserved">in</span> _visibleVNodes<span class="asBracket">)</span> <span class="asBracket">{</span>
                toInvisibleNodes<span class="asBracket">[</span>vn<span class="asBracket">]</span> <span class="asOperator">=</span> vn;
            <span class="asBracket">}</span>
            
            <span class="asComment">/* now populate the set of nodes which should be
             * turned visible, first by using the nodes  within
             * distance limit */</span>
            newVisibleNodes <span class="asOperator">=</span> <span class="asReserved">new</span> Dictionary;
            
            <span class="asReserved">for</span> <span class="asReserved">each</span><span class="asBracket">(</span>vn <span class="asReserved">in</span> _nodeIDsWithinDistanceLimit<span class="asBracket">)</span> <span class="asBracket">{</span>
                newVisibleNodes<span class="asBracket">[</span>vn<span class="asBracket">]</span> <span class="asOperator">=</span> vn;
            <span class="asBracket">}</span>
            
            <span class="asComment">/* now add the history nodes to the set of new visible
             * nodes if the history is enabled */</span>
            <span class="asComment">/* Step 3: render all (new?) history nodes and nodes on the path visible (if applicable) */</span>
            <span class="asReserved">if</span><span class="asBracket">(</span>_showCurrentNodeHistory<span class="asBracket">)</span> <span class="asBracket">{</span>
        
                <span class="asComment">/* this is mapping in the tree that provides a parent
                 * for each single node in the tree 
                 * we need this to find the trace to the root */</span>
                treeparents <span class="asOperator">=</span> _graph.getTree<span class="asBracket">(</span>_currentRootVNode.node<span class="asBracket">)</span>.parents;
                
                <span class="asReserved">for</span> <span class="asReserved">each</span><span class="asBracket">(</span>vn <span class="asReserved">in</span> _currentVNodeHistory<span class="asBracket">)</span> <span class="asBracket">{</span>
                    n <span class="asOperator">=</span> vn.node;        
                    <span class="asComment">/* we cannot use vn here, because it is n that is changed
                     * in this while loop. Basically we are walking the tree
                     * backward from the current vnode&apos;s node n to the root
                     * for every vn in the history */</span>
                    <span class="asReserved">while</span><span class="asBracket">(</span>n.vnode <span class="asOperator">!=</span> _currentRootVNode<span class="asBracket">)</span> <span class="asBracket">{</span>
                        
                        <span class="asComment">/* set it visible */</span>
                        newVisibleNodes<span class="asBracket">[</span>n.vnode<span class="asBracket">]</span> <span class="asOperator">=</span> n.vnode;
                        <span class="asComment">//setNodeVisibility(n.vnode, true);
</span>                        
                        <span class="asComment">/* move to the parent node */</span>
                        n <span class="asOperator">=</span> treeparents<span class="asBracket">[</span>n<span class="asBracket">]</span>;
                        <span class="asReserved">if</span><span class="asBracket">(</span>n <span class="asOperator">==</span> <span class="asReserved">null</span><span class="asBracket">)</span> <span class="asBracket">{</span>
                            <span class="asReserved">throw</span> Error<span class="asBracket">(</span><span class="asString">&quot;parent node was null but node was not root node&quot;</span><span class="asBracket">)</span>;
                        <span class="asBracket">}</span>
                    <span class="asBracket">}</span>
                <span class="asBracket">}</span>
            <span class="asBracket">}</span>
            
            <span class="asComment">/* now from each set remove the common nodes, these
             * are the nodes that should remain visible, so they
             * must not be turned invisible and should also not
             * be turned visible again. */</span>
            
            <span class="asReserved">for</span> <span class="asReserved">each</span><span class="asBracket">(</span>vn <span class="asReserved">in</span> toInvisibleNodes<span class="asBracket">)</span> <span class="asBracket">{</span>
                <span class="asReserved">if</span><span class="asBracket">(</span>newVisibleNodes<span class="asBracket">[</span>vn<span class="asBracket">]</span> <span class="asOperator">!=</span> <span class="asReserved">null</span><span class="asBracket">)</span> <span class="asBracket">{</span>
                    <span class="asComment">/* this is a common node, remove it from
                     * both dictionaries 
                     */</span>
                    <span class="asReserved">delete</span> toInvisibleNodes<span class="asBracket">[</span>vn<span class="asBracket">]</span>;
                    <span class="asReserved">delete</span> newVisibleNodes<span class="asBracket">[</span>vn<span class="asBracket">]</span>;
                <span class="asBracket">}</span> 
            <span class="asBracket">}</span>
            
            <span class="asComment">/* now finally turn all toInvisibleNodes invisible
             * likewise any edge adjacent to an invisible node
             * will become invisible */</span>
            <span class="asReserved">for</span> <span class="asReserved">each</span><span class="asBracket">(</span>vn <span class="asReserved">in</span> toInvisibleNodes<span class="asBracket">)</span> <span class="asBracket">{</span>
                setNodeVisibility<span class="asBracket">(</span>vn, <span class="asReserved">false</span><span class="asBracket">)</span>;
                
                <span class="asComment">/* remove the edges */</span>
                edges <span class="asOperator">=</span> vn.node.inEdges.concat<span class="asBracket">(</span>vn.node.outEdges<span class="asBracket">)</span>;
                <span class="asReserved">for</span> <span class="asReserved">each</span><span class="asBracket">(</span>e <span class="asReserved">in</span> edges<span class="asBracket">)</span> <span class="asBracket">{</span>
                    <span class="asReserved">delete</span> _visibleEdges<span class="asBracket">[</span>e<span class="asBracket">]</span>;
                <span class="asBracket">}</span>
            <span class="asBracket">}</span>
            
            <span class="asComment">/* and all new visible nodes to visible */</span>
            <span class="asReserved">for</span> <span class="asReserved">each</span><span class="asBracket">(</span>vn <span class="asReserved">in</span> newVisibleNodes<span class="asBracket">)</span> <span class="asBracket">{</span>
                setNodeVisibility<span class="asBracket">(</span>vn, <span class="asReserved">true</span><span class="asBracket">)</span>;
                
                <span class="asComment">/* now here we have to test each edges othernode
                 * if it is also visible */</span>
                edges <span class="asOperator">=</span> vn.node.inEdges;
                edges <span class="asOperator">=</span> edges.concat<span class="asBracket">(</span>vn.node.outEdges<span class="asBracket">)</span>;
                <span class="asReserved">for</span> <span class="asReserved">each</span><span class="asBracket">(</span>e <span class="asReserved">in</span> edges<span class="asBracket">)</span> <span class="asBracket">{</span>
                    <span class="asComment">/* get the other node at the end of the edge */</span>
                    vno <span class="asOperator">=</span> e.othernode<span class="asBracket">(</span>vn.node<span class="asBracket">)</span>.vnode;
                    
                    <span class="asComment">/* if this node either is still visible or in the
                     * list to become visible, then the edge is also
                     * visible */</span>
                    <span class="asReserved">if</span><span class="asBracket">(</span>vno.isVisible <span class="asOperator">||</span> <span class="asBracket">(</span>newVisibleNodes<span class="asBracket">[</span>vno<span class="asBracket">]</span> <span class="asOperator">!=</span> <span class="asReserved">null</span><span class="asBracket">))</span> <span class="asBracket">{</span>
                        _visibleEdges<span class="asBracket">[</span>e<span class="asBracket">]</span> <span class="asOperator">=</span> e;
                    <span class="asBracket">}</span>
                <span class="asBracket">}</span>
                
            <span class="asBracket">}</span>
            
            <span class="asComment">/* now all node visibility is updated, so we can update the
             * edge visibility 
             * THIS IS STILL VERY BAD, HAVE TO FIND A SIMILAR SOLUTION AS FOR NODES */</span>
            <span class="asComment">/*
            _visibleEdges = new Dictionary;
            for each(e in _graph.edges) {
                /* if both vnodes are visible, we add the edge *
                if(e.node1.vnode.isVisible &amp;&amp; e.node2.vnode.isVisible) {
                    _visibleEdges[e] = e;        
                }
            }
            */</span>
            
            <span class="asComment">/* this restarts any layouting */</span>
            draw<span class="asBracket">()</span>;
        <span class="asBracket">}</span>

        <span class="asDoc">/**
         * Reset visibility of all nodes, all nodes are back to visible.
         * This can be a very very heavy operation if you have many nodes. 
         * */</span>
        <span class="asReserved">private</span> <span class="asFunction">function</span> setAllVisible<span class="asBracket">()</span><span class="asOperator">:</span><span class="asReserved">void</span> <span class="asBracket">{</span>
            <span class="asVar">var</span> n<span class="asOperator">:</span>INode;
            <span class="asVar">var</span> e<span class="asOperator">:</span>IEdge;
            
            <span class="asComment">/* since a layouter that uses timer based iterations
             * might find itself on a changing node set, we need
             * to stop/reset anything before altering the node
             * visibility */</span>
            _layouter.resetAll<span class="asBracket">()</span>;
            
            <span class="asComment">/* recreate those, this is cheaper probably */</span>
            _visibleVNodes <span class="asOperator">=</span> <span class="asReserved">new</span> Dictionary;
            _noVisibleVNodes <span class="asOperator">=</span> 0;
            
            <span class="asReserved">for</span> <span class="asReserved">each</span><span class="asBracket">(</span>n <span class="asReserved">in</span> _graph.nodes<span class="asBracket">)</span> <span class="asBracket">{</span>
                setNodeVisibility<span class="asBracket">(</span>n.vnode, <span class="asReserved">true</span><span class="asBracket">)</span>;
            <span class="asBracket">}</span>
            
            <span class="asComment">/* same for edges */</span>
            _visibleEdges <span class="asOperator">=</span> <span class="asReserved">new</span> Dictionary;
            <span class="asReserved">for</span> <span class="asReserved">each</span><span class="asBracket">(</span>e <span class="asReserved">in</span> _graph.edges<span class="asBracket">)</span> <span class="asBracket">{</span>
                _visibleEdges<span class="asBracket">[</span>e<span class="asBracket">]</span> <span class="asOperator">=</span> e;
            <span class="asBracket">}</span>
            draw<span class="asBracket">()</span>;
        <span class="asBracket">}</span>
    
        <span class="asDoc">/**
         * This sets a VNode visible or invisible, updating all related
         * data.
         * @param vn The VisualNode to be turned invisible or not.
         * @param visible The indicator if visible or not.
         * */</span>    
        <span class="asReserved">private</span> <span class="asFunction">function</span> setNodeVisibility<span class="asBracket">(</span>vn<span class="asOperator">:</span>IVisualNode, visible<span class="asOperator">:</span>Boolean<span class="asBracket">)</span><span class="asOperator">:</span><span class="asReserved">void</span> <span class="asBracket">{</span>
            
            <span class="asVar">var</span> comp<span class="asOperator">:</span>UIComponent;
            
            <span class="asComment">/* was there actually a change, if not issue a warning */</span>
            <span class="asReserved">if</span><span class="asBracket">(</span>vn.isVisible <span class="asOperator">===</span> visible<span class="asBracket">)</span> <span class="asBracket">{</span>
                <span class="asTrace">trace</span><span class="asBracket">(</span><span class="asString">&quot;Tried to set node:&quot;</span><span class="asOperator">+</span>vn.id<span class="asOperator">+</span><span class="asString">&quot; visibility to:&quot;</span><span class="asOperator">+</span>visible.toString<span class="asBracket">()</span><span class="asOperator">+</span><span class="asString">&quot; but it was already.&quot;</span><span class="asBracket">)</span>;
                <span class="asReserved">return</span>;
            <span class="asBracket">}</span>
            
            <span class="asReserved">if</span><span class="asBracket">(</span>visible <span class="asOperator">==</span> <span class="asReserved">true</span><span class="asBracket">)</span> <span class="asBracket">{</span>
                
                <span class="asComment">/* set the node to visible, this might create a view for it */</span>
                vn.isVisible <span class="asOperator">=</span> <span class="asReserved">true</span>;
                <span class="asComment">/* add it to the hash of currently visible nodes */</span>
                _visibleVNodes<span class="asBracket">[</span>vn<span class="asBracket">]</span> <span class="asOperator">=</span> vn;
                <span class="asComment">/* increase the counter */</span>
                <span class="asOperator">++</span>_noVisibleVNodes;
                
                <span class="asComment">/* create the node&apos;s view */</span>
                comp <span class="asOperator">=</span> createVNodeComponent<span class="asBracket">(</span>vn<span class="asBracket">)</span>;
                
                <span class="asComment">/* set it to visible, should be default anyway */</span>
                comp.visible <span class="asOperator">=</span> <span class="asReserved">true</span>;
                
            <span class="asBracket">}</span> <span class="asReserved">else</span> <span class="asBracket">{</span> <span class="asComment">// i.e. set to invisible 
</span>                <span class="asComment">/* render node invisible, thus potentially destroying its view */</span>
                vn.isVisible <span class="asOperator">=</span> <span class="asReserved">false</span>;
                <span class="asComment">/* remove it from the hash */</span>
                <span class="asReserved">delete</span> _visibleVNodes<span class="asBracket">[</span>vn<span class="asBracket">]</span>;
                <span class="asComment">/* decrease the counter */</span>
                <span class="asOperator">--</span>_noVisibleVNodes;
                
                <span class="asComment">/* remove the view if there is one */</span>
                <span class="asReserved">if</span><span class="asBracket">(</span>vn.view <span class="asOperator">!=</span> <span class="asReserved">null</span><span class="asBracket">)</span> <span class="asBracket">{</span>
                    removeComponent<span class="asBracket">(</span>vn.view, <span class="asReserved">false</span><span class="asBracket">)</span>;
                <span class="asBracket">}</span>
            <span class="asBracket">}</span>
        <span class="asBracket">}</span>
    <span class="asBracket">}</span>
<span class="asBracket">}</span></pre></body>
</html>
