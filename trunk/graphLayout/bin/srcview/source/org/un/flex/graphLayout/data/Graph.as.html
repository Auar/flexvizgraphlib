<!-- saved from url=(0014)about:internet -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<title>Graph.as</title>
<link rel="stylesheet" type="text/css" href="../../../../../../SourceStyles.css"/>
</head>

<body><pre><span class="asComment">/* 
 * The MIT License
 *
 * Copyright (c) 2007 The SixDegrees Project Team
 * (Jason Bellone, Juan Rodriguez, Segolene de Basquiat, Daniel Lang).
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the &quot;Software&quot;), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */</span>

<span class="asPackage">package</span> org.un.flex.graphLayout.data <span class="asBracket">{</span>
    <span class="asReserved">import</span> flash.utils.Dictionary;
    <span class="asReserved">import</span> mx.events.IndexChangedEvent;
    
    <span class="asDoc">/**
     * Graph implements a graph datastructure G(V,E)
     * with vertices V and edges E, except that we call the
     * vertices nodes, which is here more in line with similar
     * implementations. A graph may be associated with a 
     * VisualGraph object, which can visualize graph components
     * in Flash.
     * @see VisualGraph
     * @see Node
     * @see Edge
     * */</span>
    <span class="asReserved">public</span> <span class="asClass">class</span> Graph <span class="asReserved">implements</span> IGraph <span class="asBracket">{</span>
        
        <span class="asDoc">/**
         * The default XML tagname of an XML item that defines a node.
         * */</span>
        <span class="asReserved">public</span> <span class="asReserved">static</span> <span class="asReserved">const</span> DEFAULTNAME_NODE<span class="asOperator">:</span>String <span class="asOperator">=</span> <span class="asString">&quot;Node&quot;</span>;

        <span class="asDoc">/**
         * The default XML tagname of an XML item that defines an edge.
         * */</span>        
        <span class="asReserved">public</span> <span class="asReserved">static</span> <span class="asReserved">const</span> DEFAULTNAME_EDGE<span class="asOperator">:</span>String <span class="asOperator">=</span> <span class="asString">&quot;Edge&quot;</span>;

        <span class="asDoc">/**
         * The default XML attribute of an XML edge item that describes the from node.
         * */</span>
        <span class="asReserved">public</span> <span class="asReserved">static</span> <span class="asReserved">const</span> DEFAULTNAME_FROMID<span class="asOperator">:</span>String <span class="asOperator">=</span> <span class="asString">&quot;fromID&quot;</span>;

        <span class="asDoc">/**
         * The default XML attribute of an XML edge item that describes the to node.
         * */</span>
        <span class="asReserved">public</span> <span class="asReserved">static</span> <span class="asReserved">const</span> DEFAULTNAME_TOID<span class="asOperator">:</span>String <span class="asOperator">=</span> <span class="asString">&quot;toID&quot;</span>;
        
        <span class="asDoc">/**
         * @internal
         * attributes of a graph
         * */</span>
        <span class="asReserved">private</span> <span class="asVar">var</span> _id<span class="asOperator">:</span>String;
        <span class="asReserved">private</span> <span class="asVar">var</span> _nodes<span class="asOperator">:</span>Array;
        <span class="asReserved">private</span> <span class="asVar">var</span> _edges<span class="asOperator">:</span>Array;

        <span class="asComment">/* lookup by string id and by id */</span>
        <span class="asReserved">private</span> <span class="asVar">var</span> _nodesByStringId<span class="asOperator">:</span>Object;
        <span class="asReserved">private</span> <span class="asVar">var</span> _nodesById<span class="asOperator">:</span>Object;
        
        <span class="asComment">/* indicator if the graph is directional or not */</span>
        <span class="asReserved">private</span> <span class="asVar">var</span> _directional<span class="asOperator">:</span>Boolean;
        
        <span class="asDoc">/** 
         * @internal
         * these two serve as id for nodes and
         * and edges the id&apos;s will start from 1 (not 0) !!
         * and are always increased.
         * */</span>
        <span class="asReserved">private</span> <span class="asVar">var</span> _currentNodeId<span class="asOperator">:</span>int;
        <span class="asReserved">private</span> <span class="asVar">var</span> _currentEdgeId<span class="asOperator">:</span>int;
        
        <span class="asDoc">/**
         * @internal
         * these two serve as count for nodes and edges
         * and are also decreased if nodes or edges
         * are removed
         * */</span>
        <span class="asReserved">private</span> <span class="asVar">var</span> _numberOfNodes<span class="asOperator">:</span>int;
        <span class="asReserved">private</span> <span class="asVar">var</span> _numberOfEdges<span class="asOperator">:</span>int;
        
        <span class="asDoc">/**
         * @internal
         * for several algorithms we might need
         * BFS and DFS implementations, all related
         * to a specific root node.
         * */</span>
        <span class="asReserved">private</span> <span class="asVar">var</span> _treeMap<span class="asOperator">:</span>Dictionary;
        
        
        <span class="asDoc">/**
         * Constructor method that creates the graph and can
         * initialise it directly from an XML object, if one is specified.
         * 
         * @param id The id (or rather name) of the graph. Every graph has to have one.
         * @param directional Indicator if the graph is directional or not. Directional graphs have not been tested so far.
         * @param xmlsource an XML object that contains node and edge items that define the graph.
         * @param xmlnames an optional Array that contains XML tag and attribute names that define the graph. 
         * */</span>
        <span class="asReserved">public</span> <span class="asFunction">function</span> Graph<span class="asBracket">(</span>id<span class="asOperator">:</span>String <span class="asOperator">=</span> <span class="asString">&quot;&quot;</span>, directional<span class="asOperator">:</span>Boolean <span class="asOperator">=</span> <span class="asReserved">false</span>, xmlsource<span class="asOperator">:</span>XML <span class="asOperator">=</span> <span class="asReserved">null</span>, xmlnames<span class="asOperator">:</span>Array <span class="asOperator">=</span> <span class="asReserved">null</span><span class="asBracket">)</span><span class="asOperator">:</span><span class="asReserved">void</span> <span class="asBracket">{</span>
            _nodes <span class="asOperator">=</span> <span class="asReserved">new</span> Array;
            _edges <span class="asOperator">=</span> <span class="asReserved">new</span> Array;
            _treeMap <span class="asOperator">=</span> <span class="asReserved">new</span> Dictionary;
            
            _nodesByStringId <span class="asOperator">=</span> <span class="asReserved">new</span> Object;
            _nodesById <span class="asOperator">=</span> <span class="asReserved">new</span> Object;
            
            _directional <span class="asOperator">=</span> directional;
            _currentNodeId <span class="asOperator">=</span> 0;
            _currentEdgeId <span class="asOperator">=</span> 0;
            _numberOfNodes <span class="asOperator">=</span> 0;
            _numberOfEdges <span class="asOperator">=</span> 0;
            
            <span class="asReserved">if</span><span class="asBracket">(</span>id.length <span class="asOperator">&gt;</span> 0<span class="asBracket">)</span> <span class="asBracket">{</span>
                _id <span class="asOperator">=</span> id;
            <span class="asBracket">}</span> <span class="asReserved">else</span> <span class="asBracket">{</span>
                <span class="asComment">/* we may want to catch that error in the future
                 * but I leave it like that for now....
                 */</span>
                <span class="asReserved">throw</span> Error<span class="asBracket">(</span><span class="asString">&quot;Cannot create graph with empty id&quot;</span><span class="asBracket">)</span>;
            <span class="asBracket">}</span>
            
            <span class="asComment">//trace(&quot;Create graph with xmlsource:&quot;+xmlsource.toString());
</span>            
            <span class="asReserved">if</span><span class="asBracket">(</span>xmlsource <span class="asOperator">!=</span> <span class="asReserved">null</span><span class="asBracket">)</span> <span class="asBracket">{</span>
                <span class="asComment">//trace(&quot;Graph detected XML source:&quot;+xmlsource.name().toString());
</span>                initFromXML<span class="asBracket">(</span>xmlsource, xmlnames<span class="asBracket">)</span>;
            <span class="asBracket">}</span>
            
        <span class="asBracket">}</span>

        <span class="asDoc">/**
         * A static factory method to create new graphs, but requires an xmlsource to be specified.
         * 
         * @param id The id (or rather name) of the graph. Every graph has to have one.
         * @param directional Indicator if the graph is directional or not. Directional graphs have not been tested so far.
         * @param xmlsource an XML object that contains node and edge items that define the graph.
         * @param xmlnames an optional Array that contains XML tag and attribute names that define the graph. 
         * @return the created Graph object (i.e. an object that implements the IGraph interface.
         * @throws Error of the xmlsource is null.
         **/</span>
        <span class="asReserved">public</span> <span class="asReserved">static</span> <span class="asFunction">function</span> createGraph<span class="asBracket">(</span>id<span class="asOperator">:</span>String, directional<span class="asOperator">:</span>Boolean, xmlsource<span class="asOperator">:</span>XML, xmlnames<span class="asOperator">:</span>Array <span class="asOperator">=</span> <span class="asReserved">null</span><span class="asBracket">)</span><span class="asOperator">:</span>IGraph <span class="asBracket">{</span>
            <span class="asVar">var</span> g<span class="asOperator">:</span>IGraph;
            
            <span class="asReserved">if</span><span class="asBracket">(</span>xmlsource <span class="asOperator">==</span> <span class="asReserved">null</span><span class="asBracket">)</span> <span class="asBracket">{</span>
                <span class="asReserved">throw</span> Error<span class="asBracket">(</span><span class="asString">&quot;the xmlsource must not be null if creating a new Graph&quot;</span><span class="asBracket">)</span>;
                <span class="asReserved">return</span> <span class="asReserved">null</span>;
            <span class="asBracket">}</span>
            g <span class="asOperator">=</span> <span class="asReserved">new</span> Graph<span class="asBracket">(</span>id, directional, xmlsource, xmlnames<span class="asBracket">)</span>;
            <span class="asReserved">return</span> g;
        <span class="asBracket">}</span>

        <span class="asDoc">/**
         * @inheritDoc
         * */</span>
        <span class="asReserved">public</span> <span class="asFunction">function</span> <span class="asReserved">get</span> id<span class="asBracket">()</span><span class="asOperator">:</span>String <span class="asBracket">{</span>
            <span class="asReserved">return</span> _id;
        <span class="asBracket">}</span>        
        
        <span class="asDoc">/**
         * @inheritDoc
         * */</span>
        <span class="asReserved">public</span> <span class="asFunction">function</span> <span class="asReserved">get</span> nodes<span class="asBracket">()</span><span class="asOperator">:</span>Array <span class="asBracket">{</span>
            <span class="asReserved">return</span> _nodes;
        <span class="asBracket">}</span>
        
        <span class="asDoc">/**
         * @inheritDoc
         * */</span>
        <span class="asReserved">public</span> <span class="asFunction">function</span> <span class="asReserved">get</span> edges<span class="asBracket">()</span><span class="asOperator">:</span>Array <span class="asBracket">{</span>
            <span class="asReserved">return</span> _edges;
        <span class="asBracket">}</span>
        
        <span class="asDoc">/**
         * @inheritDoc
         * */</span>
        <span class="asReserved">public</span> <span class="asFunction">function</span> <span class="asReserved">get</span> isDirectional<span class="asBracket">()</span><span class="asOperator">:</span>Boolean <span class="asBracket">{</span>
            <span class="asReserved">return</span> _directional;
        <span class="asBracket">}</span>
        
        <span class="asDoc">/**
         * @inheritDoc
         * */</span>
        <span class="asReserved">public</span> <span class="asFunction">function</span> <span class="asReserved">get</span> noNodes<span class="asBracket">()</span><span class="asOperator">:</span>int <span class="asBracket">{</span>
            <span class="asReserved">return</span> _numberOfNodes;
        <span class="asBracket">}</span>

        <span class="asDoc">/**
         * @inheritDoc
         * */</span>
        <span class="asReserved">public</span> <span class="asFunction">function</span> <span class="asReserved">get</span> noEdges<span class="asBracket">()</span><span class="asOperator">:</span>int <span class="asBracket">{</span>
            <span class="asReserved">return</span> _numberOfEdges;
        <span class="asBracket">}</span>
    
        <span class="asDoc">/**
         * @inheritDoc
         * */</span>
        <span class="asReserved">public</span> <span class="asFunction">function</span> nodeByStringId<span class="asBracket">(</span>sid<span class="asOperator">:</span>String<span class="asBracket">)</span><span class="asOperator">:</span>INode <span class="asBracket">{</span>
            <span class="asReserved">if</span><span class="asBracket">(</span>_nodesByStringId.hasOwnProperty<span class="asBracket">(</span>sid<span class="asBracket">))</span> <span class="asBracket">{</span>
                <span class="asReserved">return</span> _nodesByStringId<span class="asBracket">[</span>sid<span class="asBracket">]</span>;
            <span class="asBracket">}</span> <span class="asReserved">else</span> <span class="asBracket">{</span>
                <span class="asReserved">return</span> <span class="asReserved">null</span>;
            <span class="asBracket">}</span>
        <span class="asBracket">}</span>
        
        <span class="asDoc">/**
         * @inheritDoc
         * */</span>
        <span class="asReserved">public</span> <span class="asFunction">function</span> nodeById<span class="asBracket">(</span>id<span class="asOperator">:</span>int<span class="asBracket">)</span><span class="asOperator">:</span>INode <span class="asBracket">{</span>
            <span class="asReserved">if</span><span class="asBracket">(</span>_nodesById.hasOwnProperty<span class="asBracket">(</span>id<span class="asBracket">))</span> <span class="asBracket">{</span>
                <span class="asReserved">return</span> _nodesById<span class="asBracket">[</span>id<span class="asBracket">]</span>;
            <span class="asBracket">}</span> <span class="asReserved">else</span> <span class="asBracket">{</span>
                <span class="asReserved">return</span> <span class="asReserved">null</span>;
            <span class="asBracket">}</span>
        <span class="asBracket">}</span>
    
        <span class="asDoc">/**
         * @inheritDoc
         * */</span>
        <span class="asReserved">public</span> <span class="asFunction">function</span> getTree<span class="asBracket">(</span>n<span class="asOperator">:</span>INode, restr<span class="asOperator">:</span>Boolean <span class="asOperator">=</span> <span class="asReserved">false</span><span class="asBracket">)</span><span class="asOperator">:</span>IGTree <span class="asBracket">{</span>
            <span class="asReserved">if</span><span class="asBracket">(</span><span class="asOperator">!</span>_treeMap.hasOwnProperty<span class="asBracket">(</span>n<span class="asBracket">))</span> <span class="asBracket">{</span>
                _treeMap<span class="asBracket">[</span>n<span class="asBracket">]</span> <span class="asOperator">=</span> <span class="asReserved">new</span> GTree<span class="asBracket">(</span>n,<span class="asReserved">this</span>,restr<span class="asBracket">)</span>;
                <span class="asComment">/* do the init now, not lazy */</span>
                <span class="asBracket">(</span>_treeMap<span class="asBracket">[</span>n<span class="asBracket">]</span> <span class="asReserved">as</span> IGTree<span class="asBracket">)</span>.initTree<span class="asBracket">()</span>;
            <span class="asBracket">}</span>
            <span class="asReserved">return</span> <span class="asBracket">(</span>_treeMap<span class="asBracket">[</span>n<span class="asBracket">]</span> <span class="asReserved">as</span> IGTree<span class="asBracket">)</span>;
        <span class="asBracket">}</span>
    
        <span class="asDoc">/**
         * @inheritDoc
         * */</span>
        <span class="asReserved">public</span> <span class="asFunction">function</span> purgeTrees<span class="asBracket">()</span><span class="asOperator">:</span><span class="asReserved">void</span> <span class="asBracket">{</span>
            _treeMap <span class="asOperator">=</span> <span class="asReserved">new</span> Dictionary;
        <span class="asBracket">}</span>
    
        <span class="asDoc">/**
         * @inheritDoc
         * */</span>
        <span class="asReserved">public</span> <span class="asFunction">function</span> initFromXML<span class="asBracket">(</span>xml<span class="asOperator">:</span>XML, xmlnames<span class="asOperator">:</span>Array<span class="asBracket">)</span><span class="asOperator">:</span><span class="asReserved">void</span> <span class="asBracket">{</span>
            
            <span class="asVar">var</span> nodeName<span class="asOperator">:</span>String <span class="asOperator">=</span> DEFAULTNAME_NODE;
            <span class="asVar">var</span> edgeName<span class="asOperator">:</span>String <span class="asOperator">=</span> DEFAULTNAME_EDGE;
            <span class="asVar">var</span> fromIDName<span class="asOperator">:</span>String <span class="asOperator">=</span> DEFAULTNAME_FROMID;
            <span class="asVar">var</span> toIDName<span class="asOperator">:</span>String <span class="asOperator">=</span> DEFAULTNAME_TOID;

            <span class="asVar">var</span> xnode<span class="asOperator">:</span>XML;
            <span class="asVar">var</span> xedge<span class="asOperator">:</span>XML;
            
            <span class="asVar">var</span> fromNodeId<span class="asOperator">:</span>String;
            <span class="asVar">var</span> toNodeId<span class="asOperator">:</span>String;
    
            <span class="asVar">var</span> fromNode<span class="asOperator">:</span>INode;
            <span class="asVar">var</span> toNode<span class="asOperator">:</span>INode;

            <span class="asReserved">if</span><span class="asBracket">(</span>xmlnames <span class="asOperator">!=</span> <span class="asReserved">null</span><span class="asBracket">)</span> <span class="asBracket">{</span>
                nodeName <span class="asOperator">=</span> xmlnames<span class="asBracket">[</span>0<span class="asBracket">]</span>;
                edgeName <span class="asOperator">=</span> xmlnames<span class="asBracket">[</span>1<span class="asBracket">]</span>;
                fromIDName <span class="asOperator">=</span> xmlnames<span class="asBracket">[</span>2<span class="asBracket">]</span>;
                toIDName <span class="asOperator">=</span> xmlnames<span class="asBracket">[</span>3<span class="asBracket">]</span>;
            <span class="asBracket">}</span>
            
            <span class="asComment">//trace(&quot;initFromXML called&quot;);
</span>            
            <span class="asReserved">for</span> <span class="asReserved">each</span><span class="asBracket">(</span>xnode <span class="asReserved">in</span> xml.descendants<span class="asBracket">(</span>nodeName<span class="asBracket">))</span> <span class="asBracket">{</span>
                <span class="asComment">/* we add the xml node id as string id and the xml
                 * node data as data object */</span>
                fromNode <span class="asOperator">=</span> createNode<span class="asBracket">(</span>xnode.@id, xnode<span class="asBracket">)</span>;
                <span class="asComment">//trace(&quot;Node:&quot;+fromNode.stringid+&quot; created, total:&quot;+_nodes.length);
</span>            <span class="asBracket">}</span>
            
            <span class="asReserved">for</span> <span class="asReserved">each</span><span class="asBracket">(</span>xedge <span class="asReserved">in</span> xml.descendants<span class="asBracket">(</span>edgeName<span class="asBracket">))</span> <span class="asBracket">{</span>
                fromNodeId <span class="asOperator">=</span> xedge.attribute<span class="asBracket">(</span>fromIDName<span class="asBracket">)</span>;
                toNodeId <span class="asOperator">=</span> xedge.attribute<span class="asBracket">(</span>toIDName<span class="asBracket">)</span>;
                
                fromNode <span class="asOperator">=</span> nodeByStringId<span class="asBracket">(</span>fromNodeId<span class="asBracket">)</span>;
                toNode <span class="asOperator">=</span> nodeByStringId<span class="asBracket">(</span>toNodeId<span class="asBracket">)</span>;
                
                <span class="asComment">/* we do not throw an error here, because the data
                 * is often inconsistent. In this case we just ignore
                 * the edge */</span>
                <span class="asReserved">if</span><span class="asBracket">(</span>fromNode <span class="asOperator">==</span> <span class="asReserved">null</span><span class="asBracket">)</span> <span class="asBracket">{</span>
                    <span class="asTrace">trace</span><span class="asBracket">(</span><span class="asString">&quot;Node id: &quot;</span><span class="asOperator">+</span>fromNodeId<span class="asOperator">+</span><span class="asString">&quot; not found, link not done&quot;</span><span class="asBracket">)</span>;
                    <span class="asReserved">continue</span>;
                <span class="asBracket">}</span>
                <span class="asReserved">if</span><span class="asBracket">(</span>toNode <span class="asOperator">==</span> <span class="asReserved">null</span><span class="asBracket">)</span> <span class="asBracket">{</span>
                    <span class="asTrace">trace</span><span class="asBracket">(</span><span class="asString">&quot;Node id: &quot;</span><span class="asOperator">+</span>toNodeId<span class="asOperator">+</span><span class="asString">&quot; not found, link not done&quot;</span><span class="asBracket">)</span>;
                    <span class="asReserved">continue</span>;
                <span class="asBracket">}</span>
                link<span class="asBracket">(</span>fromNode,toNode,xedge<span class="asBracket">)</span>;
                <span class="asComment">//trace(&quot;Current nr of edges:&quot;+_edges.length);
</span>            <span class="asBracket">}</span>
        <span class="asBracket">}</span>

    
        <span class="asDoc">/**
         * @inheritDoc
         * */</span>
        <span class="asReserved">public</span> <span class="asFunction">function</span> createNode<span class="asBracket">(</span>sid<span class="asOperator">:</span>String <span class="asOperator">=</span> <span class="asString">&quot;&quot;</span>, o<span class="asOperator">:</span>Object <span class="asOperator">=</span> <span class="asReserved">null</span><span class="asBracket">)</span><span class="asOperator">:</span>INode <span class="asBracket">{</span>
            
            <span class="asComment">/* we allow to pass a string id, e.g. it can originate
             * from the XML file.*/</span>
            
            <span class="asVar">var</span> myid<span class="asOperator">:</span>int <span class="asOperator">=</span> <span class="asOperator">++</span>_currentNodeId;
            <span class="asVar">var</span> mysid<span class="asOperator">:</span>String <span class="asOperator">=</span> sid;
            <span class="asVar">var</span> myNode<span class="asOperator">:</span>Node;
            
            <span class="asReserved">if</span><span class="asBracket">(</span>mysid <span class="asOperator">==</span> <span class="asString">&quot;&quot;</span><span class="asBracket">)</span> <span class="asBracket">{</span>
                mysid <span class="asOperator">=</span> myid.toString<span class="asBracket">()</span>;
            <span class="asBracket">}</span>
            
            <span class="asComment">/* avoid using a duplicate string id */</span>
            <span class="asReserved">if</span><span class="asBracket">(</span>_nodesByStringId.hasOwnProperty<span class="asBracket">(</span>mysid<span class="asBracket">))</span> <span class="asBracket">{</span>
                <span class="asReserved">throw</span> Error<span class="asBracket">(</span><span class="asString">&quot;sid: &quot;</span><span class="asOperator">+</span>mysid<span class="asOperator">+</span><span class="asString">&quot; already in use, node not created&quot;</span><span class="asBracket">)</span>;
            <span class="asBracket">}</span>
            
            <span class="asComment">/* 
             * see below when we link nodes, we cannot yet 
             * set the visual counterpart, but we have setter/getters
             * for the attribute, have to consider which
             * component must be created first
             * consider also to just pass it to the abstract graph
             * but more likely, we initialise the abstract graph
             * from a graphML XML file, when it is there, then we build
             * all the visual objects 
             */</span>
            
            myNode <span class="asOperator">=</span> <span class="asReserved">new</span> Node<span class="asBracket">(</span>myid,mysid,<span class="asReserved">null</span>,o<span class="asBracket">)</span>;
            
            _nodes.unshift<span class="asBracket">(</span>myNode<span class="asBracket">)</span>;
            _nodesByStringId<span class="asBracket">[</span>mysid<span class="asBracket">]</span> <span class="asOperator">=</span> myNode;
            _nodesById<span class="asBracket">[</span>myid<span class="asBracket">]</span> <span class="asOperator">=</span> myNode;
            <span class="asOperator">++</span>_numberOfNodes;
            
            <span class="asComment">/* a new node means all potentially existing
             * trees in the treemap need to be invalidated */</span>
            _treeMap <span class="asOperator">=</span> <span class="asReserved">new</span> Dictionary;
            
            <span class="asReserved">return</span> myNode;
        <span class="asBracket">}</span>
        
        <span class="asDoc">/**
         * @inheritDoc
         * */</span>
        <span class="asReserved">public</span> <span class="asFunction">function</span> removeNode<span class="asBracket">(</span>n<span class="asOperator">:</span>INode<span class="asBracket">)</span><span class="asOperator">:</span><span class="asReserved">void</span> <span class="asBracket">{</span>
            <span class="asComment">/* we check if inEdges or outEdges
             * are not empty. This also works for
             * non directional graphs, even though one
             * comparison would be sufficient */</span>
            <span class="asReserved">if</span><span class="asBracket">(</span>n.inEdges.length <span class="asOperator">&gt;</span> 0 <span class="asOperator">||</span> n.outEdges.length <span class="asOperator">&gt;</span> 0<span class="asBracket">)</span> <span class="asBracket">{</span>
                   <span class="asReserved">throw</span> Error<span class="asBracket">(</span><span class="asString">&quot;Attempted to remove Node: &quot;</span><span class="asOperator">+</span>n.id<span class="asOperator">+</span><span class="asString">&quot; but it still has Edges&quot;</span><span class="asBracket">)</span>;
            <span class="asBracket">}</span> <span class="asReserved">else</span> <span class="asBracket">{</span>
                <span class="asComment">/* XXXX searching like this through arrays takes
                 * LINEAR time, so at one point we might want to add
                 * associative arrays (possibly Dictionaries) to map
                 * the objects back to their index... */</span>
                <span class="asVar">var</span> myindex<span class="asOperator">:</span>int <span class="asOperator">=</span> _nodes.indexOf<span class="asBracket">(</span>n<span class="asBracket">)</span>;
                
                <span class="asComment">/* check if node was not found */</span>
                <span class="asReserved">if</span><span class="asBracket">(</span>myindex <span class="asOperator">==</span> <span class="asOperator">-</span>1<span class="asBracket">)</span> <span class="asBracket">{</span>
                    <span class="asReserved">throw</span> Error<span class="asBracket">(</span><span class="asString">&quot;Node: &quot;</span><span class="asOperator">+</span>n.id<span class="asOperator">+</span><span class="asString">&quot; was not found in the graph&apos;s&quot;</span> <span class="asOperator">+</span>
                    <span class="asString">&quot;node table while trying to delete it&quot;</span><span class="asBracket">)</span>;
                <span class="asBracket">}</span>
                
                <span class="asComment">// HMMM we assume that the throw will abort the script
</span>                <span class="asComment">// but I am not sure, we&apos;ll see
</span>                <span class="asComment">//trace(&quot;PASSED Check for node in _node list&quot;);
</span>                
                <span class="asComment">/* remove node from list */</span>
                _nodes.splice<span class="asBracket">(</span>myindex,1<span class="asBracket">)</span>;
                <span class="asOperator">--</span>_numberOfNodes;
                
                <span class="asComment">/* we need to do something about vnodes */</span>
                <span class="asReserved">if</span><span class="asBracket">(</span>n.vnode <span class="asOperator">!=</span> <span class="asReserved">null</span><span class="asBracket">)</span> <span class="asBracket">{</span>
                    <span class="asReserved">throw</span> Error<span class="asBracket">(</span><span class="asString">&quot;Node is still associated with its vnode, this leaves a dangling reference and a potential memory leak&quot;</span><span class="asBracket">)</span>;
                <span class="asBracket">}</span>
                
                <span class="asComment">/* node should have no longer a reference now
                 * so the GarbageCollector will get it */</span>
                
                <span class="asComment">/* invalidate trees */</span>
                _treeMap <span class="asOperator">=</span> <span class="asReserved">new</span> Dictionary;
            <span class="asBracket">}</span>
        <span class="asBracket">}</span>
        
        <span class="asDoc">/**
         * @inheritDoc
         * */</span>
        <span class="asReserved">public</span> <span class="asFunction">function</span> link<span class="asBracket">(</span>node1<span class="asOperator">:</span>INode, node2<span class="asOperator">:</span>INode, o<span class="asOperator">:</span>Object <span class="asOperator">=</span> <span class="asReserved">null</span><span class="asBracket">)</span><span class="asOperator">:</span>IEdge <span class="asBracket">{</span>
            
            <span class="asVar">var</span> retEdge<span class="asOperator">:</span>IEdge;
            
            <span class="asReserved">if</span><span class="asBracket">(</span>node1 <span class="asOperator">==</span> <span class="asReserved">null</span><span class="asBracket">)</span> <span class="asBracket">{</span>
                <span class="asReserved">throw</span> Error<span class="asBracket">(</span><span class="asString">&quot;link: node1 was null&quot;</span><span class="asBracket">)</span>;
            <span class="asBracket">}</span>
            <span class="asReserved">if</span><span class="asBracket">(</span>node2 <span class="asOperator">==</span> <span class="asReserved">null</span><span class="asBracket">)</span> <span class="asBracket">{</span>
                <span class="asReserved">throw</span> Error<span class="asBracket">(</span><span class="asString">&quot;link: node2 was null&quot;</span><span class="asBracket">)</span>;
            <span class="asBracket">}</span>
            
            <span class="asComment">/* check if a link already exists */</span>
            <span class="asReserved">if</span><span class="asBracket">(</span>node1.successors.indexOf<span class="asBracket">(</span>node2<span class="asBracket">)</span> <span class="asOperator">!=</span> <span class="asOperator">-</span>1<span class="asBracket">)</span> <span class="asBracket">{</span>
                <span class="asComment">/* we should give an error message, but
                 * there is no need to abort the script
                 * we should just do nothing */</span>
                <span class="asTrace">trace</span><span class="asBracket">(</span><span class="asString">&quot;Link between nodes:&quot;</span><span class="asOperator">+</span>node1.id<span class="asOperator">+</span><span class="asString">&quot; and &quot;</span><span class="asOperator">+</span>
                node2.id<span class="asOperator">+</span><span class="asString">&quot; already exists, returning existing edge&quot;</span><span class="asBracket">)</span>;
                
                <span class="asComment">/* oh in fact, we should return the edge that was found 
                 * this was more complicated than I thought and I am
                 * not tooo happy with this way....*/</span>
                <span class="asVar">var</span> outedges<span class="asOperator">:</span>Array <span class="asOperator">=</span> node1.outEdges;
                <span class="asReserved">for</span> <span class="asReserved">each</span> <span class="asBracket">(</span><span class="asVar">var</span> edge<span class="asOperator">:</span>Edge <span class="asReserved">in</span> outedges<span class="asBracket">)</span> <span class="asBracket">{</span>
                    <span class="asReserved">if</span><span class="asBracket">(</span>edge.node2 <span class="asOperator">==</span> node2<span class="asBracket">)</span> <span class="asBracket">{</span>
                        retEdge <span class="asOperator">=</span> edge;
                        <span class="asReserved">break</span>;
                    <span class="asBracket">}</span>
                <span class="asBracket">}</span>
                <span class="asReserved">if</span><span class="asBracket">(</span>retEdge <span class="asOperator">==</span> <span class="asReserved">null</span><span class="asBracket">)</span> <span class="asBracket">{</span>
                    <span class="asReserved">throw</span> Error<span class="asBracket">(</span><span class="asString">&quot;We did not find the edge although it should be there&quot;</span><span class="asBracket">)</span>;
                <span class="asBracket">}</span>
            <span class="asBracket">}</span> <span class="asReserved">else</span> <span class="asBracket">{</span>
                <span class="asComment">// link does not exist, so we can create it
</span>                <span class="asVar">var</span> newEid<span class="asOperator">:</span>int <span class="asOperator">=</span> <span class="asOperator">++</span>_currentEdgeId;
                <span class="asComment">/* not sure where we will be able to set the visual edge
                 * as it must exist first, for now we pass null 
                 * since the attribute has also a setter */</span>
                <span class="asVar">var</span> newEdge<span class="asOperator">:</span>Edge <span class="asOperator">=</span> <span class="asReserved">new</span> Edge<span class="asBracket">(</span><span class="asReserved">this</span>,<span class="asReserved">null</span>,newEid,node1,node2,o<span class="asBracket">)</span>;
                _edges.unshift<span class="asBracket">(</span>newEdge<span class="asBracket">)</span>;
                <span class="asOperator">++</span>_numberOfEdges;
                
                <span class="asComment">/* now register the edge with its nodes */</span>
                node1.addOutEdge<span class="asBracket">(</span>newEdge<span class="asBracket">)</span>;
                node2.addInEdge<span class="asBracket">(</span>newEdge<span class="asBracket">)</span>;
                
                <span class="asComment">/* if we are a NON directional graph we would have
                 * to add another edge also vice versa (in the other
                 * direction), but that leaves us with the question
                 * which of the edges to return.... maybe it can be
                 * handled using the same edge, if the in the directional
                 * case, the edge returns always the other node */</span>
                <span class="asComment">//trace(&quot;Graph is directional? &quot;+_directional.toString());
</span>                <span class="asReserved">if</span><span class="asBracket">(</span><span class="asOperator">!</span>_directional<span class="asBracket">)</span> <span class="asBracket">{</span>
                    node1.addInEdge<span class="asBracket">(</span>newEdge<span class="asBracket">)</span>;
                    node2.addOutEdge<span class="asBracket">(</span>newEdge<span class="asBracket">)</span>;
                    <span class="asComment">//trace(&quot;graph is not directional adding same edge:&quot;+newEdge.id+
</span>                    <span class="asComment">//&quot; the other way round&quot;);
</span>                <span class="asBracket">}</span>
                retEdge <span class="asOperator">=</span> newEdge;
            <span class="asBracket">}</span>
                            
            <span class="asComment">/* invalidate trees */</span>
            _treeMap <span class="asOperator">=</span> <span class="asReserved">new</span> Dictionary;
            <span class="asReserved">return</span> retEdge;
        <span class="asBracket">}</span>
        
        <span class="asDoc">/**
         * @inheritDoc
         * */</span>
        <span class="asReserved">public</span> <span class="asFunction">function</span> unlink<span class="asBracket">(</span>node1<span class="asOperator">:</span>INode, node2<span class="asOperator">:</span>INode<span class="asBracket">)</span><span class="asOperator">:</span><span class="asReserved">void</span> <span class="asBracket">{</span>

            <span class="asComment">/* find the corresponding edge first */</span>
            <span class="asVar">var</span> e<span class="asOperator">:</span>IEdge;
            
            e <span class="asOperator">=</span> getEdge<span class="asBracket">(</span>node1,node2<span class="asBracket">)</span>;
            
            <span class="asReserved">if</span><span class="asBracket">(</span>e <span class="asOperator">==</span> <span class="asReserved">null</span><span class="asBracket">)</span> <span class="asBracket">{</span>
                <span class="asReserved">throw</span> Error<span class="asBracket">(</span><span class="asString">&quot;Could not find edge, Nodes: &quot;</span><span class="asOperator">+</span>node1.id<span class="asOperator">+</span><span class="asString">&quot; and &quot;</span>
                <span class="asOperator">+</span>node2.id<span class="asOperator">+</span><span class="asString">&quot; may not be linked.&quot;</span><span class="asBracket">)</span>;
            <span class="asBracket">}</span> <span class="asReserved">else</span> <span class="asBracket">{</span>
                removeEdge<span class="asBracket">(</span>e<span class="asBracket">)</span>;
            <span class="asBracket">}</span>
        <span class="asBracket">}</span>
        
        <span class="asDoc">/**
         * @inheritDoc
         * */</span>
        <span class="asReserved">public</span> <span class="asFunction">function</span> getEdge<span class="asBracket">(</span>n1<span class="asOperator">:</span>INode, n2<span class="asOperator">:</span>INode<span class="asBracket">)</span><span class="asOperator">:</span>IEdge <span class="asBracket">{</span>
            <span class="asVar">var</span> outedges<span class="asOperator">:</span>Array <span class="asOperator">=</span> n1.outEdges;
            <span class="asVar">var</span> e<span class="asOperator">:</span>IEdge <span class="asOperator">=</span> <span class="asReserved">null</span>;
            <span class="asReserved">for</span> <span class="asReserved">each</span> <span class="asBracket">(</span><span class="asVar">var</span> edge<span class="asOperator">:</span>Edge <span class="asReserved">in</span> outedges<span class="asBracket">)</span> <span class="asBracket">{</span>
                <span class="asReserved">if</span><span class="asBracket">(</span>edge.othernode<span class="asBracket">(</span>n1<span class="asBracket">)</span> <span class="asOperator">==</span> n2<span class="asBracket">)</span> <span class="asBracket">{</span>
                    e <span class="asOperator">=</span> edge;
                    <span class="asReserved">return</span> e;
                <span class="asBracket">}</span>
            <span class="asBracket">}</span>
            <span class="asReserved">return</span> <span class="asReserved">null</span>;
        <span class="asBracket">}</span>
        
        <span class="asDoc">/**
         * @inheritDoc
         * */</span>
        <span class="asReserved">public</span> <span class="asFunction">function</span> removeEdge<span class="asBracket">(</span>e<span class="asOperator">:</span>IEdge<span class="asBracket">)</span><span class="asOperator">:</span><span class="asReserved">void</span> <span class="asBracket">{</span>
            <span class="asVar">var</span> n1<span class="asOperator">:</span>INode <span class="asOperator">=</span> e.node1;
            <span class="asVar">var</span> n2<span class="asOperator">:</span>INode <span class="asOperator">=</span> e.node2;
            <span class="asVar">var</span> edgeIndex<span class="asOperator">:</span>int <span class="asOperator">=</span> _edges.indexOf<span class="asBracket">(</span>e<span class="asBracket">)</span>;
            
            <span class="asReserved">if</span><span class="asBracket">(</span>edgeIndex <span class="asOperator">==</span> <span class="asOperator">-</span>1<span class="asBracket">)</span> <span class="asBracket">{</span>
                <span class="asReserved">throw</span> Error<span class="asBracket">(</span><span class="asString">&quot;Edge: &quot;</span><span class="asOperator">+</span>e.id<span class="asOperator">+</span><span class="asString">&quot; does not seem to exist in graph &quot;</span><span class="asOperator">+</span>_id<span class="asBracket">)</span>;
                <span class="asComment">// here we would need to abort the script
</span>            <span class="asBracket">}</span>
            
            n1.removeOutEdge<span class="asBracket">(</span>e<span class="asBracket">)</span>;
            n2.removeInEdge<span class="asBracket">(</span>e<span class="asBracket">)</span>;
            
            <span class="asComment">/* if we are NOT directed, we also 
             * have to remove the other way round */</span>
            <span class="asReserved">if</span><span class="asBracket">(</span><span class="asOperator">!</span>_directional<span class="asBracket">)</span> <span class="asBracket">{</span>
                n1.removeInEdge<span class="asBracket">(</span>e<span class="asBracket">)</span>;
                n2.removeOutEdge<span class="asBracket">(</span>e<span class="asBracket">)</span>;
            <span class="asBracket">}</span>
            
            <span class="asComment">/* now remove from the list of edges */</span>
            _edges.splice<span class="asBracket">(</span>edgeIndex,1<span class="asBracket">)</span>;
            <span class="asOperator">--</span>_numberOfEdges;
            
            <span class="asComment">/* invalidate trees */</span>
            _treeMap <span class="asOperator">=</span> <span class="asReserved">new</span> Dictionary;
        <span class="asBracket">}</span>                        
    <span class="asBracket">}</span>
<span class="asBracket">}</span></pre></body>
</html>
